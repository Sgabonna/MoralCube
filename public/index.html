<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>The Moral Cube</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" />
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600&family=Inter:wght@400;500&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Spline+Sans+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
body {
  padding: 0;
  margin: 0;
  background-color: var(--bg-dark-primary);
  color: var(--text-light);
  font-family: 'Spline Sans Mono', monospace;
  overflow-x: hidden;
  width: 100%;
}
:root {
  /* Dark theme colors from your design */
  --bg-dark-primary: #04031d;
  --bg-dark-secondary: #14132c;
  --bg-dark-tertiary: #191832;
  --bg-dark-quaternary: #201e36;
  --text-light: #bbbbc3;
  --text-lighter: #f7e2d3;
  
  /* Category colors */
  --evil-color: #ff36c4;
  --virtue-color: #4ade80;
  --vice-color: #fcbd21;
  --sin-color: #9e005d;
  --morally-grey-color: #a1a1aa;
  --world-building-color: #7f47dd;
}
.main-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  background: var(--bg-dark-secondary);
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,.3);
  width: 100%;
}

.plot-container {
background-color: white;
border-radius: 6px;
padding: 5px;
height: 400px;
display: flex;
align-items: center;
justify-content: center;
}

#cube-plot {
width: 100%;
height: 100%;
}
.page-header {
border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

/* Update all headings */
h1, h2, h3, h4, h5, h6 {
  font-family: 'Spline Sans Mono', monospace;
  color: var(--text-lighter);
}

/* Navigation styling */
.navbar-nav .nav-link {
  font-family: 'Spline Sans Mono', monospace !important;
  font-weight: 400 !important;
  font-size: 0.9rem !important;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--text-light) !important;
  padding: 0.7rem 1.5rem;
  transition: all 0.3s ease;
  border-radius: 0;
  position: relative;
}

.navbar-nav .nav-link:hover {
  color: var(--text-lighter) !important;
  background-color: rgba(255, 255, 255, 0.05);
}

.navbar-nav .nav-item {
position: relative;
}

.navbar-nav .nav-item:not(:last-child)::after {
content: "";
position: absolute;
right: -3px;
top: 50%;
transform: translateY(-50%);
height: 4px;
width: 4px;
border-radius: 50%;
background-color: #718096;
opacity: 0.5;
}

@media (max-width: 991.98px) {
.navbar-nav .nav-item:not(:last-child)::after {
display: none;
}

.navbar-nav .nav-item {
text-align: center;
}
}
.category-badge {
display: inline-block;
padding: 0.25em 0.6em;
font-size: 0.9rem;
font-weight: 500;
border-radius: 4px;
margin-left: 0.5rem;
}

.category-evil {
  background-color: var(--evil-color);
  color: white;
  font-family: 'Spline Sans Mono', monospace;
  font-size: 0.8rem;
}

.category-virtue {
  background-color: var(--virtue-color);
  color: var(--bg-dark-primary);
  font-family: 'Spline Sans Mono', monospace;
  font-size: 0.8rem;
}

.category-vice {
  background-color: var(--vice-color);
  color: var(--bg-dark-primary);
  font-family: 'Spline Sans Mono', monospace;
  font-size: 0.8rem;
}

.category-sin {
  background-color: var(--sin-color);
  color: white;
  font-family: 'Spline Sans Mono', monospace;
  font-size: 0.8rem;
}

.category-morally-grey {
  background-color: var(--morally-grey-color);
  color: white;
  font-family: 'Spline Sans Mono', monospace;
  font-size: 0.8rem;
}

.category-world-building {
  background-color: var(--world-building-color);
  color: white;
  font-family: 'Spline Sans Mono', monospace;
  font-size: 0.8rem;
}

/* Philosophical Analysis Filter Styles */
.philosophical-filter {
margin-top: 0;
}

.philosophical-theory {
margin-bottom: 12px;
}

.philosophical-theory-label {
font-size: 0.85rem;
font-weight: 600;
margin-bottom: 6px;
color: #2d3748;
}

.philosophical-buttons {
display: flex;
gap: 6px;
}

.phil-button {
width: 30px;
height: 30px;
border: 2px solid #e2e8f0;
border-radius: 6px;
cursor: pointer;
display: flex;
align-items: center;
justify-content: center;
font-size: 0.9rem;
font-weight: bold;
transition: all 0.2s ease;
background-color: white;
}

.phil-button:hover {
border-color: #a0aec0;
transform: translateY(-1px);
}

.phil-button.active {
border-width: 3px;
transform: scale(1.1);
}

.phil-button.right {
color: #38a169;
border-color: #38a169;
}

.phil-button.right.active {
background-color: #f0fff4;
border-color: #2d7738;
}

.phil-button.wrong {
color: #e53e3e;
border-color: #e53e3e;
}

.phil-button.wrong.active {
background-color: #fff5f5;
border-color: #c53030;
}

.phil-button.other {
color: #718096;
border-color: #718096;
}

.phil-button.other.active {
background-color: #f7fafc;
border-color: #4a5568;
}

.phil-button.highlighted {
box-shadow: 0 0 8px rgba(66, 153, 225, 0.6);
border-color: #4299e1;
}

.parent-marker {
border: 2px solid #000;
opacity: 1 !important;
}

.child-marker {
border: 1px dashed #666;
}
/* For compact tables in scenario details */
.compact-table {
font-size: 0.75rem;  /* Reduced font size (2 points smaller than before) */
margin-bottom: 10px; /* Adds gap after the table */
}

.compact-table th,
.compact-table td {
padding: 4px 6px;    /* Reduced cell padding for a more compact row height */
vertical-align: middle;
}

/* Optional: if you want additional gap below the table container */
.scenario-table-container {
margin-bottom: 10px;
}

/* (Optional) Adjust header font sizes if needed */
.compact-table th {
font-weight: bold;
}
.compact-table td {
overflow: visible;
position: relative; /* Ensure that the tooltip is positioned relative to the cell */
}   

.relationship-line {
stroke-dasharray: 5,5;
opacity: 0.6;
}

.selected-scenario {
border: 3px solid #0d6efd;
box-shadow: 0 0 5px rgba(13, 110, 253, 0.5);
}
.selected-card {
background-color: var(--bg-dark-quaternary); /* dark mode selected card background */
border: 2px solid var(--virtue-color);
/* Optional: add a box-shadow for extra emphasis */
box-shadow: 0 0 5px rgba(0, 193, 182, 0.8);
}

.relationship-badge {
font-size: 0.8rem;
padding: 0.2em 0.5em;
border-radius: 3px;
margin-left: 0.5rem;
background-color: #e9ecef;
color: #495057;
}

.relationship-active {
background-color: #0d6efd;
color: white;
}

.filter-section {
background-color: var(--bg-dark-tertiary);
border: 1px solid rgba(255, 255, 255, 0.1);
color: var(--text-light);
padding: 20px;
border-radius: 6px;
margin-bottom: 20px;
display: grid;
grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
gap: 20px;
}

.filter-group {
margin-bottom: 15px;
}

/* Specific styling for the alternate outcomes select */
#alternateOutcomes {
width: 100%;
min-height: 150px;
}

/* Add consistent label styling */
.filter-group label {
display: block;
margin-bottom: 8px;
font-weight: 600;
font-size: 14px;
}

.filter-group label {
font-weight: 600;
display: block;
margin-bottom: 8px;
}

.filter-badges {
display: flex;
flex-direction: column;
gap: 8px;
margin-top: 10px;
}

.filter-badge {
padding: 4px 12px;
border-radius: 20px;
cursor: pointer;
opacity: 0.6;
transition: opacity 0.3s;
user-select: none;
}

.filter-badge.active {
opacity: 1;
background-color: var(--bg-dark-quaternary) !important;
color: white !important;
}

.info-icon {
color: #0d6efd;
font-size: 0.875rem;
margin-left: 0.5rem;
cursor: help;
}

/* Initially hide the ethics scores in each card */
.comparison-card .ethics-scores {
display: none;
}

/* When the card is expanded, show the ethics scores */
.comparison-card.expanded .ethics-scores {
display: block;
}

/* New container for the three columns */
#overview-section {
display: flex;
width: 100%;
box-sizing: border-box;
gap: 10px; /* Add gap for better spacing */
}

#cube-column {
width: 37%;
min-width: 0; /* Prevent overflow */
}

#cards-column {
width: 18%;
padding: 0 10px;
min-width: 0;
}

#placeholder-overview-column {
width: 45%;
padding: 0 10px;
display: flex;
flex-direction: column;
height: 500px;
min-width: 0;
}

::-webkit-scrollbar {
  width: 10px;
}

::-webkit-scrollbar-track {
  background: var(--bg-dark-tertiary);
}

::-webkit-scrollbar-thumb {
  background: var(--bg-dark-quaternary);
  border-radius: 5px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.2);
}


/* The container for the stacked overview cards:
       Fixed height for 5 cards (e.g., 500px total) */
#overview {
height: 500px;            /* Adjust if needed */
overflow: hidden;         /* By default, hide overflow */
display: flex;
flex-direction: column;
justify-content: flex-start;
}



.tooltip {
position: relative;
display: inline-block;
}

.tooltip-container {
position: relative;
display: inline-flex;
align-items: center;
margin-left: 8px;
vertical-align: middle;
}

.tooltip-icon {
color: #0d6efd;
font-size: 14px;
cursor: help;
opacity: 0.8;
transition: opacity 0.2s;
}

.tooltip-icon:hover {
opacity: 1;
}

.tooltip-content {
visibility: hidden;
opacity: 0;
position: absolute;
bottom: 150%;
left: 20px; /* Base positioning for all tooltips */
padding: 8px 12px;
background-color: #2d3748;
color: white;
border-radius: 6px;
font-size: 13px;
line-height: 1.4;
white-space: normal;
max-width: 300px;
width: max-content;
z-index: 1000;
transition: all 0.2s ease;
box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
text-align: left;
}

/* Remove all left/right specific rules and use the same positioning for both */
.tooltip-container .tooltip-content {
left: 5px;
right: auto;
transform: none;
}

.tooltip-container .tooltip-content::after {
left: 5px;
right: auto;
transform: none;
}

.tooltip-container:hover .tooltip-content {
visibility: visible;
opacity: 1;
bottom: 140%;
}

.tooltip-content::after {
content: "";
position: absolute;
top: 100%;
border-width: 6px;
border-style: solid;
border-color: #2d3748 transparent transparent transparent;
}

/* Remove any specific first-child or last-child rules that might override */
.tooltip-container:first-child .tooltip-content,
.tooltip-container:last-child .tooltip-content {
left: 5px;
right: auto;
}

.tooltip-container:first-child .tooltip-content::after,
.tooltip-container:last-child .tooltip-content::after {
left: 5px;
right: auto;
}

/* Prevent tooltip from being cut off at the top of the viewport */
@media (max-height: 500px) {
.tooltip-content {
bottom: auto;
top: 150%;
}

.tooltip-container:hover .tooltip-content {
bottom: auto;
top: 140%;
}

.tooltip-content::after {
top: auto;
bottom: 100%;
border-color: transparent transparent #2d3748 transparent;
}
}
.tooltip:hover .tooltiptext {
visibility: visible;
opacity: 1;
}
.tooltip .tooltiptext {
visibility: hidden;
opacity: 0;
background-color: #333;
color: #fff;
text-align: center;
border-radius: 4px;
padding: 5px 10px;
position: absolute;
z-index: 1000; /* increased z-index */
bottom: 125%;
left: 50%;
transform: translateX(-50%);
transition: opacity 0.3s;
white-space: nowrap;
font-size: 0.75rem;
}


.tooltiptext {
visibility: hidden;
opacity: 0;
background-color: #333;
color: #fff;
text-align: center;
padding: 5px 10px;
border-radius: 4px;
position: absolute;
z-index: 1;
bottom: 125%;
left: 50%;
transform: translateX(-50%);
transition: opacity 0.3s;
white-space: nowrap;
font-size: 0.75rem;
}

.tooltiptext::after {
content: "";
position: absolute;
top: 100%;
left: 50%;
margin-left: -5px;
border-width: 5px;
border-style: solid;
border-color: #333 transparent transparent transparent;
}

#overview {
padding: 15px;
border-radius: 6px;
margin-bottom: 20px;
}

/* Media placeholder dark mode styling */
#media-placeholder {
background-color: var(--bg-dark-secondary);
border: 1px solid rgba(255, 255, 255, 0.1);
border-radius: 8px;
}

/* Ensure that embedded iframes fill the media container */
#media-placeholder iframe {
width: 100%;
height: 100%;
display: block;
object-fit: contain;
border-radius: 8px;
}

/* Reddit embed dark mode improvements */
.reddit-embed {
background-color: var(--bg-dark-tertiary) !important;
border: 1px solid rgba(255, 255, 255, 0.2) !important;
border-radius: 8px !important;
}

.reddit-embed a {
color: var(--text-light) !important;
text-decoration: none !important;
font-family: 'Spline Sans Mono', monospace !important;
}

/* Bootstrap card dark mode styling for scenario details */
.card {
background-color: var(--bg-dark-tertiary) !important;
border: 1px solid rgba(255, 255, 255, 0.2) !important;
color: var(--text-light) !important;
}

.card-header {
background-color: var(--bg-dark-quaternary) !important;
border-bottom: 1px solid rgba(255, 255, 255, 0.2) !important;
color: var(--text-lighter) !important;
}

.card-body {
background-color: var(--bg-dark-tertiary) !important;
color: var(--text-light) !important;
}

.btn-link {
color: var(--text-lighter) !important;
text-decoration: none !important;
}

.btn-link:hover {
color: var(--text-lighter) !important;
text-decoration: none !important;
}



.comparison-container {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
gap: 10px;  /* Reduced gap for a more compact layout */
}
/* Adjust badge size specifically within overview cards */
.comparison-card .category-badge {
font-size: 0.65rem;       /* Smaller font size (adjust as needed) */
padding: 0.1em 0.3em;      /* Reduced padding for a sleeker look */
}
.scenario-section {
background-color: var(--bg-dark-tertiary);
border: 1px solid rgba(255, 255, 255, 0.1);
color: var(--text-light);
margin-top: 20px;
padding: 20px;
border-radius: 6px;
font-size: 0.6rem;
}
.scenario-section .compact-table th {
font-size: 0.8rem;
}

/* Ensure scenario details tables use dark theme colors */
.scenario-section table,
.scenario-section .table,
.scenario-section .compact-table {
color: var(--text-light) !important;
background-color: var(--bg-dark-tertiary) !important;
}

.scenario-section th,
.scenario-section td {
color: var(--text-light) !important;
border-color: rgba(255, 255, 255, 0.1) !important;
}

.scenario-section th {
background-color: var(--bg-dark-quaternary) !important;
color: var(--text-lighter) !important;
}

.scenario-table-container {
margin-bottom: 10px;
}

/* Each overview card (stacked vertically) */
.comparison-card {
background-color: var(--bg-dark-tertiary);
border: 1px solid rgba(255, 255, 255, 0.2);
color: var(--text-light);
cursor: pointer;
height: 125px;  /* Fixed height for each card (e.g., 125px if container is 500px) */
box-sizing: border-box;
padding: 5px 8px;
margin-bottom: 5px;
overflow: hidden;
font-size: 0.75rem;       /* Reduced font size */
transition: height 0.3s ease;
}

/* When the card is expanded (via read more), allow it to grow */
.comparison-card.expanded {
background-color: var(--bg-dark-tertiary);
border: 1px solid rgba(255, 255, 255, 0.2);
color: var(--text-light);
height: auto;
overflow: visible;
}

/* Alternate background colors for cards */
.comparison-card:nth-child(odd) {
    background-color: var(--bg-dark-tertiary);
}
.comparison-card:nth-child(even) {
    background-color: var(--bg-dark-quaternary);
}

/* Make the heading smaller within the card */
.comparison-card h4 {
font-size: 0.8rem;
margin: 0;
}

/* Read More Functionality for the card description */
.scenario-description .description-text {
display: -webkit-box;
-webkit-line-clamp: 2;  /* Clamp to 2 lines for a compact look */
-webkit-box-orient: vertical;
overflow: hidden;
transition: all 0.3s ease;
}
.comparison-card.expanded .scenario-description .description-text {
-webkit-line-clamp: unset;
}
.read-more {
display: block;
color: #007bff;
cursor: pointer;
font-size: 0.7rem;
margin-top: 3px;
}

.table {
color: var(--text-light);
margin-bottom: 0;
font-size: 1rem;
}

.table th {
background-color: var(--bg-dark-quaternary);
color: var(--text-lighter);
border-color: rgba(255, 255, 255, 0.2);
font-weight: 600;
border-bottom: 2px solid #dee2e6;
padding: 12px;
}

.table td {
border-color: rgba(255, 255, 255, 0.1);
color: var(--text-light);
vertical-align: middle;
padding: 12px;
}

/* Form controls */
.form-control {
  background-color: var(--bg-dark-quaternary);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: var(--text-light);
}

.form-control:focus {
  background-color: var(--bg-dark-quaternary);
  border-color: var(--virtue-color);
  color: var(--text-light);
  box-shadow: 0 0 0 0.2rem rgba(0, 193, 182, 0.25);
}

/* Buttons */
.btn-secondary {
  background-color: var(--bg-dark-quaternary);
  border-color: rgba(255, 255, 255, 0.2);
  color: var(--text-light);
  font-family: 'Spline Sans Mono', monospace;
}

.btn-secondary:hover {
  background-color: var(--bg-dark-tertiary);
  border-color: rgba(255, 255, 255, 0.3);
  color: var(--text-lighter);
}

.scenario-link {
color: #0d6efd;
margin-left: 5px;
font-size: 0.9em;
}

@media (max-width: 992px) {
.plot-container {
background-color: var(--bg-dark-quaternary);
border: 1px solid rgba(255, 255, 255, 0.1);
height: 350px;
margin-bottom: 20px;
}

.main-container {
padding: 15px;
}

/* Main title styling */
.main-title {
  font-family: 'Spline Sans Mono', monospace;
  font-size: 3.5rem;
  font-weight: 300;
  letter-spacing: 0.05em;
  color: var(--text-lighter);
  text-transform: uppercase;
}

.comparison-container {
grid-template-columns: 1fr;
}
}

.relevant-option {
background-color: #d1e7dd;
}

.relevant-badge {
border: 2px solid #0d6efd;
}
.page-header {
background: linear-gradient(135deg, #04031d 0%, #191832 100%);
padding: 40px 20px 0 20px;
position: relative;
overflow: hidden; /* Important for containing the pattern */
border-bottom: 1px solid rgba(0, 0, 0, 0.1);
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.page-header::after {
  content: '';
  position: absolute;
  top: 0;
  right: -100px; /* Adjust this to position the pattern */
  width: 600px; /* Adjust based on your pattern size */
  height: 100%;
  background-image: url('./CubePattern.png');
  background-repeat: no-repeat;
  background-position: center right;
  background-size: contain;
  opacity: 0.3; /* Make it subtle so it doesn't overpower the content */
  pointer-events: none; /* Ensure it doesn't interfere with clicking */
  z-index: 1;
}
/* Header content layout */
.header-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
  position: relative;
  z-index: 2; /* Ensure content appears above the pattern */
}

.logo-title-group {
  display: flex;
  align-items: center;
  flex: 1;
}

.logo-link {
  flex: 0 0 auto;
  margin-right: 20px;
}

.logo {
  height: 160px;
  width: auto;
  object-fit: contain;
}

.title-section {
  text-align: left;
  flex: 0 0 auto;
}

.main-title {
  font-family: 'Spline Sans Mono', monospace;
  font-size: 3.5rem;
  font-weight: 300;
  letter-spacing: 0.05em;
  color: #f7e2d3;
  text-transform: uppercase;
  margin-bottom: 0.5rem;
}

.subtitle {
  font-family: 'Spline Sans Mono', monospace;
  font-size: 1rem;
  font-weight: 400;
  letter-spacing: 0.3em;
  color: #bbbbc3;
  text-transform: uppercase;
  margin: 0;
}

.pattern-placeholder {
  flex: 0 0 150px; /* Increased from 100px to accommodate larger pattern */
  display: flex;
  align-items: center;
  justify-content: center;
}

.pattern-image {
  height: 160px;
  width: auto;
  object-fit: contain;
  opacity: 0.8;
}


.navbar-nav .nav-link:hover {
background-color: rgba(255, 255, 255, 0.4);
color: #2c5282;
}

/* Add a subtle underline effect on hover */
.navbar-nav .nav-link::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 50%;
  width: 0;
  height: 2px;
  background: linear-gradient(90deg, var(--evil-color), var(--virtue-color));
  transform: translateX(-50%);
  transition: width 0.3s ease;
}

.navbar-nav .nav-link:hover::after {
  width: 80%;
}

.navbar-nav .nav-item {
position: relative;
}

.navbar-nav .nav-item:not(:last-child)::after {
content: "";
position: absolute;
right: -3px;
top: 50%;
transform: translateY(-50%);
height: 4px;
width: 4px;
border-radius: 50%;
background-color: #718096;
opacity: 0.5;
}

@media (max-width: 991.98px) {
.navbar-nav .nav-item:not(:last-child)::after {
display: none;
}

.navbar-nav .nav-item {
text-align: center;
}
}


footer {
  background-color: var(--bg-dark-tertiary) !important;
  border-top: 1px solid rgba(255, 255, 255, 0.1) !important;
  color: var(--text-light);
}

footer a {
  color: var(--text-light) !important;
  text-decoration: none;
  transition: color 0.3s ease;
}

footer a:hover {
  color: var(--virtue-color) !important;
}

/* Modal styles */
.modal-content {
  background-color: var(--bg-dark-secondary);
  color: var(--text-light);
  border: 1px solid rgba(255, 255, 255, 0.2);
}
.modal-header {
  background-color: var(--bg-dark-tertiary);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}
.modal-body {
  background-color: var(--bg-dark-secondary);
}
.modal-body h4 {
color: #2c5282;
font-weight: 600;
}

.modal-body h5 {
color: var(--text-lighter);
font-weight: 600;
}

.modal-body p {
line-height: 1.6;
color: var(--text-light);
}

.modal-body .ml-4 {
border-left: 3px solid #e2e8f0;
padding-left: 1rem;
}

.modal-body strong {
color: var(--text-light);
}
.navbar {
padding: 0;
margin-top: auto;
border-top: 1px solid rgba(0, 0, 0, 0.1);
box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.05);
width: 100%;
}

.navbar-nav {
display: flex;
flex-direction: row;
justify-content: center;
width: 100%;
padding: 0.5rem 0;
}

.nav-item {
position: relative;
margin: 0 1rem;
}

.nav-link {
font-family: 'Inter', sans-serif;
font-weight: 500;
font-size: 1.2rem;
padding: 0.7rem 1.2rem;
transition: all 0.2s ease;
border-radius: 4px;
white-space: nowrap;
}

.nav-link:hover {
background-color: rgba(255, 255, 255, 0.4);
color: #2c5282;
}

.close {
  color: var(--text-light);
  opacity: 0.8;
}

.close:hover {
  color: var(--text-lighter);
  opacity: 1;
}

/* Responsive adjustments */
@media (max-width: 768px) {
.nav-link {
font-size: 1rem;
padding: 0.5rem 0.8rem;
}

.nav-item {
margin: 0 0.5rem;
}
}

/* Title adjustments for mobile */
@media (max-width: 576px) {
.page-header h1 {
font-size: 2.5rem !important;
margin-right: 0 !important;
}
}
/* Base styles remain the same */
@media (max-width: 991.98px) {
.navbar-collapse {
display: flex !important;
justify-content: center !important;  /* Center the collapse container */
width: 100% !important;
}

.navbar-nav {
display: flex !important;
flex-direction: row !important;
justify-content: center !important;  /* Center the nav items */
width: max-content !important;  /* Allow nav to be as wide as needed */
overflow-x: auto;
-webkit-overflow-scrolling: touch;
scrollbar-width: none;
-ms-overflow-style: none;
padding: 0.5rem 1rem !important;
}

/* Hide scrollbar */
.navbar-nav::-webkit-scrollbar {
display: none;
}

.navbar-toggler {
display: none !important;
}

/* Adjust spacing for nav items */
.nav-item.mx-3 {
margin-left: 0.5rem !important;
margin-right: 0.5rem !important;
}

/* Adjust padding for nav links */
.nav-link {
padding-left: 0.8rem !important;
padding-right: 0.8rem !important;
white-space: nowrap;  /* Prevent text wrapping */
}
}

/* Additional adjustments for very small screens */
@media (max-width: 576px) {
.nav-item.mx-3 {
margin-left: 0.3rem !important;
margin-right: 0.3rem !important;
}

.nav-link {
padding-left: 0.6rem !important;
padding-right: 0.6rem !important;
}
}
</style>
</head>
<body>
<!-- Updated Page Header with Pattern Background -->
<div class="page-header">
    <div class="container-fluid">
      <!-- Logo and Title Section -->
      <div class="header-content">
        <div class="logo-title-group">
          <a href="/" class="logo-link">
            <img src="./MoralCubeLogo-dark.png.png" alt="Moral Cube Logo" class="logo"/>
          </a>
          <div class="title-section">
            <h1 class="main-title">The Moral Cube</h1>
            <p class="subtitle">EXPLORE ETHICAL SPACE</p>
          </div>
        </div>
        <div class="pattern-placeholder">
          <img src="./CubePattern.png.png" alt="Cube Pattern" class="pattern-image"/>
        </div>
      </div>
  
      <!-- Navigation Menu -->
      <nav class="navbar navbar-expand-lg navbar-dark p-0">
        <div class="collapse navbar-collapse justify-content-center" id="navbarNav">
          <ul class="navbar-nav">
            <li class="nav-item mx-3">
              <a class="nav-link" href="/">HOME</a>
            </li>
            <li class="nav-item mx-3">
              <a class="nav-link" href="#" data-toggle="modal" data-target="#whatIsModal">ABOUT</a>
            </li>
            <li class="nav-item mx-3">
              <a class="nav-link" href="#" data-toggle="modal" data-target="#howToUseModal">INSTRUCTIONS</a>
            </li>
            <li class="nav-item mx-3">
              <a class="nav-link" href="/feedback.html">FEEDBACK</a>
            </li>
            <li class="nav-item mx-3">
                <a class="nav-link" href="https://www.youtube.com/watch?v=hauuDOrZQ1o" target="_blank">LEARN MORE</a>
            </li>
            <li class="nav-item mx-3">
              <a class="nav-link" href="https://www.linkedin.com/in/scott-m-young/" target="_blank">CONTACT</a>
            </li>
          </ul>
        </div>
      </nav>
    </div>
  </div>

      
<div class="filter-section">
<div class="filter-group values-filter-group">
<label for="valuesFilter">Values:</label>
<select id="valuesFilter" class="form-control values-select" multiple size="6"></select>
</div>
<div class="filter-group scenario-filter-group">
<label for="scenarioFilter">
Scenarios:
<span class="tooltip">
<i class="fas fa-info-circle info-icon"></i>
<span class="tooltiptext">Hold Ctrl (Cmd on Mac) to select multiple scenarios</span>
</span>
</label>
<select id="scenarioFilter" class="form-control scenario-select" multiple size="6"></select>
</div>
<div class="filter-group model-filter-group">
<label for="modelFilter">AI Models:
</label>
<select id="modelFilter" class="form-control model-select" multiple size="6"></select>
</div>
<div class="filter-group">
<label>
What If Scenarios:
<span class="tooltip">
<i class="fas fa-info-circle info-icon"></i>
<span class="tooltiptext">Hold Ctrl (Cmd on Mac) to select multiple outcomes</span>
</span>
</label>
<select id="alternateOutcomes" class="form-control" multiple size="6">
<option disabled>Select a scenario and model to see alternates</option>
</select>
</div>
<!-- New Clear Filters button underneath the four filters -->
<div class="filter-group">
<button id="clearFilters" class="btn btn-secondary">Reset Filters</button>
</div>
</div>


<!-- New three-column layout -->
<div id="overview-section" style="display: flex; width: 100%;">
<!-- Left Column: Cube Plot (40% width) -->
<div id="cube-column" style="width: 37%;">
<div class="plot-container">
<div id="cube-plot"></div>
</div>
<!-- Filters Container - Side by Side Layout -->
<div class="filters-container" style="display: flex; gap: 20px; align-items: flex-start; margin-top: 20px; padding-top: 15px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
    <!-- Moral Category Filter -->
    <div class="filter-group" style="flex: 1;">
        <label style="display: block; margin-bottom: 10px; font-weight: bold;">Moral Category:</label>
        <div class="filter-badges">
            <span class="filter-badge category-evil active" data-category="evil">Evil</span>
            <span class="filter-badge category-virtue active" data-category="virtue">Virtue</span>
            <span class="filter-badge category-vice active" data-category="vice">Vice</span>
            <span class="filter-badge category-sin active" data-category="sin">Sin</span>
            <span class="filter-badge category-morally-grey active" data-category="morally_grey">Morally Grey</span>
            <span class="filter-badge category-world-building active" data-category="world_building">World Building</span>
        </div>
    </div>

    <!-- Philosophical Analysis Filter -->
    <div class="filter-group philosophical-filter" style="flex: 1;">
        <label style="display: block; margin-bottom: 10px; font-weight: bold;">Philosophical Analysis:</label>

        <div class="philosophical-theory">
            <div class="philosophical-theory-label">Deontology:</div>
            <div class="philosophical-buttons">
                <div class="phil-button right" data-theory="Deontology" data-value="right" title="Right">✓</div>
                <div class="phil-button wrong" data-theory="Deontology" data-value="wrong" title="Wrong">✗</div>
                <div class="phil-button other" data-theory="Deontology" data-value="other" title="Other/Ambiguous">?</div>
            </div>
        </div>

        <div class="philosophical-theory">
            <div class="philosophical-theory-label">Utilitarianism:</div>
            <div class="philosophical-buttons">
                <div class="phil-button right" data-theory="Utilitarianism" data-value="right" title="Right">✓</div>
                <div class="phil-button wrong" data-theory="Utilitarianism" data-value="wrong" title="Wrong">✗</div>
                <div class="phil-button other" data-theory="Utilitarianism" data-value="other" title="Other/Ambiguous">?</div>
            </div>
        </div>

        <div class="philosophical-theory">
            <div class="philosophical-theory-label">Virtue Ethics:</div>
            <div class="philosophical-buttons">
                <div class="phil-button right" data-theory="Virtue Ethics" data-value="right" title="Virtue">✓</div>
                <div class="phil-button wrong" data-theory="Virtue Ethics" data-value="wrong" title="Vice">✗</div>
                <div class="phil-button other" data-theory="Virtue Ethics" data-value="other" title="Other/Ambiguous">?</div>
            </div>
        </div>
    </div>
</div>
</div>
<div id="cards-column" style="width: 18%; padding: 0 10px;">
<p style="font-size: 0.9rem; margin-bottom: 0.5rem;">Select 2 scenarios/models to compare:</p>
<div id="overview"></div>
</div>

<!-- Right Column: Overview Placeholder for Video/Website -->
<div id="placeholder-overview-column" style="width: 45%; padding: 0 10px; display: flex; flex-direction: column; height: 500px;">
<div id="media-placeholder" style="flex-grow: 1; border: none; overflow: hidden;"></div>
<button id="open-media" class="btn btn-secondary btn-sm mt-2" style="width: 100%;">Open in New Window</button>
</div>


</div>



<div id="scenarioSection" class="scenario-section">
<h4 class="mb-3">
Scenario Details
<span class="tooltip-container">
<i class="fas fa-info-circle tooltip-icon"></i>
<span class="tooltip-content">Click two Scenario Cards above to compare the answers</span>
</span>
</h4>
<div class="accordion" id="scenarioAccordion">
<!-- Will be populated dynamically -->
</div>
</div>
</div>
<div class="modal fade" id="whatIsModal" tabindex="-1">
<div class="modal-dialog modal-lg">
<div class="modal-content">
<div class="modal-header">
<h5 class="modal-title">What is the Moral Cube?</h5>
<button type="button" class="close" data-dismiss="modal">
<span>&times;</span>
</button>
</div>
<div class="modal-body">
<div class="introduction mb-4">
<h4 class="mb-3">Understanding the Moral Cube</h4>
<p>The Moral Cube is a tool designed to help people think more clearly about moral decisions. It provides a structured way to assess actions by considering three key dimensions: <strong>Ends (Goals & Intentions), Means (Sacrifice), and Character (Awareness & Self-Control).</strong></p>
</div>

<div class="concept mb-4">
<h5 class="mb-3">The Concept</h5>
<p>Rather than prescribing what is right or wrong, the Cube offers a space for reflection. By answering questions about motivation, sacrifice, and character, each scenario is mapped onto three orthogonal (right-angle) axes—<strong>x, y, and z.</strong> This creates a unique position within the Cube that represents the moral complexity of each action.</p>
</div>

<div class="purpose mb-4">
<h5 class="mb-3">Why Use the Moral Cube?</h5>
<p>The Moral Cube isn't just about exploring different perspectives—it's about understanding <em>why</em> we judge actions as right or wrong. When good intentions clash with difficult trade-offs, the Cube helps break down these decisions into clear components.</p>

<p>By using the Cube, you can compare moral reasoning across time, between people, and even with AI systems. This comparison reveals where human and machine perspectives align or differ, offering valuable insights as AI becomes increasingly prevalent in our world.</p>
</div>

<div class="approach mb-4">
<h5 class="mb-3">Our Approach</h5>
<p>We often rely on intuition or cultural norms for moral judgments. The Moral Cube offers a more structured path. It helps align your values with your actions while fostering meaningful discussions about complex ethical choices.</p>
</div>

<div class="conclusion text-center mt-4">
<p><strong>Explore, reflect, and discover your moral perspective within the Cube.</strong></p>
</div>
</div>
</div>
</div>
</div>
<!-- How to Use Modal -->
<div class="modal fade" id="howToUseModal" tabindex="-1">
<div class="modal-dialog modal-lg">
<div class="modal-content">
<div class="modal-header">
<h5 class="modal-title">How to Use the Moral Cube</h5>
<button type="button" class="close" data-dismiss="modal">
<span>&times;</span>
</button>
</div>
<div class="modal-body">
<div class="introduction mb-4">
<h4 class="mb-3">Welcome to the Moral Cube</h4>
<p>The Moral Cube is an interactive tool for exploring ethical scenarios and their analyses by various AI models. This guide will help you navigate and maximize the platform's capabilities.</p>
</div>

<div class="getting-started mb-4">
<h5 class="mb-3">Getting Started</h5>
<p>Begin your exploration through either of these approaches:</p>
<div class="ml-4">
<p><strong>Category-Based Exploration:</strong> Select a Category Type to view related scenarios, providing a thematic approach to ethical exploration.</p>
<p><strong>Direct Scenario Selection:</strong> Choose specific scenarios from the complete list if you have particular cases in mind.</p>
</div>
</div>

<div class="comparison-features mb-4">
<h5 class="mb-3">Comparing Scenarios and Models</h5>
<p>The platform offers multiple comparison capabilities:</p>
<div class="ml-4">
<p><strong>Scenario Selection:</strong> Use Ctrl+Click (PC) or tap multiple options (mobile/tablet) to select scenarios for comparison. The system supports up to four scenarios simultaneously.</p>
<p><strong>AI Model Analysis:</strong> Once you select a scenario, the platform displays available AI models that have analyzed that particular case.</p>
<p><strong>Alternative Scenarios:</strong> Many cases include hypothetical variations, demonstrating how subtle changes in actions can significantly affect ethical positioning within the cube.</p>
</div>
</div>

<div class="detailed-analysis mb-4">
<h5 class="mb-3">Exploring Detailed Analysis</h5>
<p>For optimal analysis review:</p>
<div class="ml-4">
<p><strong>Side-by-Side Comparison:</strong> Select two scenarios to view a detailed comparison in the Scenario Details section. This limitation ensures clear and meaningful analysis presentation.</p>
<p><strong>Enhanced Understanding:</strong> Each question and justification includes informative tooltips. Hover over the information (i) and question (?) icons to access additional context about the models' evaluation criteria.</p>
</div>
</div>
</div>
</div>
</div>

<script>
// Initialize global variables
let dataPoints = [];
let activeCategories = new Set(['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building']);
let selectedComparison = []; // Will hold the IDs of the two items selected for comparison
let selectedValues = [];
let selectedScenarios = [];
let selectedModels = [];
let selectedAlternateOutcomes = [];
let isCategoryFiltering = false;
let isUpdatingFilters = false;
let scenarioRelationships = new Map(); // Stores parent-child relationships
let currentMediaUrl = "";

// Philosophical Analysis Filter variables
let selectedPhilosophicalFilters = {
    'Deontology': null,        // 'right', 'wrong', 'other', or null
    'Utilitarianism': null,
    'Virtue Ethics': null
};

// Philosophical Analysis score categorization function
function categorizePhilosophicalScore(question, score) {
    if (!score || score === null || score === "") return 'other';
    
    const scoreStr = score.toString().toLowerCase().trim();
    
    // RIGHT category
    const rightPatterns = ['right', 'virtue', 'displaying virtue', 'courage (virtue)', 'right (with caveat)'];
    if (rightPatterns.some(pattern => scoreStr.includes(pattern))) {
        return 'right';
    }
    
    // WRONG category  
    const wrongPatterns = ['wrong', 'mild failing', 'vice', 'vicious', 'vices dominant'];
    if (wrongPatterns.some(pattern => scoreStr.includes(pattern))) {
        return 'wrong';
    }
    
    // Handle mixed virtue/vice cases for Virtue Ethics
    if (question === 'Virtue Ethics' && scoreStr.includes('vices:') && scoreStr.includes('virtues:')) {
        return 'other'; // Mixed virtue/vice goes to other
    }
    
    // OTHER category (default)
    return 'other'; // Includes: mixed, neutral, ambiguous, potentially right/wrong, other, null
}

// Philosophical Analysis highlighting functions
function updatePhilosophicalHighlighting(selectedScenarios) {
    // Clear existing highlights
    clearPhilosophicalHighlighting();
    
    // Collect philosophical scores from selected scenarios
    const philosophicalScores = {};
    
    selectedScenarios.forEach(point => {
        const philDimension = point.dimensions.find(dim => dim.id === 'Philosophical Analysis');
        if (philDimension && philDimension.questions) {
            ['Deontology', 'Utilitarianism', 'Virtue Ethics'].forEach(theory => {
                const theoryQuestion = philDimension.questions.find(q => q.question === theory);
                if (theoryQuestion && theoryQuestion.score) {
                    const category = categorizePhilosophicalScore(theory, theoryQuestion.score);
                    if (!philosophicalScores[theory]) {
                        philosophicalScores[theory] = new Set();
                    }
                    philosophicalScores[theory].add(category);
                }
            });
        }
    });
    
    // Apply highlights to buttons that match the selected scenarios
    Object.entries(philosophicalScores).forEach(([theory, categories]) => {
        categories.forEach(category => {
            const button = document.querySelector(`.phil-button[data-theory="${theory}"][data-value="${category}"]`);
            if (button) {
                button.classList.add('highlighted');
            }
        });
    });
}

function clearPhilosophicalHighlighting() {
    document.querySelectorAll('.phil-button').forEach(btn => {
        btn.classList.remove('highlighted');
    });
}

// Fixed array of shared border colors.
const sharedBorderColors = ["purple", "blue", "black", "pink", "dark green"];
// Mapping from scenario title to a fixed border color.
let scenarioColorMapping = {};

const questionTooltips = {

"Societal Needs": {
info: "If needs are essential elements to ensure survival and growth (e.g., food, water, security, love), then societal needs are essential for the survival and growth of a society. Societal needs include maintaining justice, fairness, and trust in social institutions (e.g., don’t lie, keep promises, don’t steal, help others, uphold justice, avoid cruelty). When these societal needs are met, societies function harmoniously, promoting the well-being of individuals within them.",
question: "To what extent was the action focused on fulfilling societal needs such as justice, fairness, equality, respect for persons, or promoting the common good?"
},
"Others Needs": {
info: "Needs are often necessary for survival or fulfilling a core purpose. When essential needs (e.g., hunger, safety, belonging) are not met, there is an increase in unpleasant sensations. Meeting these needs reduces discomfort and ensures survival and well-being. This question focuses on whether the action was aimed at fulfilling others' essential needs.",
question: "To what extent was the action focused on fulfilling others' needs related to physiology, safety, love/belonging, esteem, or self-actualization?"
},
"Others Wants": {
info: "Wants are often tied to increasing pleasant sensations or achieving rewards and favourable outcomes. They are not essential for survival but often relate to desires for financial gain, recognition, or status. This question focuses on whether the action was aimed at fulfilling others' non-essential wants.",
question: "To what extent was the action focused on fulfilling others' wants such as financial gain, social recognition, praise, power, appearance, conformity, reward, competition, or security?"
},
"Personal Needs": {
info: "Needs are often essential for personal survival or fulfilling a core purpose. When these needs are unmet, unpleasant sensations arise (e.g., hunger, lack of security or belonging). Meeting personal needs reduces this discomfort. This question focuses on whether the action was primarily aimed at fulfilling personal essential needs.",
question: "To what degree was the action motivated by fulfilling essential personal needs such as safety, physiological survival, or self-actualisation?"
},
"Personal Wants": {
info: "Wants are most often tied to desires for rewards or pleasant sensations, beyond essential needs. These can include financial gain, praise, or social recognition. This question assesses whether the action was motivated by fulfilling personal non-essential wants.",
question: "To what extent was the action focused on fulfilling personal wants such as financial gain, social recognition, praise, power, appearance, conformity, reward, competition, or security?"
},
"Future Self-Sacrifice": {
info: "Our future selves don’t exist yet and morally speaking would be considered an “other”, treated as an agent yet to come. When we make decisions that negatively impact our future, it is similar to making a decision that impacts another person’s future morally speaking. With this in mind evaluate the level of sacrifice affecting the future self, including future versions of oneself, cumulative identity, long-term values, and future aspirations. This encompasses actions that impact deeply held values, long-term plans, fundamental life goals, health, or personal well-being.",
question: "To what extent did the action require sacrifices that impact the future self? Consider aspects like future plans, core values, psychological wellbeing, life goals, elements of personal identity and legacy, health, and long-term well-being."
},
"Number of Individuals Affected": {
info: "",
question: "How many people were impacted by the sacrifice or harm?"
},
"Type of Sacrifice": {
info: "",
question: "What was the severity of the impact on each individual in terms of what they lost (time, money, resources, freedom, life)?"
},
"Duration of Sacrifice": {
info: "",
question: "How long do you think the sacrifice affected the individuals involved (short-term vs. long-term impact)?"
},
"Magnitude of Life Impacted": {
info: "Evaluate the magnitude of the sacrifice based on the type of life impacted. Smaller organisms like bacteria and insects are assigned lower values, while more complex and sentient life forms, such as animals and humans, are assigned higher values. Additionally, consider the vulnerability of individuals; for example, children or disabled humans may have a slightly higher weighting due to their increased dependency and reduced capacity to defend themselves.",
question: "To what extent did the action impact life, considering the type and vulnerability of the affected organism(s)? Use the following scale to assess the magnitude of impact per individual:"
},
"Unconscious vs Conscious": {
info: "Evaluate the individual’s level of awareness regarding their actions and their consequences. Consider whether the action was performed reflexively, partially consciously, or with full mindfulness.",
question: "To what extent was the individual conscious of their actions and consequences?"
},
"Present Self-Sacrifice": {
info: "A component of Self-Control is self-sacrifice, as we don’t exercise self-control when we want to do something, only when we don’t want to. Evaluate the level of sacrifice affecting the immediate, present self. This includes sacrifices that impact short-term desires, impulses, and needs—such as loss of comfort, overcoming impulses, inconvenience, or minor financial costs.",
question: "To what extent did the action require sacrifices from the individual's present self? Consider aspects like immediate comfort, desires, impulses, convenience, minor financial expenditures, or brief emotional distress."
},
"Habit vs Will Power": {
info: "Our actions exist somewhere on the spectrum from a habit to an exertion of will power. When we’re doing something for the first time, or when we don’t want to do something, we often require more will power. Noting that when we want to do something, or are chasing a desire, we also form habits. This question aims to reflect on whether the action was habitual or required will power, not differentiating between desire driven habits, or value aligned habits. Evaluate whether the individual acted out of ingrained habits or deliberate effort. Consider the effort required to override impulses or habitual behaviours.",
question: "To what extent was the action driven by willpower versus habitual responses?"
},
"Unintentional vs Intentional": {
info: "Our actions always have a measure of intentionality, was this what was being aimed at, was it influenced by unconscious intentions (desires), or was this a mistake (not intended at all). Assess whether the action was performed deliberately or occurred reflexively without deliberate thought.",
question: "To what extent was the action intentional?"
},
"Wills at Play": {
info: "Within each person is a composition of Wills, or unconscious drivers, with fundamental wills working together as a Will to Survive which should sit at the heart of every life form, and from that will survive do second order Wills emerging. Within the Will to survive are drives such as the Will to Consume, the Will to Homeostasis, the Will to Replicate for example, and emerging from the Will to Survive are higher order drives that might aid in our placement within a Hierarchy, or ensure genetic continuity such as a Will to Status, or a Will to Reproduction, even a Will to Create. Each of these Wills are in constant competition for airtime, there are some associated with the biological impulses (lust, envy, gluttony), and some associated with virtue (will to abstain, will to patience, empathy). Reflecting on this idea, what Wills do you think might be influencing this scenario and why?",
question: "List the Wills and provide a one sentence justification as to why that Will might have influenced the scenario."
},
"Deontology": {
info: "",
question: "In one paragraph could you explain why this action was right or wrong through a deontological lens?"
},
"Utilitarianism": {
info: "",
question: "In two paragraphs could you explain why this action was right or wrong from a utilitarian and negative utilitarian perspective?"
},
"Virtue Ethics": {
info: "",
question: "From an Aristotelian perspective could you explain what virtues or vices were at play within this action?"
}
};

// *** New function: attachComparisonCardHandlers ***
function attachComparisonCardHandlers() {
document.querySelectorAll('.comparison-card').forEach(card => {
card.addEventListener('click', function() {
const id = card.getAttribute('data-scenario-id');

// If card is already selected, unselect it
if (card.classList.contains('selected-card')) {
card.classList.remove('selected-card');
selectedComparison = selectedComparison.filter(selectedId => selectedId !== id);
} else {
// If trying to select a third card
if (selectedComparison.length >= 2) {
// Clear all selections
document.querySelectorAll('.comparison-card').forEach(c => {
c.classList.remove('selected-card');
});
selectedComparison = [];

// Select the new card
card.classList.add('selected-card');
selectedComparison.push(id);
} else {
// Select the card normally
card.classList.add('selected-card');
selectedComparison.push(id);
}
}

// Update scenario details based on selection
if (selectedComparison.length === 2) {
const compData = dataPoints.filter(point => 
selectedComparison.includes(point.id)
);
populateScenarioDetails(compData);

// Update philosophical analysis button highlighting
updatePhilosophicalHighlighting(compData);
} else {
// Clear scenario details if fewer than 2 cards selected
document.getElementById('scenarioAccordion').innerHTML = `
                           <div class="text-center text-muted p-3">
                               Select two scenario cards above to compare details
                           </div>
                       `;

// Clear philosophical highlighting
clearPhilosophicalHighlighting();
}
});
});
}

function getEthicsScores(item) {
try {
if (!item.dimensions) {
return {
deontologyScore: 'N/A',
utilitarianismScore: 'N/A',
virtueEthicsScore: 'N/A'
};
}

const philosophyDimension = item.dimensions.find(dim => 
dim.id.trim().toLowerCase() === 'philosophical analysis'
);

if (!philosophyDimension || !philosophyDimension.questions) {
return {
deontologyScore: 'N/A',
utilitarianismScore: 'N/A',
virtueEthicsScore: 'N/A'
};
}

const scores = {};
philosophyDimension.questions.forEach(q => {
const questionType = q.question.trim().toLowerCase();
if (questionType === 'deontology') {
scores.deontologyScore = q.score;
} else if (questionType === 'utilitarianism') {
scores.utilitarianismScore = q.score;
} else if (questionType === 'virtue ethics') {
scores.virtueEthicsScore = q.score;
}
});

return scores;
} catch (error) {
console.error('Error extracting ethics scores:', error);
return {
deontologyScore: 'N/A',
utilitarianismScore: 'N/A',
virtueEthicsScore: 'N/A'
};
}
}



// Function to render the questions into the container
function renderSurveyQuestions() {
const container = document.getElementById('survey-questions');
if (!container) return; // if the container doesn't exist, exit

surveyQuestions.forEach(q => {
const questionMarkup = `
           <div class="question-container mb-3" style="font-size: 1rem;">
               <strong>${q.short}</strong>
               <!-- Info icon hover -->
               ${q.info ? `
               <span class="tooltip">
                   <i class="fas fa-info-circle info-icon"></i>
                   <span class="tooltiptext" style="max-width: 300px;">${q.info}</span>
               </span>` : ''}
               <!-- Question icon hover -->
               ${q.question ? `
               <span class="tooltip">
                   <i class="fas fa-question-circle info-icon" style="margin-left: 0.5rem;"></i>
                   <span class="tooltiptext" style="max-width: 300px;">${q.question}</span>
               </span>` : ''}
           </div>
           `;
// Append the markup to the container
container.innerHTML += questionMarkup;
});
}



function normalizeCategory(category) {
// Convert category to lowercase and replace spaces with underscores
return category.toLowerCase().replace(/\s+/g, '_');
}

function fetchScenarios() {
console.log("Starting fetchScenarios...");

fetch('/.netlify/functions/fetchscenarios')
.then(response => {
console.log("Fetch response status:", response.status);
console.log("Response headers:", Object.fromEntries(response.headers.entries()));

if (!response.ok) {
throw new Error(`Network response was not ok: ${response.status} ${response.statusText}`);
}
return response.json();
})
.then(data => {
// Detailed logging of the response
console.log("Raw API response data:", data);
console.log("Response type:", typeof data);
console.log("Top-level keys:", Object.keys(data));

let scenariosToProcess;

// Determine data structure and extract scenarios
if (data && Array.isArray(data.scenarios)) {
console.log("Found scenarios array in data.scenarios");
console.log("Number of scenarios:", data.scenarios.length);
if (data.scenarios.length > 0) {
console.log("First scenario structure:", {
keys: Object.keys(data.scenarios[0]),
hasMetadata: !!data.scenarios[0].metadata,
hasId: !!data.scenarios[0].id,
hasMongoId: !!data.scenarios[0]._id
});
}
scenariosToProcess = data.scenarios;
} else if (Array.isArray(data)) {
console.log("Data is directly an array");
console.log("Number of items:", data.length);
if (data.length > 0) {
console.log("First item structure:", {
keys: Object.keys(data[0]),
hasMetadata: !!data[0].metadata,
hasId: !!data[0].id,
hasMongoId: !!data[0]._id
});
}
scenariosToProcess = data;
} else {
console.error("Unexpected data format:", {
dataType: typeof data,
isNull: data === null,
isUndefined: data === undefined,
keys: data ? Object.keys(data) : 'no keys'
});

// Attempt to salvage data if possible
if (data && typeof data === 'object') {
if (data.scenarios) {
console.log("Attempting to use data.scenarios despite format issues");
scenariosToProcess = Array.isArray(data.scenarios) ? data.scenarios : [data.scenarios];
} else {
console.log("Attempting to use entire data object as single scenario");
scenariosToProcess = [data];
}
} else {
throw new Error("Could not extract valid scenarios from response");
}
}

// Pre-process validation
if (scenariosToProcess && scenariosToProcess.length > 0) {
console.log("Proceeding to process scenarios");
console.log("Sample of first scenario:", JSON.stringify(scenariosToProcess[0], null, 2));
processJsonData(scenariosToProcess);
} else {
console.warn("No scenarios to process!");
processJsonData([]); // Process empty array to ensure UI updates
}
})
.catch(error => {
console.error("Error in fetchScenarios:", {
message: error.message,
stack: error.stack,
type: error.name
});

// Log additional context
console.error("Error details:", {
timeStamp: new Date().toISOString(),
errorType: error.constructor.name,
errorMessage: error.message
});

// Ensure UI is updated even in error case
processJsonData([]);
});








function processJsonData(data) {
console.log("API response data:", data);
console.log("Response type:", typeof data);

// Clear existing relationships
scenarioRelationships.clear();
dataPoints = [];
let displayPoints = [];  // For parent scenarios

// In processJsonData function, modify the flattening step:
let flattenedScenarios = [];
// Remove duplicates by using a Set of IDs
const processedIds = new Set();

data.forEach(doc => {
if (doc.scenarios && Array.isArray(doc.scenarios)) {
doc.scenarios.forEach(scenario => {
if (!processedIds.has(scenario.id)) {
processedIds.add(scenario.id);
flattenedScenarios.push(scenario);
}
});
}
});

console.log("Flattened scenarios (unique):", flattenedScenarios);

flattenedScenarios.forEach((scenario, index) => {
console.log(`\n--- Processing scenario at index ${index} ---`);
console.log("Full scenario data:", scenario);

// Use scenario.id as it's already in the correct format
const documentId = scenario.id;
console.log("Document ID:", documentId);

// These should now be defined since we're using the correct nesting level
console.log("Metadata:", scenario.metadata);
console.log("Survey data:", scenario.survey);

// Check if metadata exists
if (!scenario.metadata) {
console.warn(`Scenario at index ${index} is missing metadata.`);
}
// Check if metadata.title exists
if (!scenario.metadata || !scenario.metadata.title) {
console.warn(`Scenario at index ${index} is missing a title.`);
}

// Use defaults if properties are missing
const metadata = scenario.metadata || {};
const survey = scenario.survey || {};
const point = {
id: documentId,
scenarioTitle: metadata.title || "Untitled Scenario",
scenarioDescription: metadata.description || "",
llmName: metadata.llmSource ? metadata.llmSource.model : "Unknown Model",
category: metadata.category || "Uncategorized",
overallCategory: metadata.classification ? normalizeCategory(metadata.classification.type) : "unknown",
url: metadata.url || "",
dimensions: survey.dimensions || [],
x: survey.finalPosition ? survey.finalPosition.x : 0,
y: survey.finalPosition ? survey.finalPosition.y : 0,
z: survey.finalPosition ? survey.finalPosition.z : 0,
isParent: scenario.type === 'base',
parentId: scenario.parentId || null,
relationToBase: metadata.relationToBase || null,
// Add the ethics scores if available in your data structure:
deontologyScore: survey.deontologyScore,           // Adjust as needed
utilitarianismScore: survey.utilitarianismScore,       // Adjust as needed
virtueEthicsScore: survey.virtueEthicsScore            // Adjust as needed
};


console.log(`Created point object:`, point);
console.log(`Point ID: ${point.id}`);
console.log(`Is Parent: ${point.isParent}`);
console.log(`Parent ID: ${point.parentId}`);

dataPoints.push(point);
if (point.isParent) {
displayPoints.push(point);
console.log(`Added to displayPoints as parent scenario`);
} else if (point.parentId) {
// Find the matching parent (using the parent's id)
const parent = dataPoints.find(p => p.id === point.parentId);
console.log(`Searching for parent with ID: ${point.parentId}`);
console.log(`Found parent:`, parent);

if (parent) {
if (!scenarioRelationships.has(parent.scenarioTitle)) {
scenarioRelationships.set(parent.scenarioTitle, []);
}
scenarioRelationships.get(parent.scenarioTitle).push({
childId: point.scenarioTitle,
relationshipType: point.relationToBase,
model: point.llmName,
data: point
});
console.log(`Added relationship: ${parent.scenarioTitle} -> ${point.scenarioTitle}`);
}
}
});

// Log the final collections
console.log("\n--- Final Data Collections ---");
console.log("Total dataPoints:", dataPoints.length);
console.log("Total displayPoints:", displayPoints.length);
console.log("Scenario relationships:", Array.from(scenarioRelationships.entries()));

// Update filters using parent scenarios only
const uniqueScenarios = [...new Set(displayPoints.map(p => p.scenarioTitle))];
const uniqueModels = [...new Set(displayPoints.map(p => p.llmName))];
// Extract unique values from Character dimension
const uniqueValuesSet = new Set();
displayPoints.forEach(point => {
    const characterDimension = point.dimensions.find(dim => dim.id === 'Character');
    if (characterDimension && characterDimension.questions) {
        const valuesQuestion = characterDimension.questions.find(q => q.question === 'Values');
        if (valuesQuestion && valuesQuestion.score && Array.isArray(valuesQuestion.score)) {
            valuesQuestion.score.forEach(value => uniqueValuesSet.add(value));
        }
    }
});
const uniqueValues = [...uniqueValuesSet].sort();

console.log("\n--- Filter Updates ---");
console.log("Unique scenarios:", uniqueScenarios);
console.log("Unique models:", uniqueModels);
console.log("Unique values:", uniqueValues);

document.getElementById('modelFilter').innerHTML = uniqueModels.map(model =>
`<option value="${model}">${model}</option>`
).join('');

document.getElementById('scenarioFilter').innerHTML = uniqueScenarios.map(scenario =>
`<option value="${scenario}">${scenario}</option>`
).join('');

document.getElementById('valuesFilter').innerHTML = uniqueValues.map(value =>
`<option value="${value}">${value}</option>`
).join('');

document.getElementById('alternateOutcomes').innerHTML =
'<option disabled>Select a scenario and model to see alternates</option>';

activeCategories = new Set([...new Set(displayPoints.map(point => 
normalizeCategory(point.overallCategory)))]);

console.log("Active categories:", Array.from(activeCategories));

document.querySelectorAll('.filter-badge').forEach(badge => {
const category = badge.dataset.category.toLowerCase();
const exists = displayPoints.some(point => 
normalizeCategory(point.overallCategory) === category);
badge.style.display = exists ? 'inline-block' : 'none';
badge.classList.toggle('active', activeCategories.has(category));
});

// Initial visualization: show parent scenarios only
console.log("\n--- Creating Initial Plot ---");
console.log("Display points for plot:", displayPoints);
createPlot(displayPoints);
}
}


// Visualization functions
function createPlot(points) {
const meshData = {
type: 'mesh3d',
x: [-8, 12, 12, -8, -8, 12, 12, -8],
y: [0, 0, 0, 0, 8, 8, 8, 8],
z: [-21.6, -21.6, 0, 0, -21.6, -21.6, 0, 0],
i: [0, 0, 4, 4, 0, 0, 2, 2, 0, 1],
j: [1, 2, 5, 6, 1, 5, 3, 7, 0, 2],
k: [2, 3, 6, 7, 5, 4, 7, 6, 3, 3],
opacity: 0.1,
color: 'lightblue',
showlegend: false,
hoverinfo: 'none'
};

let data = [meshData];

// Draw relationship lines (if applicable)
const parentPoint = points.find(p => p.isParent);
if (parentPoint && scenarioRelationships.has(parentPoint.scenarioTitle)) {
const childPoints = points.filter(p => !p.isParent);
childPoints.forEach(childPoint => {
data.push({
type: 'scatter3d',
x: [parentPoint.x, childPoint.x],
y: [parentPoint.z, childPoint.z],
z: [parentPoint.y, childPoint.y],
mode: 'lines',
line: { color: '#666', width: 2, dash: 'dash' },
hoverinfo: 'text',
hovertext: `${parentPoint.scenarioTitle} → ${childPoint.scenarioTitle}`,
showlegend: false
});
});
}

// Plot the data points (markers)
data.push({
type: 'scatter3d',
x: points.map(p => p.x),
y: points.map(p => p.z),
z: points.map(p => p.y),
mode: 'markers',
marker: {
size: points.map(p => p.isParent ? 8 : 6),
color: points.map(p => getColorByCategory(p.overallCategory)),
opacity: 0.8,
line: {
// Use the composite key for marker borders and increase the width.
color: points.map(p => scenarioColorMapping[p.scenarioTitle + '_' + p.llmName] || '#000'),
width: points.map(p => p.isParent ? 6 : 4)
}
},
text: points.map(p => `
               <b>${p.scenarioTitle}</b><br>
               <b>Category:</b> ${p.overallCategory}<br>
               <b>Model:</b> ${p.llmName}<br>
               ${p.isParent ? '<b>Type:</b> Parent' : '<b>Type:</b> Alternative'}
               `),
hoverinfo: 'text',
showlegend: false
});

const layout = {
margin: { l: 0, r: 0, b: 0, t: 0 },
paper_bgcolor: '#04031d',
plot_bgcolor: '#04031d',
scene: {
bgcolor: '#04031d',
xaxis: { 
    title: 'Altruistic - Self Motivated', 
    range: [-8, 12], 
    titlefont: { size: 10, color: '#bbbbc3' },
    tickfont: { color: '#bbbbc3' },
    gridcolor: 'rgba(187, 187, 195, 0.2)',
    zerolinecolor: 'rgba(187, 187, 195, 0.3)'
},
yaxis: { 
    title: 'Habit/Instinct - Will Power', 
    range: [0, 8], 
    titlefont: { size: 10, color: '#bbbbc3' },
    tickfont: { color: '#bbbbc3' },
    gridcolor: 'rgba(187, 187, 195, 0.2)',
    zerolinecolor: 'rgba(187, 187, 195, 0.3)'
},
zaxis: { 
    title: 'Small Sacrifice - Large sacrifice', 
    range: [-21.6, 0], 
    titlefont: { size: 10, color: '#bbbbc3' },
    tickfont: { color: '#bbbbc3' },
    gridcolor: 'rgba(187, 187, 195, 0.2)',
    zerolinecolor: 'rgba(187, 187, 195, 0.3)'
},
camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } },
aspectmode: 'cube',
aspectratio: { x: 1, y: 1, z: 1 }
}
};

Plotly.newPlot('cube-plot', data, layout, {
displayModeBar: false,
responsive: true
});
}

function updateAlternateOutcomesDropdown(parentScenario, selectedModel) {
const alternateOutcomes = document.getElementById('alternateOutcomes');

if (!parentScenario || !selectedModel) {
alternateOutcomes.innerHTML = '<option disabled>Select one scenario and one model</option>';
alternateOutcomes.disabled = true;
return;
}

const relationships = scenarioRelationships.get(parentScenario) || [];
const alternatives = relationships.filter(rel => rel.model === selectedModel);

if (alternatives && alternatives.length > 0) {
alternateOutcomes.innerHTML = alternatives.map(alt => `
                       <option value="${alt.childId}">
                           ${alt.childId} ${alt.relationshipType ? `(${alt.relationshipType})` : ''}
                       </option>
                   `).join('');
alternateOutcomes.disabled = false;
alternateOutcomes.multiple = true;
alternateOutcomes.size = Math.min(6, alternatives.length);
} else {
alternateOutcomes.innerHTML = '<option disabled>No alternate outcomes available</option>';
alternateOutcomes.disabled = true;
}
}


function updateFilters() {
// Model filter
const modelFilter = document.getElementById('modelFilter');
const models = [...new Set(dataPoints.map(point => point.llmName))];
modelFilter.innerHTML = models.map(model => `<option value="${model}">${model}</option>`).join('');

// Scenario filter (parent scenarios only)
const scenarioFilter = document.getElementById('scenarioFilter');
const scenarios = [...new Set(dataPoints.filter(p => p.isParent).map(point => point.scenarioTitle))];
scenarioFilter.innerHTML = scenarios.map(scenario => `<option value="${scenario}">${scenario}</option>`).join('');

// Values filter - extract unique values from Character dimension
const allValues = new Set();
dataPoints.filter(p => p.isParent).forEach(point => {
    // Look for Values question in Character dimension
    const characterDimension = point.dimensions.find(dim => dim.id === 'Character');
    if (characterDimension && characterDimension.questions) {
        const valuesQuestion = characterDimension.questions.find(q => q.question === 'Values');
        if (valuesQuestion && valuesQuestion.score && Array.isArray(valuesQuestion.score)) {
            valuesQuestion.score.forEach(value => allValues.add(value));
        }
    }
});

const valuesFilter = document.getElementById('valuesFilter');
valuesFilter.innerHTML = [...allValues].sort().map(value => `<option value="${value}">${value}</option>`).join('');

// Update category badges visibility and active state
document.querySelectorAll('.filter-badge').forEach(badge => {
const category = badge.dataset.category;
const normalizedCategory = normalizeCategory(category);
const exists = dataPoints.some(point => normalizeCategory(point.overallCategory) === normalizedCategory);
badge.style.display = exists ? 'inline-block' : 'none';
badge.classList.toggle('active', activeCategories.has(normalizedCategory));
});
}

// === updateVisualization() Function ===
function updateVisualization() {
let filteredPoints = dataPoints;

// If more than one scenario is selected, default the model to "GPT".
if (selectedScenarios.length > 1) {
selectedModels = ["GPT"];
}

// --- Clear highlights ---
document.querySelectorAll('.relevant-option').forEach(el => el.classList.remove('relevant-option'));
document.querySelectorAll('.filter-badge').forEach(badge => {
badge.classList.remove('relevant-badge');
badge.style.display = 'inline-block';
});

// --- Apply moral category filter ---
if (activeCategories.size !== 6) {
filteredPoints = filteredPoints.filter(point =>
activeCategories.has(normalizeCategory(point.overallCategory))
);

const availScenarios = new Set(filteredPoints.map(p => p.scenarioTitle));
const scenarioFilter = document.getElementById('scenarioFilter');
Array.from(scenarioFilter.options).forEach(option => {
option.style.display = availScenarios.has(option.value) ? 'block' : 'none';
if (availScenarios.has(option.value)) option.classList.add('relevant-option');
});

const availModels = new Set(filteredPoints.map(p => p.llmName));
const modelFilter = document.getElementById('modelFilter');
Array.from(modelFilter.options).forEach(option => {
option.style.display = availModels.has(option.value) ? 'block' : 'none';
if (availModels.has(option.value)) option.classList.add('relevant-option');
});
}

// --- Apply Values Filter ---
if (selectedValues.length > 0) {
    filteredPoints = filteredPoints.filter(point => {
        // Check if any of the selected values exist in this point's Values
        const characterDimension = point.dimensions.find(dim => dim.id === 'Character');
        if (characterDimension && characterDimension.questions) {
            const valuesQuestion = characterDimension.questions.find(q => q.question === 'Values');
            if (valuesQuestion && valuesQuestion.score && Array.isArray(valuesQuestion.score)) {
                return selectedValues.some(selectedValue => valuesQuestion.score.includes(selectedValue));
            }
        }
        return false;
    });
}

// --- Apply Philosophical Analysis Filter ---
const hasPhilosophicalFilters = Object.values(selectedPhilosophicalFilters).some(filter => filter !== null);
if (hasPhilosophicalFilters) {
    filteredPoints = filteredPoints.filter(point => {
        // Find the Philosophical Analysis dimension
        const philDimension = point.dimensions.find(dim => dim.id === 'Philosophical Analysis');
        if (!philDimension || !philDimension.questions) return false;
        
        // Check each selected philosophical filter
        for (const [theory, selectedCategory] of Object.entries(selectedPhilosophicalFilters)) {
            if (selectedCategory === null) continue; // Skip if no filter selected for this theory
            
            // Find the question for this theory
            const theoryQuestion = philDimension.questions.find(q => q.question === theory);
            if (!theoryQuestion || !theoryQuestion.score) return false;
            
            // Categorize the score and check if it matches the filter
            const scoreCategory = categorizePhilosophicalScore(theory, theoryQuestion.score);
            if (scoreCategory !== selectedCategory) return false;
        }
        
        return true; // Point passes all philosophical filters
    });
    
    // Update scenario and model filter options based on philosophical filtering
    const availableScenarios = new Set(filteredPoints.map(p => p.scenarioTitle));
    const availableModels = new Set(filteredPoints.map(p => p.llmName));
    
    // Update scenario filter options
    const scenarioFilter = document.getElementById('scenarioFilter');
    Array.from(scenarioFilter.options).forEach(option => {
        if (availableScenarios.has(option.value)) {
            option.style.display = 'block';
            option.classList.add('relevant-option');
        } else {
            option.style.display = 'none';
            option.classList.remove('relevant-option');
            // Deselect unavailable scenarios
            if (option.selected) {
                option.selected = false;
                selectedScenarios = selectedScenarios.filter(scenario => scenario !== option.value);
            }
        }
    });
    
    // Update model filter options
    const modelFilter = document.getElementById('modelFilter');
    Array.from(modelFilter.options).forEach(option => {
        if (availableModels.has(option.value)) {
            option.style.display = 'block';
            option.classList.add('relevant-option');
        } else {
            option.style.display = 'none';
            option.classList.remove('relevant-option');
            // Deselect unavailable models
            if (option.selected) {
                option.selected = false;
                selectedModels = selectedModels.filter(model => model !== option.value);
            }
        }
    });
}

// --- Apply Scenario Filter ---
if (selectedScenarios.length > 0) {
filteredPoints = filteredPoints.filter(point =>
selectedScenarios.includes(point.scenarioTitle)
);

const relModels = new Set(filteredPoints.map(p => p.llmName));
document.querySelectorAll('#modelFilter option').forEach(option => {
if (relModels.has(option.value)) {
option.style.display = 'block';
option.classList.add('relevant-option');
} else {
option.style.display = 'none';
option.selected = false;
}
});
}

// --- Apply Model Filter ---
if (selectedModels.length > 0) {
filteredPoints = filteredPoints.filter(point => selectedModels.includes(point.llmName));

const relScenarios = new Set(filteredPoints.map(p => p.scenarioTitle));
document.querySelectorAll('#scenarioFilter option').forEach(option => {
if (relScenarios.has(option.value)) {
option.style.display = 'block';
option.classList.add('relevant-option');
} else {
option.style.display = 'none';
option.selected = false;
}
});
}

// --- Update category badges ---
const relCats = new Set(filteredPoints.map(point => normalizeCategory(point.overallCategory)));
document.querySelectorAll('.filter-badge').forEach(badge => {
const cat = badge.dataset.category;
badge.style.opacity = (selectedScenarios.length > 0 || selectedModels.length > 0 || activeCategories.size !== 6) 
? (relCats.has(cat) ? '1' : '0.3')
: '1';
if (relCats.has(cat)) badge.classList.add('relevant-badge');
});

// --- Update alternate outcomes dropdown ---
const altOutcomes = document.getElementById('alternateOutcomes');
if (selectedScenarios.length === 1 && selectedModels.length === 1) {
const parentScenario = selectedScenarios[0];
const selModel = selectedModels[0];
const relationships = scenarioRelationships.get(parentScenario) || [];
const alternatives = relationships.filter(child => child.model === selModel);

if (alternatives && alternatives.length > 0) {
// Configure dropdown for multiple selection
altOutcomes.setAttribute('multiple', 'true');
altOutcomes.size = Math.min(alternatives.length, 6);

// Update options while preserving any valid existing selections
const currentSelections = Array.from(altOutcomes.selectedOptions).map(opt => opt.value);

altOutcomes.innerHTML = alternatives
.map(alt => {
const isSelected = currentSelections.includes(alt.childId) ? 'selected' : '';
return `
                               <option value="${alt.childId}" ${isSelected}>
                                   ${alt.childId} ${alt.relationshipType ? `(${alt.relationshipType})` : ''}
                               </option>
                           `;
}).join('');

altOutcomes.disabled = false;
altOutcomes.style.opacity = '1';
} else {
altOutcomes.innerHTML = '<option disabled>No alternate outcomes available</option>';
altOutcomes.disabled = true;
altOutcomes.style.opacity = '0.5';
}
} else {
altOutcomes.innerHTML = '<option disabled>Select one scenario and model first</option>';
altOutcomes.disabled = true;
altOutcomes.style.opacity = '0.5';
}

// Update the section in updateVisualization that handles alternate outcomes
if (selectedScenarios.length === 1 && selectedModels.length === 1) {
const parentScenarioTitle = selectedScenarios[0];
const selModel = selectedModels[0];

// Find the parent scenario
const parentPoint = dataPoints.find(p => 
p.scenarioTitle === parentScenarioTitle && 
p.llmName === selModel &&
p.isParent
);

if (parentPoint) {
// Start with the parent point
let points = [parentPoint];

// Add selected alternate scenarios if any are selected
if (selectedAlternateOutcomes.length > 0) {
const rels = scenarioRelationships.get(parentScenarioTitle) || [];
const alternatePoints = rels
.filter(child => 
child.model === selModel && 
selectedAlternateOutcomes.includes(child.childId)
)
.map(child => child.data);

points = points.concat(alternatePoints);
}

filteredPoints = points;
}
}


// --- Update available values in the values filter ---
const filtValues = new Set();
filteredPoints.forEach(point => {
    const characterDimension = point.dimensions.find(dim => dim.id === 'Character');
    if (characterDimension && characterDimension.questions) {
        const valuesQuestion = characterDimension.questions.find(q => q.question === 'Values');
        if (valuesQuestion && valuesQuestion.score && Array.isArray(valuesQuestion.score)) {
            valuesQuestion.score.forEach(value => filtValues.add(value));
        }
    }
});

document.querySelectorAll('#valuesFilter option').forEach(option => {
    if (filtValues.has(option.value)) {
        option.style.display = 'block';
        option.classList.add('relevant-option');
    } else {
        option.style.display = 'none';
        option.selected = false;
    }
});

if (filteredPoints.length === 0) {
alert('No data points match the current filters.');
// Clear philosophical highlighting when no data matches filters
clearPhilosophicalHighlighting();
return;
}

// --- Build the shared color mapping using composite keys (scenarioTitle + "_" + llmName) ---
const uniqueCompositeKeys = [...new Set(filteredPoints.map(p => p.scenarioTitle + '_' + p.llmName))];
scenarioColorMapping = {};
uniqueCompositeKeys.forEach((key, index) => {
scenarioColorMapping[key] = sharedBorderColors[index % sharedBorderColors.length];
});
console.log("Shared color mapping:", scenarioColorMapping);

// --- Update overview cards and scenario details ---
if (selectedScenarios.length > 0) {
const compData = filteredPoints.filter(point => selectedScenarios.includes(point.scenarioTitle));
populateOverview(compData);
populateScenarioDetails(compData);
// Update philosophical highlighting for scenario selection
if (compData.length > 0) {
    updatePhilosophicalHighlighting(compData);
}
} else if (selectedModels.length === 2) {
const compData = selectedModels.map(model =>
filteredPoints.find(point => point.llmName === model)
).filter(Boolean);
populateOverview(compData);
populateScenarioDetails(compData);
// Update philosophical highlighting for model comparison
if (compData.length > 0) {
    updatePhilosophicalHighlighting(compData);
}
} else {
// If only one scenario is selected, show a maximum of 4 models.
let compData = Array.isArray(filteredPoints) ? filteredPoints.slice(0, 4) : filteredPoints;
populateOverview(compData);
populateScenarioDetails(compData);
// Update philosophical highlighting for single scenario + model selection
if (compData.length > 0) {
    updatePhilosophicalHighlighting(compData);
}
}

// --- Create the 3D plot ---
const xValues = filteredPoints.map(point => point.x);
const yValues = filteredPoints.map(point => point.z);
const zValues = filteredPoints.map(point => point.y);
const plotData = [
{
type: 'mesh3d',
x: [-8, 12, 12, -8, -8, 12, 12, -8],
y: [0, 0, 0, 0, 8, 8, 8, 8],
z: [-21.6, -21.6, 0, 0, -21.6, -21.6, 0, 0],
i: [0, 0, 4, 4, 0, 0, 2, 2, 0, 1],
j: [1, 2, 5, 6, 1, 5, 3, 7, 0, 2],
k: [2, 3, 6, 7, 5, 4, 7, 6, 3, 3],
opacity: 0.1,
color: 'lightblue',
showlegend: false,
hoverinfo: 'none'
},
{
type: 'scatter3d',
x: xValues,
y: yValues,
z: zValues,
mode: 'markers',
marker: {
size: filteredPoints.map(p => p.isParent ? 8 : 6),
color: filteredPoints.map(p => getColorByCategory(p.overallCategory)),
opacity: 0.8,
line: {
color: filteredPoints.map(p => scenarioColorMapping[p.scenarioTitle + '_' + p.llmName] || '#000'),
width: filteredPoints.map(p => p.isParent ? 8 : 6)
}
},
text: filteredPoints.map(point => `
                   <b>${point.scenarioTitle}</b><br>
                   <b>Category:</b> ${point.overallCategory}<br>
                   <b>Model:</b> ${point.llmName}<br>
                   ${point.isParent ? '<b>Type:</b> Parent' : '<b>Type:</b> Alternative'}
               `),
hoverinfo: 'text',
showlegend: false
}
];
const layout = {
margin: { l: 0, r: 0, b: 0, t: 0 },
paper_bgcolor: '#04031d',
plot_bgcolor: '#04031d',
scene: {
bgcolor: '#04031d',
xaxis: { 
    title: 'Altruistic - Self Motivated', 
    range: [-8, 12], 
    titlefont: { size: 10, color: '#bbbbc3' },
    tickfont: { color: '#bbbbc3' },
    gridcolor: 'rgba(187, 187, 195, 0.2)',
    zerolinecolor: 'rgba(187, 187, 195, 0.3)'
},
yaxis: { 
    title: 'Habit/Instinct - Will Power', 
    range: [0, 8], 
    titlefont: { size: 10, color: '#bbbbc3' },
    tickfont: { color: '#bbbbc3' },
    gridcolor: 'rgba(187, 187, 195, 0.2)',
    zerolinecolor: 'rgba(187, 187, 195, 0.3)'
},
zaxis: { 
    title: 'Small Sacrifice - Large sacrifice', 
    range: [-21.6, 0], 
    titlefont: { size: 10, color: '#bbbbc3' },
    tickfont: { color: '#bbbbc3' },
    gridcolor: 'rgba(187, 187, 195, 0.2)',
    zerolinecolor: 'rgba(187, 187, 195, 0.3)'
},
camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } },
aspectmode: 'cube',
aspectratio: { x: 1, y: 1, z: 1 }
}
};
Plotly.newPlot('cube-plot', plotData, layout, {
displayModeBar: false,
responsive: true
});

// --- Update the media placeholder with the selected scenario's media URL ---
updateSelectedMedia();
}






function checkDescriptions() {
document.querySelectorAll('.scenario-description').forEach(function(desc) {
const textEl = desc.querySelector('.description-text');
const readMoreLink = desc.querySelector('.read-more');
// Compare scrollHeight (full content height) with clientHeight (visible height)
if (textEl.scrollHeight <= textEl.clientHeight) {
// Content fits, hide the read more link
readMoreLink.style.display = 'none';
} else {
readMoreLink.style.display = 'block';
}
});
}


function populateOverview(data) {
const overviewDiv = document.getElementById('overview');
if (!Array.isArray(data)) {
data = [data];
}

// Sort data to show parent scenarios first
data.sort((a, b) => (b.isParent ? 1 : 0) - (a.isParent ? 1 : 0));
data = data.slice(0, 4); // Limit to 4 items

const cards = data.map(item => {
const scores = getEthicsScores(item);
return `
                   <div class="comparison-card" 
                       data-scenario-id="${item.id}" 
                       style="border: 2px solid ${scenarioColorMapping[item.scenarioTitle + '_' + item.llmName] || '#000'};">
                       <h4>
                           ${getScenarioTitle(item)}
                           <small>(${item.llmName} ${getCategoryBadge(item.overallCategory)})</small>
                       </h4>
                       <div class="scenario-description">
                           <span class="description-text">
                               ${item.scenarioDescription || 'No description available'}
                           </span>
                           <span class="read-more">Read more</span>
                       </div>
                       <div class="ethics-scores">
                           <div>Deontology: ${scores.deontologyScore}</div>
                           <div>Utilitarianism: ${scores.utilitarianismScore}</div>
                           <div>Virtue Ethics: ${scores.virtueEthicsScore}</div>
                       </div>
                   </div>
               `;
}).join('');

overviewDiv.innerHTML = cards;
attachComparisonCardHandlers();
checkDescriptions();
}

// After setting overviewDiv.innerHTML = cards;
document.querySelectorAll('.comparison-card').forEach(card => {
card.addEventListener('click', function() {
const id = card.getAttribute('data-scenario-id');

// Toggle selection: if already selected, unselect it.
if (card.classList.contains('selected-card')) {
card.classList.remove('selected-card');
selectedComparison = selectedComparison.filter(selectedId => selectedId !== id);
} else {
// Only allow selection if fewer than 2 are already selected.
if (selectedComparison.length < 2) {
card.classList.add('selected-card');
selectedComparison.push(id);
} else {
alert("You can only compare 2 scenarios/models at a time.");
}
}

// If exactly 2 items are selected, update scenario details.
if (selectedComparison.length === 2) {
// Filter dataPoints to only include those with IDs in selectedComparison.
const compData = dataPoints.filter(point => selectedComparison.includes(point.id));
populateScenarioDetails(compData);
// Update philosophical highlighting for selected comparison
updatePhilosophicalHighlighting(compData);
} else {
// Optionally, clear or update the scenario details if fewer than 2 are selected.
// For example, you could clear the details:
// document.getElementById('scenarioAccordion').innerHTML = '';
// Clear philosophical highlighting when less than 2 scenarios selected
clearPhilosophicalHighlighting();
}
});
});





// Update the updateMediaDisplay function to handle URLs more robustly
function updateMediaDisplay(url) {
const container = document.getElementById('media-placeholder');
const openMediaButton = document.getElementById('open-media');

// Update the current URL
currentMediaUrl = url || "";

// Enable/disable the "Open in New Window" button based on URL availability
openMediaButton.disabled = !currentMediaUrl;

if (!url) {
container.innerHTML = "<p class='text-center text-muted mt-3'>No media available for this selection</p>";
return;
}

try {
// Handle different types of URLs
if (url.includes("reddit.com")) {
container.innerHTML = `
                       <blockquote class="reddit-embed" data-embed-media="true" data-height="500">
                           <a href="${url}">View this post on Reddit</a>
                       </blockquote>
                   `;
// Reload Reddit embed script
let existingScript = document.getElementById('reddit-embed-script');
if (existingScript) {
existingScript.remove();
}
let script = document.createElement('script');
script.id = 'reddit-embed-script';
script.async = true;
script.src = 'https://embed.reddit.com/widgets.js';
script.charset = 'UTF-8';
document.body.appendChild(script);
} else if (url.includes("youtube.com") || url.includes("youtu.be")) {
// Clear the container first
container.innerHTML = '';

// Extract video ID from various YouTube URL formats
let videoId;
if (url.includes('youtube.com')) {
const urlParams = new URL(url).searchParams;
videoId = urlParams.get('v');
} else if (url.includes('youtu.be')) {
videoId = url.split('/').pop().split('?')[0];
}

if (videoId) {
// Create a new iframe element
const iframe = document.createElement('iframe');
iframe.width = '100%';
iframe.height = '100%';
iframe.src = `https://www.youtube.com/embed/${videoId}`;
iframe.frameBorder = '0';
iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
iframe.allowFullscreen = true;

// Append the new iframe
container.appendChild(iframe);
} else {
console.error('Could not extract YouTube video ID from URL:', url);
container.innerHTML = `
                           <p class='text-center text-muted mt-3'>
                               Unable to display video. <a href="${url}" target="_blank">Open externally</a>
                           </p>`;
}
} else {
// For other URLs, try to embed them directly
// Create a new iframe to force a refresh
const iframe = document.createElement('iframe');
iframe.style.width = '100%';
iframe.style.height = '100%';
iframe.style.border = 'none';
iframe.src = url;
iframe.allowFullscreen = true;

// Clear the container and append the new iframe
container.innerHTML = '';
container.appendChild(iframe);
}
} catch (error) {
console.error('Error updating media display:', error);
container.innerHTML = `
                   <p class='text-center text-muted mt-3'>
                       Unable to display media. <a href="${url}" target="_blank">Open externally</a>
                   </p>`;
}
}

// Helper function to convert YouTube URL to embed URL
function convertYouTubeUrl(url) {
try {
let videoId;
if (url.includes('youtube.com')) {
const urlParams = new URL(url).searchParams;
videoId = urlParams.get('v');
} else if (url.includes('youtu.be')) {
videoId = url.split('/').pop().split('?')[0];
}

if (videoId) {
return `https://www.youtube.com/embed/${videoId}`;
}
return url;
} catch (error) {
console.error('Error converting YouTube URL:', error);
return url;
}
}

// Update the updateSelectedMedia function to include logging
function updateSelectedMedia() {
console.log('updateSelectedMedia called');
console.log('Current selected scenarios:', selectedScenarios);

if (selectedScenarios.length === 0) {
console.log('No scenarios selected, clearing media');
updateMediaDisplay("");
return;
}

if (selectedScenarios.length === 1) {
// Find all points that match the selected scenario title
const scenarioPoints = dataPoints.filter(p => p.scenarioTitle === selectedScenarios[0]);
console.log('Found scenario points:', scenarioPoints);

// First try to find the parent scenario
let parentScenario = scenarioPoints.find(p => p.isParent);

// If no parent found but we have points, use the first point
if (!parentScenario && scenarioPoints.length > 0) {
parentScenario = scenarioPoints[0];
}

if (parentScenario && parentScenario.url) {
console.log('Updating media with URL:', parentScenario.url);
updateMediaDisplay(parentScenario.url);
} else {
console.log('No URL found for scenario:', selectedScenarios[0]);
updateMediaDisplay("");
}
} else {
console.log('Multiple scenarios selected, clearing media');
updateMediaDisplay("");
}
}


function getScenarioTitle(data) {
// Only include the link if a nonempty URL exists
if (data.url && data.url.trim() !== "") {
return `${data.scenarioTitle} <a href="${data.url}" target="_blank" class="scenario-link">
                           <i class="fas fa-external-link-alt"></i></a>`;
}
return data.scenarioTitle;
}


function getCategoryBadge(category) {
let normalizedCategory = category.toLowerCase().replace(/\s+/g, '-');
if (normalizedCategory === 'morally_grey' || normalizedCategory === 'morally-grey') {
normalizedCategory = 'morally-grey';
}
const categoryClass = `category-badge category-${normalizedCategory}`;
return `<span class="${categoryClass}">${category}</span>`;
}
function getColorByCategory(category) {
  const colorMap = {
    'evil': '#ff36c4',
    'virtue': '#4ade80',
    'vice': '#fcbd21',
    'sin': '#9e005d',
    'morally_grey': '#a1a1aa',
    'world_building': '#7f47dd'
  };
  return colorMap[category] || '#a1a1aa';
}
// Helper function: normalize a category string.
function normalizeCategory(category) {
return category.toLowerCase().replace(/\s+/g, '_');
}
function populateScenarioDetails(scenarioData) {
// Normalize input to array and limit to 2 scenarios for comparison
if (!Array.isArray(scenarioData)) {
scenarioData = [scenarioData];
}
if (scenarioData.length > 2) {
scenarioData = scenarioData.slice(0, 2);
}

const scenarioAccordion = document.getElementById('scenarioAccordion');

// Early return if no valid data
if (!scenarioData.length || !scenarioData[0].dimensions) {
scenarioAccordion.innerHTML = '<div class="alert alert-info">No scenario data available.</div>';
return;
}

// Get dimension score helper
function getDimensionScore(scenario, dimensionId) {
if (!['Ends', 'Means', 'Character'].includes(dimensionId)) return null;

const scores = {
'Ends': scenario.x,
'Means': scenario.y,
'Character': scenario.z
};
return scores[dimensionId]?.toFixed(2) ?? null;
}

// Get range value helper
function getRange(dimensionId, questionIndex) {
const rangeMap = {
'Ends': {
default: questionIndex < 3 ? "0 to 4" : "0 to -4"
},
'Means': {
0: "0 to -4",
1: "0 to -6",
2: "0 to -4",
3: "0 to -4",
4: "0.01 to 1.2"
},
'Character': {
0: "0 to 1",
1: "0 to 2", 
2: "0 to 4",
3: "0 to 1",
4: "Array"  // Values question
}
};

return rangeMap[dimensionId]?.[questionIndex] || 
rangeMap[dimensionId]?.default || 
"N/A";
}

// Build table structure helper
function getTableStructure(isPhilosophical) {
if (isPhilosophical) {
return {
colgroup: `
                               <col style="width:20%;">
                               <col style="width:20%;">
                               <col style="width:60%;">
                           `,
header: `
                               <tr>
                                   <th>Question</th>
                                   <th>Score</th>
                                   <th>Justification</th>
                               </tr>
                           `
};
}

return {
colgroup: `
                           <col style="width:10%;">
                           <col style="width:10%;">
                           <col style="width:12.5%;">
                           <col style="width:70%;">
                       `,
header: `
                           <tr>
                               <th>Question</th>
                               <th>Score</th>
                               <th>Range</th>
                               <th>Justification</th>
                           </tr>
                       `
};
}

// Create question row helper
function createQuestionRow(question, tooltip, range, isPhilosophical) {
const tooltipHTML = tooltip ? `
                       <div style="display: inline-flex; align-items: center; gap: 4px;">
                           <span class="tooltip-container">
                               <i class="fas fa-info-circle tooltip-icon" aria-hidden="true"></i>
                               <span class="tooltip-content" role="tooltip">${tooltip.info}</span>
                           </span>
                           <span class="tooltip-container">
                               <i class="fas fa-question-circle tooltip-icon" aria-hidden="true"></i>
                               <span class="tooltip-content" role="tooltip">${tooltip.question}</span>
                           </span>
                       </div>
                   ` : '';

// Handle different score types: numbers, strings, and arrays (for Values)
let score;
if (typeof question.score === 'number') {
    score = question.score.toFixed(1);
} else if (Array.isArray(question.score)) {
    // Format array as comma-separated list for Values questions
    score = question.score.join(', ');
} else {
    score = question.score;
}

if (isPhilosophical) {
return `
                           <tr>
                               <td>${question.question}${tooltipHTML}</td>
                               <td>${score}</td>
                               <td>${question.justification}</td>
                           </tr>
                       `;
}

return `
                       <tr>
                           <td>${question.question}${tooltipHTML}</td>
                           <td>${score}</td>
                           <td>${range}</td>
                           <td>${question.justification}</td>
                       </tr>
                   `;
}

// Create scenario table helper
function createScenarioTable(scenario, dimension, isPhilosophical, dimensionId, tableStructure) {
const dimensionScore = getDimensionScore(scenario, dimension.id);
const scoreDisplay = dimensionScore !== null && 
['Ends', 'Means', 'Character'].includes(dimension.id) ?
` (${dimension.id} Score: ${dimensionScore})` : '';

const questionRows = dimension.questions.map((question, index) => {
const range = !isPhilosophical ? getRange(dimension.id, index) : "N/A";
const tooltip = questionTooltips[question.question] || null;
return createQuestionRow(question, tooltip, range, isPhilosophical);
}).join('');

return `
                       <div class="col-md-${scenarioData.length === 1 ? '12' : '6'} scenario-table-container">
                           <h5 class="mb-3">${scenario.scenarioTitle} (${scenario.llmName})${scoreDisplay}</h5>
                           <table class="table table-bordered compact-table">
                               <colgroup>${tableStructure.colgroup}</colgroup>
                               <thead>${tableStructure.header}</thead>
                               <tbody>${questionRows}</tbody>
                           </table>
                       </div>
                   `;
}

// Main content generation
const dimensionContent = scenarioData[0].dimensions.map((dimension, index) => {
const dimensionId = `dimension${index}`;
const collapseId = `collapse${index}`;
const isPhilosophical = dimension.id.trim().toLowerCase() === 'philosophical analysis';
const tableStructure = getTableStructure(isPhilosophical);

const scenarioTables = scenarioData.map(scenario => 
createScenarioTable(
scenario, 
scenario.dimensions[index], 
isPhilosophical, 
dimensionId, 
tableStructure
)
).join('');

return `
                       <div class="card">
                           <div class="card-header" id="${dimensionId}-header">
                               <h2 class="mb-0">
                                   <button class="btn btn-link ${index === 0 ? '' : 'collapsed'}" 
                                           type="button" 
                                           data-toggle="collapse" 
                                           data-target="#${collapseId}">
                                       <strong>${dimension.id} (${dimension.label})</strong>
                                   </button>
                               </h2>
                           </div>
                           <div id="${collapseId}" 
                               class="collapse ${index === 0 ? 'show' : ''}" 
                               data-parent="#scenarioAccordion">
                               <div class="card-body">
                                   <div class="row">
                                       ${scenarioTables}
                                   </div>
                               </div>
                           </div>
                       </div>
                   `;
}).join('');

scenarioAccordion.innerHTML = dimensionContent;
}








// Event Listeners
// Model Filter Event Listener
document.getElementById('modelFilter').addEventListener('change', function(e) {
if (isUpdatingFilters || isCategoryFiltering) return;

selectedModels = Array.from(e.target.selectedOptions).map(option => option.value);

// Enforce maximum selection limit
if (selectedModels.length > 4) {
alert('Please select a maximum of 4 models for comparison');
selectedModels = selectedModels.slice(0, 4);
Array.from(this.options).forEach(option => {
option.selected = selectedModels.includes(option.value);
});
}

// Update alternate outcomes if exactly one scenario and one model are selected
const alternateOutcomes = document.getElementById('alternateOutcomes');

if (selectedScenarios.length === 1 && selectedModels.length === 1) {
const parentScenario = selectedScenarios[0];
const selectedModel = selectedModels[0];

const relationships = scenarioRelationships.get(parentScenario) || [];
const alternatives = relationships.filter(child => child.model === selectedModel);

if (alternatives && alternatives.length > 0) {
// Configure dropdown for multiple selection
alternateOutcomes.setAttribute('multiple', 'true');
alternateOutcomes.size = Math.min(alternatives.length, 6);
alternateOutcomes.disabled = false;

// Clear existing options
alternateOutcomes.innerHTML = '';

// Add new options
alternatives.forEach(alt => {
const option = document.createElement('option');
option.value = alt.childId;
option.text = `${alt.childId} ${alt.relationshipType ? `(${alt.relationshipType})` : ''}`;
alternateOutcomes.appendChild(option);
});

// Enable the dropdown
alternateOutcomes.disabled = false;
alternateOutcomes.style.opacity = '1';
} else {
alternateOutcomes.innerHTML = '<option disabled>No alternate outcomes available</option>';
alternateOutcomes.disabled = true;
alternateOutcomes.style.opacity = '0.5';
}
} else {
alternateOutcomes.innerHTML = '<option disabled>Select one scenario and model first</option>';
alternateOutcomes.disabled = true;
alternateOutcomes.style.opacity = '0.5';
}

updateVisualization();
});


document.getElementById('scenarioFilter').addEventListener('change', function(e) {
if (isUpdatingFilters || isCategoryFiltering) return;

// Clear previous selections
selectedModels = [];
selectedAlternateOutcomes = []; // Add this to handle alternate outcomes
document.getElementById('modelFilter').selectedIndex = -1;
document.getElementById('alternateOutcomes').innerHTML = '<option disabled>Select a model first</option>';
document.getElementById('alternateOutcomes').disabled = true;

// Update selected scenarios
selectedScenarios = Array.from(e.target.selectedOptions).map(option => option.value);

// Enforce maximum selection limit
if (selectedScenarios.length > 4) {
alert('Please select a maximum of 4 scenarios for comparison');
selectedScenarios = selectedScenarios.slice(0, 4);
Array.from(this.options).forEach(option => {
option.selected = selectedScenarios.includes(option.value);
});
}

// Show/hide scenarios based on selection count
const options = Array.from(this.options);
options.forEach(option => {
if (selectedScenarios.length < 4) {
option.style.display = 'block';
} else {
option.style.display = selectedScenarios.includes(option.value) ? 'block' : 'none';
}
});

// Update model filter based on selected scenarios
const modelFilter = document.getElementById('modelFilter');
const availableModels = new Set();

selectedScenarios.forEach(scenario => {
const scenarioData = dataPoints.filter(point => 
point.scenarioTitle === scenario
);
scenarioData.forEach(data => {
availableModels.add(data.llmName);
});
});

// Populate model filter
if (availableModels.size > 0) {
modelFilter.innerHTML = Array.from(availableModels)
.map(model => `<option value="${model}">${model}</option>`)
.join('');
modelFilter.disabled = false;
} else {
modelFilter.innerHTML = '<option disabled>No models available</option>';
modelFilter.disabled = true;
}

updateVisualization();
});





// Update the alternate outcomes event listener
document.getElementById('alternateOutcomes').addEventListener('change', function(e) {
if (isUpdatingFilters) return;

// Update selected alternate outcomes
selectedAlternateOutcomes = Array.from(this.selectedOptions).map(opt => opt.value);

// Enforce maximum of 3 selections
if (selectedAlternateOutcomes.length > 3) {
alert('Please select a maximum of 3 alternate scenarios');
selectedAlternateOutcomes = selectedAlternateOutcomes.slice(0, 3);
Array.from(this.options).forEach(option => {
option.selected = selectedAlternateOutcomes.includes(option.value);
});
}

// Only update visualization, without refreshing other filters
let updatedPoints = [];

if (selectedScenarios.length === 1 && selectedModels.length === 1) {
const parentScenarioTitle = selectedScenarios[0];
const selModel = selectedModels[0];

// Get the parent scenario
const parentPoint = dataPoints.find(p => 
p.scenarioTitle === parentScenarioTitle && 
p.llmName === selModel &&
p.isParent
);

// Get the selected alternate scenarios
const rels = scenarioRelationships.get(parentScenarioTitle) || [];
const alternatePoints = rels
.filter(child => 
child.model === selModel && 
selectedAlternateOutcomes.includes(child.childId)
)
.map(child => child.data);

if (parentPoint) {
updatedPoints = [parentPoint, ...alternatePoints];
}
}

// Update only if we have points to show
if (updatedPoints.length > 0) {
// Update plot and overview without changing filters
createPlot(updatedPoints);
populateOverview(updatedPoints);
}
});



// Values Filter Listener
document.getElementById('valuesFilter').addEventListener('change', function(e) {
if (isUpdatingFilters || isCategoryFiltering) return;

// Update selected values
selectedValues = Array.from(e.target.selectedOptions).map(option => option.value);

// Clear other filters
selectedScenarios = [];
selectedModels = [];
document.getElementById('scenarioFilter').selectedIndex = -1;
document.getElementById('modelFilter').selectedIndex = -1;
document.getElementById('alternateOutcomes').innerHTML = '<option disabled>Select a scenario and model first</option>';

// Filter scenarios based on selected values
const scenarioFilter = document.getElementById('scenarioFilter');
const availableScenarios = dataPoints.filter(point => {
    if (!point.isParent) return false;
    if (selectedValues.length === 0) return true;
    
    // Check if this scenario contains any of the selected values
    const characterDimension = point.dimensions.find(dim => dim.id === 'Character');
    if (characterDimension && characterDimension.questions) {
        const valuesQuestion = characterDimension.questions.find(q => q.question === 'Values');
        if (valuesQuestion && valuesQuestion.score && Array.isArray(valuesQuestion.score)) {
            return selectedValues.some(selectedValue => valuesQuestion.score.includes(selectedValue));
        }
    }
    return false;
});

// Create a Set of unique scenario titles to prevent duplicates
const uniqueScenarios = [...new Set(availableScenarios.map(point => point.scenarioTitle))];

// Update scenario filter options with unique scenarios
scenarioFilter.innerHTML = uniqueScenarios
.map(title => `<option value="${title}">${title}</option>`)
.join('');

// Clear model filter
document.getElementById('modelFilter').innerHTML = '<option disabled>Select a scenario first</option>';

updateVisualization();
});

// Philosophical Analysis Filter Event Listeners
document.querySelectorAll('.phil-button').forEach(button => {
    button.addEventListener('click', function() {
        const theory = this.dataset.theory;
        const value = this.dataset.value;
        
        // Remove active class from all buttons in this theory
        document.querySelectorAll(`.phil-button[data-theory="${theory}"]`).forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Toggle the clicked button
        if (selectedPhilosophicalFilters[theory] === value) {
            // If already selected, deselect it
            selectedPhilosophicalFilters[theory] = null;
        } else {
            // Select this button
            this.classList.add('active');
            selectedPhilosophicalFilters[theory] = value;
        }
        
        // Update visualization with new philosophical filters
        updateVisualization();
    });
});



document.addEventListener('DOMContentLoaded', fetchScenarios);
document.addEventListener('DOMContentLoaded', () => {
renderSurveyQuestions();
});


// Remove duplicate scenarioFilter listener (we now have one combined listener above)


// Filter Badge Listener (unchanged):
document.querySelectorAll('.filter-badge').forEach(badge => {
badge.addEventListener('click', function() {
if (isUpdatingFilters) return;

const category = this.dataset.category;

// Reset all badges to inactive
document.querySelectorAll('.filter-badge').forEach(b => {
b.classList.remove('active');
b.style.opacity = '0.3';
});

// If clicking an already active sole category, reset all
if (activeCategories.size === 1 && activeCategories.has(category)) {
activeCategories = new Set(['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building']);
document.querySelectorAll('.filter-badge').forEach(b => {
b.classList.add('active');
b.style.opacity = '1';
});
} else {
// Set only this category as active
activeCategories = new Set([category]);
this.classList.add('active');
this.style.opacity = '1';
}

// Reset other filters
selectedModels = [];
selectedScenarios = [];
selectedValues = [];
document.getElementById('modelFilter').selectedIndex = -1;
document.getElementById('scenarioFilter').selectedIndex = -1;
document.getElementById('valuesFilter').selectedIndex = -1;
document.getElementById('alternateOutcomes').innerHTML = '<option>Select a scenario and model first</option>';

updateVisualization();
});
});


// Update the clear filters function to handle alternate outcomes
document.getElementById('clearFilters').addEventListener('click', function() {
// Reset all filter selections
selectedModels = [];
selectedScenarios = [];
selectedValues = [];
selectedAlternateOutcomes = [];

// Reset philosophical filters
selectedPhilosophicalFilters = {
    'Deontology': null,
    'Utilitarianism': null,
    'Virtue Ethics': null
};

// Reset philosophical button visual states
document.querySelectorAll('.phil-button').forEach(btn => {
    btn.classList.remove('active', 'highlighted');
});

// Reset active categories
activeCategories = new Set(['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building']);

isUpdatingFilters = true;

// Clear filter selections
document.getElementById('modelFilter').selectedIndex = -1;
document.getElementById('scenarioFilter').selectedIndex = -1;
document.getElementById('valuesFilter').selectedIndex = -1;

// Reset alternate outcomes dropdown
const alternateOutcomes = document.getElementById('alternateOutcomes');
alternateOutcomes.innerHTML = '<option disabled>Select one scenario and one model</option>';
alternateOutcomes.disabled = true;

// Reset filter badges
document.querySelectorAll('.filter-badge').forEach(badge => {
badge.classList.add('active');
badge.style.opacity = '1';
});

isUpdatingFilters = false;
isCategoryFiltering = false;

// Update filters and visualization
updateFilters();
const parentScenarios = dataPoints.filter(point => point.isParent);
createPlot(parentScenarios);
updateVisualization();
});

document.addEventListener('click', function(e) {
if (e.target.classList.contains('read-more')) {
// Find the parent card (.comparison-card)
const card = e.target.closest('.comparison-card');
card.classList.toggle('expanded');
// Update the link text accordingly
if (card.classList.contains('expanded')) {
e.target.textContent = 'Show less';
} else {
e.target.textContent = 'Read more';
}
}
});
// Call the render function when the page loads
document.addEventListener('DOMContentLoaded', () => {
renderSurveyQuestions();
});

document.addEventListener('DOMContentLoaded', function() {
const navbarToggler = document.querySelector('.navbar-toggler');
const navbarCollapse = document.querySelector('.navbar-collapse');

navbarToggler.addEventListener('click', function() {
navbarCollapse.classList.toggle('show');
});

// Close menu when clicking outside
document.addEventListener('click', function(event) {
const isClickInside = navbarToggler.contains(event.target) || navbarCollapse.contains(event.target);
if (!isClickInside && navbarCollapse.classList.contains('show')) {
navbarCollapse.classList.remove('show');
}
});

// Close menu when clicking a nav link
document.querySelectorAll('.nav-link').forEach(link => {
link.addEventListener('click', function() {
if (window.innerWidth < 992) {
navbarCollapse.classList.remove('show');
}
});
});
});






</script>

    <!-- Footer -->
    <footer style="background-color: #e9ecef; padding: 20px 0; text-align: center; margin-top: 40px; border-top: 1px solid #dee2e6;">
        <div class="container">
            <p>&copy; 2025 The Moral Cube. All rights reserved.</p>
            <p>
                <a href="/feedback.html" style="color: #4A5568; text-decoration: none;">Feedback</a> |
                <a href="/privacy-policy.html" style="color: #4A5568; text-decoration: none;">Privacy Policy</a> |
                <a href="https://www.linkedin.com/in/scott-m-young/" target="_blank" style="color: #4A5568; text-decoration: none;">
                    <i class="fab fa-linkedin"></i> Contact
                </a>
            </p>
        </div>
    </footer>
</body>
</html>