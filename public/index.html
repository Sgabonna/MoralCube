<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Moral Cube</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" />
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600&family=Inter:wght@400;500&display=swap" rel="stylesheet">
    <style>
        /* Global Styles */
        body {
        padding: 20px;
        background-color: #f8f9fa;
        font-family: 'Inter', sans-serif;
        }

        /* Main Container */
        .main-container {
        max-width: 1600px;
        margin: 0 auto;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        padding: 20px;
        }

        /* Plot Container & Cube Plot */
        .plot-container {
        background-color: white;
        border-radius: 6px;
        padding: 5px;
        height: 400px;
        display: flex;
        align-items: center;
        justify-content: center;
        }
        #cube-plot {
        width: 100%;
        height: 100%;
        }

        /* Page Header */
        .page-header {
        background-color: #D7E8FF;
        padding: 20px;
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        /* Navigation */
        .navbar {
        padding: 0;
        margin-top: auto;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
        box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.05);
        width: 100%;
        }
        .navbar-nav {
        display: flex;
        flex-direction: row;
        justify-content: center;
        width: 100%;
        padding: 0.5rem 0;
        }
        .navbar-nav .nav-link {
        padding: 0.7rem 1.2rem;
        transition: all 0.2s ease;
        border-radius: 4px;
        font-family: 'Inter', sans-serif;
        font-weight: 500;
        font-size: 1.2rem;
        white-space: nowrap;
        }
        .navbar-nav .nav-link:hover {
        background-color: rgba(255, 255, 255, 0.4);
        color: #2c5282;
        }
        .navbar-nav .nav-item {
        position: relative;
        margin: 0 1rem;
        }
        .navbar-nav .nav-item:not(:last-child)::after {
        content: "";
        position: absolute;
        right: -3px;
        top: 50%;
        transform: translateY(-50%);
        height: 4px;
        width: 4px;
        border-radius: 50%;
        background-color: #718096;
        opacity: 0.5;
        }

        /* Media Queries for Navigation */
        @media (max-width: 991.98px) {
        .navbar-nav .nav-item:not(:last-child)::after {
            display: none;
        }
        .navbar-nav .nav-item {
            text-align: center;
        }
        .navbar-collapse {
            display: flex !important;
            justify-content: center !important;
            width: 100% !important;
        }
        .navbar-nav {
            flex-direction: row;
            justify-content: center;
            width: max-content !important;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding: 0.5rem 1rem !important;
        }
        .navbar-nav::-webkit-scrollbar {
            display: none;
        }
        .navbar-toggler {
            display: none !important;
        }
        .nav-item.mx-3 {
            margin: 0 0.5rem !important;
        }
        .nav-link {
            padding: 0.8rem !important;
        }
        }
        @media (max-width: 768px) {
        .nav-link {
            font-size: 1rem;
            padding: 0.5rem 0.8rem;
        }
        }
        @media (max-width: 576px) {
        .page-header h1 {
            font-size: 2.5rem !important;
            margin-right: 0 !important;
        }
        .nav-item.mx-3 {
            margin: 0 0.3rem !important;
        }
        .nav-link {
            padding: 0.6rem !important;
        }
        }

        /* Filter Section */
        .filter-section {
        background-color: #f8f9fa;
        padding: 20px;
        border-radius: 6px;
        margin-bottom: 20px;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        }
        .filter-group {
        margin-bottom: 15px;
        }
        .filter-group select {
        width: 100%;
        min-height: 150px;
        }
        .filter-group select option {
        padding: 8px 12px;
        font-size: 14px;
        }
        .filter-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        font-size: 14px;
        }
        
        /* Filter action buttons row */
        .filter-actions {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        /* Category Badges */
        .category-badge {
        display: inline-block;
        padding: 0.25em 0.6em;
        font-size: 0.9rem;
        font-weight: 500;
        border-radius: 4px;
        margin-left: 0.5rem;
        }
        .category-evil {
        background-color: #dc3545;
        color: white;
        }
        .category-virtue {
        background-color: #28a745;
        color: white;
        }
        .category-vice {
        background-color: #ffc107;
        color: black;
        }
        .category-sin {
        background-color: #6c757d;
        color: white;
        }
        .category-morally-grey,
        .category-morally_grey {
        background-color: #6610f2;
        color: white;
        }
        .category-world-building,
        .category-world_building {
        background-color: #17a2b8;
        color: white;
        }

        /* Tooltip Styles */
        .tooltip {
        position: relative;
        display: inline-block;
        }
        .tooltip .tooltiptext {
        visibility: hidden;
        opacity: 0;
        background-color: #333;
        color: #fff;
        text-align: center;
        padding: 5px 10px;
        border-radius: 4px;
        position: absolute;
        z-index: 1000;
        bottom: 125%;
        left: 50%;
        transform: translateX(-50%);
        transition: opacity 0.3s;
        white-space: nowrap;
        font-size: 0.75rem;
        }
        .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
        }
        .tooltip .tooltiptext::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border-width: 5px;
        border-style: solid;
        border-color: #333 transparent transparent transparent;
        }

        /* Additional Tooltip Container */
        .tooltip-container {
        position: relative;
        display: inline-flex;
        align-items: center;
        margin-left: 8px;
        vertical-align: middle;
        }
        .tooltip-container .tooltip-content {
        visibility: hidden;
        opacity: 0;
        position: absolute;
        bottom: 150%;
        left: 5px;
        padding: 8px 12px;
        background-color: #2d3748;
        color: white;
        border-radius: 6px;
        font-size: 13px;
        line-height: 1.4;
        white-space: normal;
        max-width: 300px;
        width: max-content;
        z-index: 1000;
        transition: all 0.2s ease;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        text-align: left;
        }
        .tooltip-container:hover .tooltip-content {
        visibility: visible;
        opacity: 1;
        bottom: 140%;
        }

        /* Media Placeholder */
        #media-placeholder iframe {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: contain;
        }

        /* Overview & Comparison Cards */
        #overview {
        height: 500px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        padding: 15px;
        border-radius: 6px;
        margin-bottom: 20px;
        }
        .comparison-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 10px;
        }
        .comparison-card {
        cursor: pointer;
        height: 125px;
        box-sizing: border-box;
        padding: 5px 8px;
        margin-bottom: 5px;
        overflow: hidden;
        font-size: 0.75rem;
        transition: height 0.3s ease;
        }
        .comparison-card.expanded {
        height: auto;
        overflow: visible;
        }
        .comparison-card:nth-child(odd) {
        background-color: #e9ecef;
        }
        .comparison-card:nth-child(even) {
        background-color: #f8f9fa;
        }
        .comparison-card h4 {
        font-size: 0.8rem;
        margin: 0;
        }
        .scenario-description .description-text {
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        transition: all 0.3s ease;
        }
        .comparison-card.expanded .scenario-description .description-text {
        -webkit-line-clamp: unset;
        }
        .read-more {
        display: block;
        color: #007bff;
        cursor: pointer;
        font-size: 0.7rem;
        margin-top: 3px;
        }

        /* Tables */
        .table {
        margin-bottom: 0;
        font-size: 1rem;
        }
        .table th {
        background-color: #f8f9fa;
        font-weight: 600;
        border-bottom: 2px solid #dee2e6;
        padding: 12px;
        }
        .table td {
        vertical-align: middle;
        padding: 12px;
        }
        .compact-table {
        font-size: 0.75rem;
        margin-bottom: 10px;
        }
        .compact-table th,
        .compact-table td {
        padding: 4px 6px;
        vertical-align: middle;
        }

        /* Scenario Section */
        .scenario-section {
        margin-top: 20px;
        padding: 20px;
        background-color: #f8f9fa;
        border-radius: 6px;
        }

        /* Modal Styles */
        .modal-body h4 {
        color: #2c5282;
        font-weight: 600;
        }
        .modal-body h5 {
        color: #4a5568;
        font-weight: 600;
        }
        .modal-body p {
        line-height: 1.6;
        color: #2d3748;
        }
        .modal-body .ml-4 {
        border-left: 3px solid #e2e8f0;
        padding-left: 1rem;
        }
        .modal-body strong {
        color: #2d3748;
        }

        /* Banner & Auth Buttons */
        .banner {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 2rem;
        background-color: white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .auth-buttons {
        display: flex;
        align-items: center;
        gap: 1rem;
        }
        .auth-btn {
        padding: 0.5rem 1rem;
        border-radius: 4px;
        border: none;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s;
        }
        #login {
        background-color: #007bff;
        color: white;
        }
        #logout {
        background-color: #f8f9fa;
        color: #333;
        }
        .avatar {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        object-fit: cover;
        }
        /* Add this to your existing styles */
        #login:hover {
            background-color: #EBF4FF;
            border-color: #B2D5FF;
            color: #1A365D;
        }

        #logout:hover {
            background-color: #EDF2F7;
            border-color: #CBD5E0;
            color: #2D3748;
        }
        .navbar-nav .nav-link {
            font-family: 'Inter', sans-serif !important;
            font-weight: 500 !important;
            font-size: 1.2rem !important;
            padding: 0.7rem 1.2rem;
            transition: all 0.2s ease;
            border-radius: 4px;
            white-space: nowrap;
        }
        
        /* User Surveys Section */
        .user-surveys-section {
            background-color: #f0f4f8;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            overflow-y: auto;
            max-height: 150px;
        }
        
        .user-surveys-section h5 {
            font-size: 0.9rem;
            margin-bottom: 10px;
            color: #2c5282;
        }
        
        .user-surveys-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .user-surveys-list li {
            padding: 6px 10px;
            font-size: 0.8rem;
            border-radius: 4px;
            margin-bottom: 5px;
            background-color: white;
            border-left: 3px solid #4299e1;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .user-surveys-list li:hover {
            background-color: #ebf4ff;
        }
        
        .no-surveys-message {
            font-size: 0.8rem;
            color: #718096;
            font-style: italic;
            text-align: center;
            padding: 10px;
        }
        
        .login-prompt {
            font-size: 0.8rem;
            color: #4a5568;
            text-align: center;
            padding: 10px;
        }
        
        .login-link {
            color: #4299e1;
            cursor: pointer;
            text-decoration: underline;
        }
        /* Add this to your CSS */
        .modal-dialog-scrollable {
            max-height: 90vh;
        }

        .modal-dialog-scrollable .modal-body {
            overflow-y: auto;
            max-height: calc(90vh - 120px);
        }

        .form-control-range {
            width: 100%;
        }
        .modal-dialog-scrollable {
            display: flex;
            flex-direction: column;
            height: calc(100% - 60px);
            max-height: 90vh;
        }
        
        .modal-dialog-scrollable .modal-content {
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .modal-dialog-scrollable .modal-body {
            overflow-y: auto !important;
            padding-right: 15px;
            scrollbar-width: thin;
        }
        
        #surveyTabContent {
            overflow: visible !important;
            max-height: none !important;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="page-header" style="background-color: #D7E8FF; padding: 20px 20px 0 20px; position: relative;">
            <div class="container-fluid">
                <!-- Logo and Title Section -->
                <div class="d-flex justify-content-between align-items-center" style="margin-bottom: 1.5rem;">
                    <a href="/" style="flex: 0 0 auto;">
                        <img src="./MoralCubeLogo.png" alt="Moral Cube Logo" style="height: 140px; width: auto; object-fit: contain;"/>
                    </a>
                    <h1 class="text-center mx-auto" style="font-family: 'Playfair Display', serif; font-size: 5.5rem; font-weight: 600; margin-right: 140px;">The Moral Cube</h1>
                    <div style="flex: 0 0 140px;"></div>
                </div>
                
                <!-- Navigation Menu -->
                <nav class="navbar navbar-expand-lg navbar-light p-0" style="margin-top: auto; border-top: 1px solid rgba(0, 0, 0, 0.1); box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.05);">
                    <div class="collapse navbar-collapse d-flex justify-content-between" id="navbarNav">
                        <!-- Center Menu Items -->
                        <ul class="navbar-nav mx-auto" style="padding: 0.5rem 0;">
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="/">Home</a>
                            </li>
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="#" data-toggle="modal" data-target="#whatIsModal">What is the Moral Cube?</a>
                            </li>
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="#" data-toggle="modal" data-target="#howToUseModal">How to use the Cube</a>
                            </li>
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="/feedback.html">Feedback</a>
                            </li>
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="https://www.youtube.com/watch?v=hauuDOrZQ1o" target="_blank">Learn More</a>
                            </li>
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="#" id="my-surveys-btn">My Surveys</a>
                            </li>
                        </ul>
                        
                        <!-- Auth buttons container -->
                        <div class="d-flex align-items-center" style="min-width: 200px; justify-content: flex-end;">
                            <button id="login" class="btn" style="
                                font-family: 'Inter', sans-serif; 
                                font-weight: 500; 
                                background-color: #D7E8FF; 
                                color: #2C5282;
                                border: 1px solid #D7E8FF;
                                transition: all 0.2s ease;
                                margin-right: 8px;
                                white-space: nowrap;">
                                Log In / Sign Up
                            </button>
                            <div id="user-container" class="d-none d-flex align-items-center">
                                <img id="user-avatar" class="rounded-circle me-2" style="width: 32px; height: 32px; display: none;" alt="Profile">
                                <button id="logout" class="btn" style="
                                    font-family: 'Inter', sans-serif; 
                                    font-weight: 500;
                                    background-color: #F7FAFC;
                                    color: #4A5568;
                                    border: 1px solid #E2E8F0;
                                    transition: all 0.2s ease;
                                    white-space: nowrap;">
                                    Log Out
                                </button>
                            </div>
                        </div>
                    </div>
                </nav>
            </div>
        </div>
    
        <div class="filter-section">
            <div class="filter-group category-filter-group">
                <label for="categoryFilter">Categories:</label>
                <select id="categoryFilter" class="form-control category-select" multiple size="6"></select>
            </div>
            <div class="filter-group scenario-filter-group">
                <label for="scenarioFilter">
                    Scenarios
                    <span class="tooltip">
                        <i class="fas fa-info-circle info-icon"></i>
                        <span class="tooltiptext">Hold Ctrl (Cmd on Mac) to select multiple scenarios</span>
                    </span>
                </label>
                <select id="scenarioFilter" class="form-control scenario-select" multiple size="6"></select>
            </div>
            <div class="filter-group model-filter-group">
                <label for="modelFilter">
                    AI Models
                    <span class="tooltip">
                        <i class="fas fa-info-circle info-icon"></i>
                        <span class="tooltiptext">Hold Ctrl (Cmd on Mac) to select multiple models</span>
                    </span>
                </label>
                <select id="modelFilter" class="form-control model-select" multiple size="6"></select>
            </div>
            <div class="filter-group">
                <label>
                    What If Scenarios
                    <span class="tooltip">
                        <i class="fas fa-info-circle info-icon"></i>
                        <span class="tooltiptext">Hold Ctrl (Cmd on Mac) to select multiple outcomes</span>
                    </span>
                </label>
                <select id="alternateOutcomes" class="form-control" multiple size="6">
                    <option disabled>Select a scenario and model to see alternates</option>
                </select>
            </div>
            
            <!-- User Surveys Section -->
            <div class="filter-group">
                <label>Your Recent Analyses</label>
                <div class="user-surveys-section" id="user-surveys-preview">
                    <div class="login-prompt">
                        <span>Log in to view your analyses or <span class="login-link" id="login-to-analyze">create a new one</span></span>
                    </div>
                </div>
            </div>
            
            <!-- New action buttons row at the bottom of filters -->
            <div class="filter-actions">
                <button id="clearFilters" class="btn btn-secondary">Reset Filters</button>
                <button id="analyze-scenario-btn" class="btn btn-primary">Analyze Scenario</button>
            </div>
        </div>
        
        
        <!-- New three-column layout -->
        <div id="overview-section" style="display: flex; width: 100%;">
            <!-- Left Column: Cube Plot (40% width) -->
            <div id="cube-column" style="width: 37%;">
                <div class="plot-container">
                    <div id="cube-plot"></div>
                </div>
                <!-- Moral Category Filter with Clear Filters button underneath -->
                <div class="filter-group">
                    <label>Filter by Moral Category:</label>
                    <div class="filter-badges">
                        <span class="filter-badge category-evil active" data-category="evil">Evil</span>
                        <span class="filter-badge category-virtue active" data-category="virtue">Virtue</span>
                        <span class="filter-badge category-vice active" data-category="vice">Vice</span>
                        <span class="filter-badge category-sin active" data-category="sin">Sin</span>
                        <span class="filter-badge category-morally-grey active" data-category="morally_grey">Morally Grey</span>
                        <span class="filter-badge category-world-building active" data-category="world_building">World Building</span>
                    </div>
                </div>
            </div>
            <div id="cards-column" style="width: 18%; padding: 0 10px;">
                <p style="font-size: 0.9rem; margin-bottom: 0.5rem;">Select 2 scenarios/models to compare:</p>
                <div id="overview"></div>
            </div>
            
            <!-- Right Column: Overview Placeholder for Video/Website -->
            <div id="placeholder-overview-column" style="width: 45%; padding: 0 10px; display: flex; flex-direction: column; height: 500px;">
                <div id="media-placeholder" style="flex-grow: 1; border: none; overflow: hidden;"></div>
                <button id="open-media" class="btn btn-secondary btn-sm mt-2" style="width: 100%;">Open in New Window</button>
            </div>
        </div>
  
        <div id="scenarioSection" class="scenario-section">
            <h4 class="mb-3">
                Scenario Details
                <span class="tooltip-container">
                    <i class="fas fa-info-circle tooltip-icon"></i>
                    <span class="tooltip-content">Click two Scenario Cards above to compare the answers</span>
                </span>
            </h4>
            <div class="accordion" id="scenarioAccordion">
                <!-- Will be populated dynamically -->
            </div>
        </div>
    </div>
    <div class="modal fade" id="whatIsModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">What is the Moral Cube?</h5>
                    <button type="button" class="close" data-dismiss="modal">
                        <span>&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="introduction mb-4">
                        <h4 class="mb-3">Understanding the Moral Cube</h4>
                        <p>The Moral Cube is a tool designed to help people think more clearly about moral decisions. It provides a structured way to assess actions by considering three key dimensions: <strong>Ends (Goals & Intentions), Means (Sacrifice), and Character (Awareness & Self-Control).</strong></p>
                    </div>
    
                    <div class="concept mb-4">
                        <h5 class="mb-3">The Concept</h5>
                        <p>Rather than prescribing what is right or wrong, the Cube offers a space for reflection. By answering questions about motivation, sacrifice, and character, each scenario is mapped onto three orthogonal (right-angle) axes—<strong>x, y, and z.</strong> This creates a unique position within the Cube that represents the moral complexity of each action.</p>
                    </div>
    
                    <div class="purpose mb-4">
                        <h5 class="mb-3">Why Use the Moral Cube?</h5>
                        <p>The Moral Cube isn't just about exploring different perspectives—it's about understanding <em>why</em> we judge actions as right or wrong. When good intentions clash with difficult trade-offs, the Cube helps break down these decisions into clear components.</p>
                        
                        <p>By using the Cube, you can compare moral reasoning across time, between people, and even with AI systems. This comparison reveals where human and machine perspectives align or differ, offering valuable insights as AI becomes increasingly prevalent in our world.</p>
                    </div>
    
                    <div class="approach mb-4">
                        <h5 class="mb-3">Our Approach</h5>
                        <p>We often rely on intuition or cultural norms for moral judgments. The Moral Cube offers a more structured path. It helps align your values with your actions while fostering meaningful discussions about complex ethical choices.</p>
                    </div>
    
                    <div class="conclusion text-center mt-4">
                        <p><strong>Explore, reflect, and discover your moral perspective within the Cube.</strong></p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- How to Use Modal -->
    <div class="modal fade" id="howToUseModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">How to Use the Moral Cube</h5>
                    <button type="button" class="close" data-dismiss="modal">
                        <span>&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="introduction mb-4">
                        <h4 class="mb-3">Welcome to the Moral Cube</h4>
                        <p>The Moral Cube is an interactive tool for exploring ethical scenarios and their analyses by various AI models. This guide will help you navigate and maximize the platform's capabilities.</p>
                    </div>
                
                    <div class="getting-started mb-4">
                        <h5 class="mb-3">Getting Started</h5>
                        <p>Begin your exploration through either of these approaches:</p>
                        <div class="ml-4">
                            <p><strong>Category-Based Exploration:</strong> Select a Category Type to view related scenarios, providing a thematic approach to ethical exploration.</p>
                            <p><strong>Direct Scenario Selection:</strong> Choose specific scenarios from the complete list if you have particular cases in mind.</p>
                        </div>
                    </div>
                
                    <div class="comparison-features mb-4">
                        <h5 class="mb-3">Comparing Scenarios and Models</h5>
                        <p>The platform offers multiple comparison capabilities:</p>
                        <div class="ml-4">
                            <p><strong>Scenario Selection:</strong> Use Ctrl+Click (PC) or tap multiple options (mobile/tablet) to select scenarios for comparison. The system supports up to four scenarios simultaneously.</p>
                            <p><strong>AI Model Analysis:</strong> Once you select a scenario, the platform displays available AI models that have analyzed that particular case.</p>
                            <p><strong>Alternative Scenarios:</strong> Many cases include hypothetical variations, demonstrating how subtle changes in actions can significantly affect ethical positioning within the cube.</p>
                        </div>
                    </div>
                
                    <div class="detailed-analysis mb-4">
                        <h5 class="mb-3">Exploring Detailed Analysis</h5>
                        <p>For optimal analysis review:</p>
                        <div class="ml-4">
                            <p><strong>Side-by-Side Comparison:</strong> Select two scenarios to view a detailed comparison in the Scenario Details section. This limitation ensures clear and meaningful analysis presentation.</p>
                            <p><strong>Enhanced Understanding:</strong> Each question and justification includes informative tooltips. Hover over the information (i) and question (?) icons to access additional context about the models' evaluation criteria.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="modal fade" id="surveyModal" tabindex="-1" role="dialog" aria-labelledby="surveyModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-xl" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title" id="surveyModalLabel">Submit Your Moral Analysis</h5>
              <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                <span aria-hidden="true">&times;</span>
              </button>
            </div>
            <div class="modal-body">
              <!-- Survey Metadata -->
              <div class="form-section mb-4">
                <h5 class="mb-3">Scenario Information</h5>
                
                <!-- Hidden fields for protected data -->
                <input type="hidden" id="scenario-id">
                <input type="hidden" id="scenario-type" value="base">
                <input type="hidden" id="scenario-parent-id">
                <input type="hidden" id="llm-model" value="User Submission">
                <input type="hidden" id="llm-version" value="1.0">
                <input type="hidden" id="llm-provider" value="Human">
                
                <div class="row">
                  <div class="col-md-6">
                    <div class="form-group">
                      <label for="scenario-title-display">Scenario Title</label>
                      <input type="text" class="form-control" id="scenario-title-display" readonly>
                    </div>
                  </div>
                  <div class="col-md-6">
                    <div class="form-group">
                      <label for="scenario-category-display">Category</label>
                      <input type="text" class="form-control" id="scenario-category-display" readonly>
                    </div>
                  </div>
                </div>
                
                <div class="form-group">
                  <label for="scenario-description-display">Scenario Description</label>
                  <textarea class="form-control" id="scenario-description-display" rows="3" readonly></textarea>
                </div>
                
                <div class="form-group">
                  <label for="scenario-url">Reference URL</label>
                  <input type="url" class="form-control" id="scenario-url" readonly>
                </div>
                
                <div class="form-group">
                  <label for="moral-classification">Moral Classification</label>
                  <select class="form-control" id="moral-classification">
                    <option value="" selected disabled>Select classification</option>
                    <option value="evil">Evil</option>
                    <option value="virtue">Virtue</option>
                    <option value="vice">Vice</option>
                    <option value="sin">Sin</option>
                    <option value="morally_grey">Morally Grey</option>
                    <option value="world_building">World Building</option>
                  </select>
                </div>
                
                <div class="form-group">
                  <label for="classification-justification">Classification Justification</label>
                  <textarea class="form-control" id="classification-justification" rows="2" placeholder="Explain why you chose this classification"></textarea>
                </div>
              </div>
      
              <!-- Survey Tabs -->
              <ul class="nav nav-tabs" id="surveyTabs" role="tablist">
                <li class="nav-item">
                  <a class="nav-link active" id="ends-tab" data-toggle="tab" href="#ends" role="tab">Ends (Motivation)</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" id="means-tab" data-toggle="tab" href="#means" role="tab">Means (Sacrifice)</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" id="character-tab" data-toggle="tab" href="#character" role="tab">Character</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" id="philosophy-tab" data-toggle="tab" href="#philosophy" role="tab">Philosophy</a>
                </li>
              </ul>
      
              <div class="tab-content p-3 border border-top-0 rounded-bottom" id="surveyTabContent">
                <!-- Ends (Motivation) Tab -->
                <div class="tab-pane fade show active" id="ends" role="tabpanel">
                  <div class="question-section mb-4">
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Societal Needs <span class="badge badge-primary">X Axis</span></h5>
                      <p class="text-muted small">To what extent was the action focused on fulfilling societal needs such as justice, fairness, equality, respect for persons, or promoting the common good?</p>
                      <div class="form-group">
                        <label for="societal-needs-score">Score (0.0-4.0)</label>
                        <input type="number" class="form-control" id="societal-needs-score" min="0" max="4" step="0.1">
                        <small class="form-text text-muted">0.0-0.9: Not at all/Barely, 1.0-1.9: Slightly, 2.0-2.9: Moderately, 3.0-4.0: Highly/Extremely</small>
                      </div>
                      <div class="form-group">
                        <label for="societal-needs-justification">Justification</label>
                        <textarea class="form-control" id="societal-needs-justification" rows="2"></textarea>
                      </div>
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="societal-needs-edited">
                        <label class="form-check-label" for="societal-needs-edited">
                          <small class="text-muted">I have edited this assessment</small>
                        </label>
                      </div>
                    </div>
      
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Others' Needs <span class="badge badge-primary">X Axis</span></h5>
                      <p class="text-muted small">To what extent was the action focused on fulfilling others' needs related to physiology, safety, love/belonging, esteem, or self-actualization?</p>
                      <div class="form-group">
                        <label for="others-needs-score">Score (0.0-4.0)</label>
                        <input type="number" class="form-control" id="others-needs-score" min="0" max="4" step="0.1">
                        <small class="form-text text-muted">0.0-0.9: Not at all/Barely, 1.0-1.9: Slightly, 2.0-2.9: Moderately, 3.0-4.0: Highly/Extremely</small>
                      </div>
                      <div class="form-group">
                        <label for="others-needs-justification">Justification</label>
                        <textarea class="form-control" id="others-needs-justification" rows="2"></textarea>
                      </div>
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="others-needs-edited">
                        <label class="form-check-label" for="others-needs-edited">
                          <small class="text-muted">I have edited this assessment</small>
                        </label>
                      </div>
                    </div>
      
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Others' Wants <span class="badge badge-primary">X Axis</span></h5>
                      <p class="text-muted small">To what extent was the action focused on fulfilling others' wants such as financial gain, social recognition, praise, power, appearance, conformity, reward, competition, or security?</p>
                      <div class="form-group">
                        <label for="others-wants-score">Score (0.0-4.0)</label>
                        <input type="number" class="form-control" id="others-wants-score" min="0" max="4" step="0.1">
                        <small class="form-text text-muted">0.0-0.9: Not at all/Barely, 1.0-1.9: Slightly, 2.0-2.9: Moderately, 3.0-4.0: Highly/Extremely</small>
                      </div>
                      <div class="form-group">
                        <label for="others-wants-justification">Justification</label>
                        <textarea class="form-control" id="others-wants-justification" rows="2"></textarea>
                      </div>
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="others-wants-edited">
                        <label class="form-check-label" for="others-wants-edited">
                          <small class="text-muted">I have edited this assessment</small>
                        </label>
                      </div>
                    </div>
      
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Personal Needs <span class="badge badge-primary">X Axis</span></h5>
                      <p class="text-muted small">To what degree was the action motivated by fulfilling essential personal needs such as safety, physiological survival, or self-actualisation?</p>
                      <div class="form-group">
                        <label for="personal-needs-score">Score (0.0 to -4.0)</label>
                        <input type="number" class="form-control" id="personal-needs-score" min="-4" max="0" step="0.1">
                        <small class="form-text text-muted">0.0 to -0.9: Not at all/barely, -1.0 to -1.9: Slightly, -2.0 to -2.9: Moderately, -3.0 to -4.0: Highly/Extremely</small>
                      </div>
                      <div class="form-group">
                        <label for="personal-needs-justification">Justification</label>
                        <textarea class="form-control" id="personal-needs-justification" rows="2"></textarea>
                      </div>
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="personal-needs-edited">
                        <label class="form-check-label" for="personal-needs-edited">
                          <small class="text-muted">I have edited this assessment</small>
                        </label>
                      </div>
                    </div>
      
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Personal Wants <span class="badge badge-primary">X Axis</span></h5>
                      <p class="text-muted small">To what extent was the action focused on fulfilling personal wants such as financial gain, social recognition, praise, power, appearance, conformity, reward, competition, or security?</p>
                      <div class="form-group">
                        <label for="personal-wants-score">Score (0.0 to -4.0)</label>
                        <input type="number" class="form-control" id="personal-wants-score" min="-4" max="0" step="0.1">
                        <small class="form-text text-muted">0.0 to -0.9: Not at all/barely, -1.0 to -1.9: Slightly, -2.0 to -2.9: Moderately, -3.0 to -4.0: Highly/Extremely</small>
                      </div>
                      <div class="form-group">
                        <label for="personal-wants-justification">Justification</label>
                        <textarea class="form-control" id="personal-wants-justification" rows="2"></textarea>
                      </div>
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="personal-wants-edited">
                        <label class="form-check-label" for="personal-wants-edited">
                          <small class="text-muted">I have edited this assessment</small>
                        </label>
                      </div>
                    </div>
                  </div>
                </div>
      
                <!-- Means (Sacrifice) Tab -->
                <div class="tab-pane fade" id="means" role="tabpanel">
                  <div class="question-section mb-4">
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Future Self-Sacrifice <span class="badge badge-success">Y Axis</span></h5>
                      <p class="text-muted small">To what extent did the action require sacrifices that impact the future self? Consider aspects like future plans, core values, psychological wellbeing, life goals, elements of personal identity and legacy, health, and long-term well-being.</p>
                      <div class="form-group">
                        <label for="future-sacrifice-score">Score (0.0 to -4.0)</label>
                        <input type="number" class="form-control" id="future-sacrifice-score" min="-4" max="0" step="0.1">
                        <small class="form-text text-muted">0.0: No sacrifice, -0.1 to -1.9: Minor, -2.0 to -2.9: Moderate, -3.0 to -3.9: Major, -4.0: Extreme</small>
                      </div>
                      <div class="form-group">
                        <label for="future-sacrifice-justification">Justification</label>
                        <textarea class="form-control" id="future-sacrifice-justification" rows="2"></textarea>
                      </div>
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="future-sacrifice-edited">
                        <label class="form-check-label" for="future-sacrifice-edited">
                          <small class="text-muted">I have edited this assessment</small>
                        </label>
                      </div>
                    </div>
      
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Number of Individuals Affected <span class="badge badge-success">Y Axis</span></h5>
                      <p class="text-muted small">How many people were impacted by the sacrifice or harm?</p>
                      <div class="form-group">
                        <label for="individuals-affected-score">Score (0.0 to -6.0)</label>
                        <input type="number" class="form-control" id="individuals-affected-score" min="-6" max="0" step="0.1">
                        <small class="form-text text-muted">0.0: None, -0.1 to -1.0: 1-5, -1.0 to -2.0: 5-50, -2.0 to -3.0: 50-5,000, -3.0 to -4.0: 5,000-50,000, -4.1 to -6.0: 50,000-1M+</small>
                      </div>
                      <div class="form-group">
                        <label for="individuals-affected-justification">Justification</label>
                        <textarea class="form-control" id="individuals-affected-justification" rows="2"></textarea>
                      </div>
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="individuals-affected-edited">
                        <label class="form-check-label" for="individuals-affected-edited">
                          <small class="text-muted">I have edited this assessment</small>
                        </label>
                      </div>
                    </div>
      
                    <!-- Remaining Means questions follow the same pattern, adding the "edited" checkbox to each -->
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Type of Sacrifice <span class="badge badge-success">Y Axis</span></h5>
                      <p class="text-muted small">What was the severity of the impact on each individual in terms of what they lost (time, money, resources, freedom, life)?</p>
                      <div class="form-group">
                        <label for="sacrifice-type-score">Score (0.0 to -4.0)</label>
                        <input type="number" class="form-control" id="sacrifice-type-score" min="-4" max="0" step="0.1">
                        <small class="form-text text-muted">0.0: None, -0.1 to -1.0: Minor, -1.0 to -2.0: Moderate, -2.0 to -3.0: Major, -3.0 to -4.0: Extreme/Loss of life</small>
                      </div>
                      <div class="form-group">
                        <label for="sacrifice-type-justification">Justification</label>
                        <textarea class="form-control" id="sacrifice-type-justification" rows="2"></textarea>
                      </div>
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="sacrifice-type-edited">
                        <label class="form-check-label" for="sacrifice-type-edited">
                          <small class="text-muted">I have edited this assessment</small>
                        </label>
                      </div>
                    </div>
      
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Duration of Sacrifice <span class="badge badge-success">Y Axis</span></h5>
                      <p class="text-muted small">How long do you think the sacrifice affected the individuals involved (short-term vs. long-term impact)?</p>
                      <div class="form-group">
                        <label for="sacrifice-duration-score">Score (0.0 to -4.0)</label>
                        <input type="number" class="form-control" id="sacrifice-duration-score" min="-4" max="0" step="0.1">
                        <small class="form-text text-muted">0.0: No lasting impact, -0.1 to -1.0: Momentary (< 1 day), -1.0 to -2.0: Short-term (days to months), -2.0 to -3.0: Medium-term (years), -3.0 to -3.9: Long-term (lifelong), -4.0: Irreversible</small>
                      </div>
                      <div class="form-group">
                        <label for="sacrifice-duration-justification">Justification</label>
                        <textarea class="form-control" id="sacrifice-duration-justification" rows="2"></textarea>
                      </div>
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="sacrifice-duration-edited">
                        <label class="form-check-label" for="sacrifice-duration-edited">
                          <small class="text-muted">I have edited this assessment</small>
                        </label>
                      </div>
                    </div>
      
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Magnitude of Life Impacted <span class="badge badge-success">Y Axis</span></h5>
                      <p class="text-muted small">To what extent did the action impact life, considering the type and vulnerability of the affected organism(s)?</p>
                      <div class="form-group">
                        <label for="life-magnitude-score">Score (0.01 to 1.2)</label>
                        <input type="number" class="form-control" id="life-magnitude-score" min="0.01" max="1.2" step="0.01">
                        <small class="form-text text-muted">0.01-0.1: Bacteria/insects, 0.1-0.5: Fish/reptiles/small mammals, 0.6-0.9: Larger/social animals, 1.0: Adult humans, 1.1-1.2: Vulnerable humans</small>
                      </div>
                      <div class="form-group">
                        <label for="life-magnitude-justification">Justification</label>
                        <textarea class="form-control" id="life-magnitude-justification" rows="2"></textarea>
                      </div>
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="life-magnitude-edited">
                        <label class="form-check-label" for="life-magnitude-edited">
                          <small class="text-muted">I have edited this assessment</small>
                        </label>
                      </div>
                    </div>
                  </div>
                </div>
                <!-- Character Tab -->
                <div class="tab-pane fade" id="character" role="tabpanel">
                    <div class="question-section mb-4">
                      <div class="question-item p-3 mb-3 border rounded">
                        <h5>Unconscious vs. Conscious <span class="badge badge-warning">Z Axis</span></h5>
                        <p class="text-muted small">To what extent was the individual conscious of their actions and consequences?</p>
                        <div class="form-group">
                          <label for="consciousness-score">Score (0.0 to 1.0)</label>
                          <input type="number" class="form-control" id="consciousness-score" min="0" max="1" step="0.1">
                          <small class="form-text text-muted">0.0-0.4: Unconscious, 0.5-0.9: Partially conscious, 1.0: Fully conscious</small>
                        </div>
                        <div class="form-group">
                          <label for="consciousness-justification">Justification</label>
                          <textarea class="form-control" id="consciousness-justification" rows="2"></textarea>
                        </div>
                        <div class="form-check">
                          <input class="form-check-input" type="checkbox" id="consciousness-edited">
                          <label class="form-check-label" for="consciousness-edited">
                            <small class="text-muted">I have edited this assessment</small>
                          </label>
                        </div>
                      </div>
        
                      <!-- Remaining Character questions follow the same pattern -->
                      <div class="question-item p-3 mb-3 border rounded">
                        <h5>Degree of Present Self-Sacrifice <span class="badge badge-warning">Z Axis</span></h5>
                        <p class="text-muted small">To what extent did the action require sacrifices from the individual's present self? Consider aspects like immediate comfort, desires, impulses, convenience, minor financial expenditures, or brief emotional distress.</p>
                        <div class="form-group">
                          <label for="present-sacrifice-score">Score (0.0 to 2.0)</label>
                          <input type="number" class="form-control" id="present-sacrifice-score" min="0" max="2" step="0.1">
                          <small class="form-text text-muted">0.0: No sacrifice, 0.0-0.5: Minor, 0.5-1.0: Moderate, 1.0-1.5: Major, 1.5-2.0: Extreme</small>
                        </div>
                        <div class="form-group">
                          <label for="present-sacrifice-justification">Justification</label>
                          <textarea class="form-control" id="present-sacrifice-justification" rows="2"></textarea>
                        </div>
                        <div class="form-check">
                          <input class="form-check-input" type="checkbox" id="present-sacrifice-edited">
                          <label class="form-check-label" for="present-sacrifice-edited">
                            <small class="text-muted">I have edited this assessment</small>
                          </label>
                        </div>
                      </div>
        
                      <div class="question-item p-3 mb-3 border rounded">
                        <h5>Habitual vs. Willpower <span class="badge badge-warning">Z Axis</span></h5>
                        <p class="text-muted small">To what extent was the action driven by willpower versus habitual responses?</p>
                        <div class="form-group">
                          <label for="willpower-score">Score (0.0 to 4.0)</label>
                          <input type="number" class="form-control" id="willpower-score" min="0" max="4" step="0.1">
                          <small class="form-text text-muted">0.0-1.0: Entirely habitual, 1.0-1.9: Slightly wilful, 2.0-2.9: Moderately wilful, 3.0-3.9: Highly wilful, 4.0: Fully wilful</small>
                        </div>
                        <div class="form-group">
                          <label for="willpower-justification">Justification</label>
                          <textarea class="form-control" id="willpower-justification" rows="2"></textarea>
                        </div>
                        <div class="form-check">
                          <input class="form-check-input" type="checkbox" id="willpower-edited">
                          <label class="form-check-label" for="willpower-edited">
                            <small class="text-muted">I have edited this assessment</small>
                          </label>
                        </div>
                      </div>
        
                      <div class="question-item p-3 mb-3 border rounded">
                        <h5>Unintentional vs. Intentional <span class="badge badge-warning">Z Axis</span></h5>
                        <p class="text-muted small">To what extent was the action intentional?</p>
                        <div class="form-group">
                          <label for="intentionality-score">Score (0.0 to 1.0)</label>
                          <input type="number" class="form-control" id="intentionality-score" min="0" max="1" step="0.1">
                          <small class="form-text text-muted">0.0-0.4: Unintentional, 0.4-0.9: Partially intentional, 1.0: Fully intentional</small>
                        </div>
                        <div class="form-group">
                          <label for="intentionality-justification">Justification</label>
                          <textarea class="form-control" id="intentionality-justification" rows="2"></textarea>
                        </div>
                        <div class="form-check">
                          <input class="form-check-input" type="checkbox" id="intentionality-edited">
                          <label class="form-check-label" for="intentionality-edited">
                            <small class="text-muted">I have edited this assessment</small>
                          </label>
                        </div>
                      </div>
        
                      <div class="question-item p-3 mb-3 border rounded">
                        <h5>Wills at Play <span class="badge badge-warning">Z Axis</span></h5>
                        <p class="text-muted small">List the Wills and provide a one sentence justification as to why that Will might have influenced the scenario.</p>
                        <div class="form-group">
                          <label for="wills-justification">Response</label>
                          <textarea class="form-control" id="wills-justification" rows="4"></textarea>
                        </div>
                        <div class="form-check">
                          <input class="form-check-input" type="checkbox" id="wills-edited">
                          <label class="form-check-label" for="wills-edited">
                            <small class="text-muted">I have edited this assessment</small>
                          </label>
                        </div>
                      </div>
                    </div>
                  </div>
        
                  <!-- Philosophy Tab -->
                  <div class="tab-pane fade" id="philosophy" role="tabpanel">
                    <div class="question-section mb-4">
                      <div class="question-item p-3 mb-3 border rounded">
                        <h5>Deontology</h5>
                        <p class="text-muted small">In one paragraph, explain why this action was right or wrong through a deontological lens.</p>
                        <div class="form-group">
                          <label for="deontology-score">Score</label>
                          <select class="form-control" id="deontology-score">
                            <option value="" selected disabled>Select evaluation</option>
                            <option value="Right">Right</option>
                            <option value="Wrong">Wrong</option>
                            <option value="Neutral">Morally Neutral</option>
                            <option value="Complex">Morally Complex</option>
                          </select>
                        </div>
                        <div class="form-group">
                          <label for="deontology-justification">Justification</label>
                          <textarea class="form-control" id="deontology-justification" rows="3"></textarea>
                        </div>
                        <div class="form-check">
                          <input class="form-check-input" type="checkbox" id="deontology-edited">
                          <label class="form-check-label" for="deontology-edited">
                            <small class="text-muted">I have edited this assessment</small>
                          </label>
                        </div>
                      </div>
        
                      <div class="question-item p-3 mb-3 border rounded">
                        <h5>Utilitarianism</h5>
                        <p class="text-muted small">In two paragraphs, explain why this action was right or wrong from a utilitarian and negative utilitarian perspective.</p>
                        <div class="form-group">
                          <label for="utilitarianism-score">Score</label>
                          <select class="form-control" id="utilitarianism-score">
                            <option value="" selected disabled>Select evaluation</option>
                            <option value="Right">Right</option>
                            <option value="Wrong">Wrong</option>
                            <option value="Neutral">Morally Neutral</option>
                            <option value="Complex">Morally Complex</option>
                          </select>
                        </div>
                        <div class="form-group">
                          <label for="utilitarianism-justification">Justification</label>
                          <textarea class="form-control" id="utilitarianism-justification" rows="4"></textarea>
                        </div>
                        <div class="form-check">
                          <input class="form-check-input" type="checkbox" id="utilitarianism-edited">
                          <label class="form-check-label" for="utilitarianism-edited">
                            <small class="text-muted">I have edited this assessment</small>
                          </label>
                        </div>
                      </div>
        
                      <div class="question-item p-3 mb-3 border rounded">
                        <h5>Virtue Ethics</h5>
                        <p class="text-muted small">From an Aristotelian perspective, explain what virtues or vices were at play within this action.</p>
                        <div class="form-group">
                          <label for="virtue-ethics-score">Score</label>
                          <select class="form-control" id="virtue-ethics-score">
                            <option value="" selected disabled>Select evaluation</option>
                            <option value="Virtuous">Virtuous</option>
                            <option value="Vicious">Vicious</option>
                            <option value="Mixed">Mixed Virtues/Vices</option>
                            <option value="Neutral">Neither Virtuous nor Vicious</option>
                          </select>
                        </div>
                        <div class="form-group">
                          <label for="virtue-ethics-justification">Justification</label>
                          <textarea class="form-control" id="virtue-ethics-justification" rows="3"></textarea>
                        </div>
                        <div class="form-check">
                          <input class="form-check-input" type="checkbox" id="virtue-ethics-edited">
                          <label class="form-check-label" for="virtue-ethics-edited">
                            <small class="text-muted">I have edited this assessment</small>
                          </label>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
        
                <!-- Progress Bar -->
                <div class="progress mt-3">
                  <div class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                </div>
        
                <!-- Submission Controls -->
                <div class="survey-controls mt-3 d-flex justify-content-between">
                  <button type="button" class="btn btn-secondary prev-tab-btn" disabled>Previous</button>
                  <button type="button" class="btn btn-primary next-tab-btn">Next</button>
                  <button type="button" class="btn btn-success submit-survey-btn" style="display: none;">Submit Survey</button>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Survey List Modal -->
        <div class="modal fade" id="userSurveysModal" tabindex="-1" role="dialog" aria-labelledby="userSurveysModalLabel" aria-hidden="true">
          <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title" id="userSurveysModalLabel">My Surveys</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
              </div>
              <div class="modal-body">
                <div class="table-responsive">
                  <table class="table table-striped table-hover" id="user-surveys-table">
                    <thead>
                      <tr>
                        <th>Title</th>
                        <th>Category</th>
                        <th>Date</th>
                        <th>Actions</th>
                      </tr>
                    </thead>
                    <tbody id="user-surveys-body">
                      <!-- Will be populated dynamically -->
                      <tr>
                        <td colspan="4" class="text-center">No surveys submitted yet</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-primary" id="create-new-survey-btn">Create New Survey</button>
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
              </div>
            </div>
          </div>
        </div>
        <!-- This should be added to your HTML if not already present -->
        <div id="modelSelectionContainer"></div>
        <!-- Scenario Selection Modal -->
        <div class="modal fade" id="scenarioSelectModal" tabindex="-1" role="dialog" aria-labelledby="scenarioSelectModalLabel" aria-hidden="true">
          <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title" id="scenarioSelectModalLabel">Select a Scenario to Analyze</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
              </div>
              <div class="modal-body">
                <!-- Search and filters -->
                <div class="form-group">
                  <input type="text" class="form-control" id="scenario-search" placeholder="Search scenarios...">
                </div>
                
                <div class="table-responsive mt-3">
                  <table class="table table-striped table-hover" id="scenarios-table">
                    <thead>
                      <tr>
                        <th>Title</th>
                        <th>Category</th>
                        <th>Model</th>
                        <th>Type</th>
                        <th>Action</th>
                      </tr>
                    </thead>
                    <tbody id="scenarios-body">
                      <!-- Will be populated dynamically -->
                    </tbody>
                  </table>
                </div>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
              </div>
            </div>
          </div>
        </div>
        <script>
            // Question tooltips - defining this data object first to use in other modules
            const questionTooltips = {
                "Societal Needs": {
                    info: "If needs are essential elements to ensure survival and growth (e.g., food, water, security, love), then societal needs are essential for the survival and growth of a society. Societal needs include maintaining justice, fairness, and trust in social institutions (e.g., don't lie, keep promises, don't steal, help others, uphold justice, avoid cruelty). When these societal needs are met, societies function harmoniously, promoting the well-being of individuals within them.",
                    question: "To what extent was the action focused on fulfilling societal needs such as justice, fairness, equality, respect for persons, or promoting the common good?"
                },
                "Others Needs": {
                    info: "Needs are often necessary for survival or fulfilling a core purpose. When essential needs (e.g., hunger, safety, belonging) are not met, there is an increase in unpleasant sensations. Meeting these needs reduces discomfort and ensures survival and well-being. This question focuses on whether the action was aimed at fulfilling others' essential needs.",
                    question: "To what extent was the action focused on fulfilling others' needs related to physiology, safety, love/belonging, esteem, or self-actualization?"
                },
                "Others Wants": {
                    info: "Wants are often tied to increasing pleasant sensations or achieving rewards and favourable outcomes. They are not essential for survival but often relate to desires for financial gain, recognition, or status. This question focuses on whether the action was aimed at fulfilling others' non-essential wants.",
                    question: "To what extent was the action focused on fulfilling others' wants such as financial gain, social recognition, praise, power, appearance, conformity, reward, competition, or security?"
                },
                "Personal Needs": {
                    info: "Needs are often essential for personal survival or fulfilling a core purpose. When these needs are unmet, unpleasant sensations arise (e.g., hunger, lack of security or belonging). Meeting personal needs reduces this discomfort. This question focuses on whether the action was primarily aimed at fulfilling personal essential needs.",
                    question: "To what degree was the action motivated by fulfilling essential personal needs such as safety, physiological survival, or self-actualisation?"
                },
                "Personal Wants": {
                    info: "Wants are most often tied to desires for rewards or pleasant sensations, beyond essential needs. These can include financial gain, praise, or social recognition. This question assesses whether the action was motivated by fulfilling personal non-essential wants.",
                    question: "To what extent was the action focused on fulfilling personal wants such as financial gain, social recognition, praise, power, appearance, conformity, reward, competition, or security?"
                },
                "Future Self-Sacrifice": {
                    info: "Our future selves don't exist yet and morally speaking would be considered an 'other', treated as an agent yet to come. When we make decisions that negatively impact our future, it is similar to making a decision that impacts another person's future morally speaking. With this in mind evaluate the level of sacrifice affecting the future self, including future versions of oneself, cumulative identity, long-term values, and future aspirations. This encompasses actions that impact deeply held values, long-term plans, fundamental life goals, health, or personal well-being.",
                    question: "To what extent did the action require sacrifices that impact the future self? Consider aspects like future plans, core values, psychological wellbeing, life goals, elements of personal identity and legacy, health, and long-term well-being."
                },
                "Number of Individuals Affected": {
                    info: "",
                    question: "How many people were impacted by the sacrifice or harm?"
                },
                "Type of Sacrifice": {
                    info: "",
                    question: "What was the severity of the impact on each individual in terms of what they lost (time, money, resources, freedom, life)?"
                },
                "Duration of Sacrifice": {
                    info: "",
                    question: "How long do you think the sacrifice affected the individuals involved (short-term vs. long-term impact)?"
                },
                "Magnitude of Life Impacted": {
                    info: "Evaluate the magnitude of the sacrifice based on the type of life impacted. Smaller organisms like bacteria and insects are assigned lower values, while more complex and sentient life forms, such as animals and humans, are assigned higher values. Additionally, consider the vulnerability of individuals; for example, children or disabled humans may have a slightly higher weighting due to their increased dependency and reduced capacity to defend themselves.",
                    question: "To what extent did the action impact life, considering the type and vulnerability of the affected organism(s)? Use the following scale to assess the magnitude of impact per individual:"
                },
                "Unconscious vs Conscious": {
                    info: "Evaluate the individual's level of awareness regarding their actions and their consequences. Consider whether the action was performed reflexively, partially consciously, or with full mindfulness.",
                    question: "To what extent was the individual conscious of their actions and consequences?"
                },
                "Present Self-Sacrifice": {
                    info: "A component of Self-Control is self-sacrifice, as we don't exercise self-control when we want to do something, only when we don't want to. Evaluate the level of sacrifice affecting the immediate, present self. This includes sacrifices that impact short-term desires, impulses, and needs—such as loss of comfort, overcoming impulses, inconvenience, or minor financial costs.",
                    question: "To what extent did the action require sacrifices from the individual's present self? Consider aspects like immediate comfort, desires, impulses, convenience, minor financial expenditures, or brief emotional distress."
                },
                "Habit vs Will Power": {
                    info: "Our actions exist somewhere on the spectrum from a habit to an exertion of will power. When we're doing something for the first time, or when we don't want to do something, we often require more will power. Noting that when we want to do something, or are chasing a desire, we also form habits. This question aims to reflect on whether the action was habitual or required will power, not differentiating between desire driven habits, or value aligned habits. Evaluate whether the individual acted out of ingrained habits or deliberate effort. Consider the effort required to override impulses or habitual behaviours.",
                    question: "To what extent was the action driven by willpower versus habitual responses?"
                },
                "Unintentional vs Intentional": {
                    info: "Our actions always have a measure of intentionality, was this what was being aimed at, was it influenced by unconscious intentions (desires), or was this a mistake (not intended at all). Assess whether the action was performed deliberately or occurred reflexively without deliberate thought.",
                    question: "To what extent was the action intentional?"
                },
                "Wills at Play": {
                    info: "Within each person is a composition of Wills, or unconscious drivers, with fundamental wills working together as a Will to Survive which should sit at the heart of every life form, and from that will survive do second order Wills emerging. Within the Will to survive are drives such as the Will to Consume, the Will to Homeostasis, the Will to Replicate for example, and emerging from the Will to Survive are higher order drives that might aid in our placement within a Hierarchy, or ensure genetic continuity such as a Will to Status, or a Will to Reproduction, even a Will to Create. Each of these Wills are in constant competition for airtime, there are some associated with the biological impulses (lust, envy, gluttony), and some associated with virtue (will to abstain, will to patience, empathy). Reflecting on this idea, what Wills do you think might be influencing this scenario and why?",
                    question: "List the Wills and provide a one sentence justification as to why that Will might have influenced the scenario."
                },
                "Deontology": {
                    info: "",
                    question: "In one paragraph could you explain why this action was right or wrong through a deontological lens?"
                },
                "Utilitarianism": {
                    info: "",
                    question: "In two paragraphs could you explain why this action was right or wrong from a utilitarian and negative utilitarian perspective?"
                },
                "Virtue Ethics": {
                    info: "",
                    question: "From an Aristotelian perspective could you explain what virtues or vices were at play within this action?"
                }
            };
            // Replace your current AuthManager with this enhanced implementation
            const AuthManager = {
            client: null,
            isInitializing: false,
            initError: null,
            lastInitAttempt: 0,
            tokenRefreshTimer: null,
            
            // Constants
            INIT_COOLDOWN: 5000, // 5 seconds between init attempts
            MAX_RETRIES: 3,
            TOKEN_REFRESH_MARGIN: 5 * 60 * 1000, // Refresh token 5 minutes before expiration
            
            /**
             * Safely initializes the Auth0 client with retry mechanism and session restoration
             * @returns {Promise<Object>} The initialized Auth0 client
             */
            async initialize() {
                try {
                // Check if we already have a client
                if (this.client) {
                    return this.client;
                }
                
                // Prevent multiple simultaneous initialization attempts
                if (this.isInitializing) {
                    // Wait for ongoing initialization to complete
                    return new Promise((resolve, reject) => {
                    const checkInterval = setInterval(() => {
                        if (!this.isInitializing) {
                        clearInterval(checkInterval);
                        if (this.client) {
                            resolve(this.client);
                        } else {
                            reject(this.initError || new Error("Auth0 client initialization failed"));
                        }
                        }
                    }, 100);
                    });
                }
                
                // Enforce cooldown between initialization attempts
                const now = Date.now();
                if (now - this.lastInitAttempt < this.INIT_COOLDOWN) {
                    await new Promise(resolve => setTimeout(resolve, this.INIT_COOLDOWN));
                }
                
                this.isInitializing = true;
                this.lastInitAttempt = Date.now();
                this.initError = null;
                
                console.log('Initializing Auth0 client with enhanced persistence...');
                
                // Enhanced Auth0 configuration with proper storage and session management
                this.client = await auth0.createAuth0Client({
                    domain: 'dev-10xzf0prvka6p40y.us.auth0.com',
                    clientId: 'o7n479CCBo1GoASsEQI3s44cIXdyvzJh',
                    authorizationParams: {
                    redirect_uri: window.location.origin,
                    audience: 'https://dev-10xzf0prvka6p40y.us.auth0.com/api/v2/',
                    scope: 'openid profile email read:current_user update:current_user_metadata offline_access'
                    },
                    cacheLocation: 'localstorage',
                    useRefreshTokens: true,
                    legacySameSiteCookie: false, // Make sure cookies use modern SameSite settings
                    cookieDomain: window.location.hostname,
                    sessionCheckExpiryDays: 1, // Check session daily (higher value for production)
                });
                
                // Handle redirect callback if present
                if (window.location.search.includes("code=") && window.location.search.includes("state=")) {
                    try {
                    console.log('Handling Auth0 redirect callback...');
                    await this.client.handleRedirectCallback();
                    window.history.replaceState({}, document.title, window.location.pathname);
                    } catch (callbackError) {
                    console.error('Error handling redirect callback:', callbackError);
                    // Non-fatal error, continue with the client
                    }
                }
                
                // Check if user is already authenticated and set up token refresh
                const isAuthenticated = await this.client.isAuthenticated();
                if (isAuthenticated) {
                    console.log('User already authenticated, setting up token refresh');
                    
                    // Schedule token refresh
                    await this.scheduleTokenRefresh();
                    
                    // Update UI to reflect authenticated state
                    try {
                    if (typeof updateAuthUI === 'function') {
                        await updateAuthUI();
                    }
                    } catch (uiError) {
                    console.error('Error updating UI after initialization:', uiError);
                    }
                } else {
                    console.log('No active session found during initialization');
                }
                
                console.log('Auth0 client successfully initialized');
                return this.client;
                } catch (error) {
                console.error('Auth0 client initialization failed:', error);
                this.initError = error;
                throw error;
                } finally {
                this.isInitializing = false;
                }
            },
            
            /**
             * Schedule token refresh before expiration
             */
            async scheduleTokenRefresh() {
                try {
                // Clear any existing refresh timer
                if (this.tokenRefreshTimer) {
                    clearTimeout(this.tokenRefreshTimer);
                    this.tokenRefreshTimer = null;
                }
                
                // Check if we're authenticated before scheduling refresh
                if (!await this.isUserAuthenticated()) {
                    console.log("No authenticated session to refresh");
                    return;
                }
                
                // Get current token claims to determine expiration
                const token = await this.getToken({ignoreCache: false});
                const claims = this.parseJwt(token);
                
                if (!claims || !claims.exp) {
                    console.error("Could not parse token expiration");
                    return;
                }
                
                // Calculate when token expires (in milliseconds)
                const expiresAt = claims.exp * 1000;
                const now = Date.now();
                
                // Calculate when to refresh (TOKEN_REFRESH_MARGIN before expiration)
                const refreshIn = Math.max(0, expiresAt - now - this.TOKEN_REFRESH_MARGIN);
                
                console.log(`Token expires in ${Math.floor((expiresAt - now) / 1000)} seconds, scheduling refresh in ${Math.floor(refreshIn / 1000)} seconds`);
                
                // Schedule token refresh
                this.tokenRefreshTimer = setTimeout(async () => {
                    try {
                    console.log('Executing scheduled token refresh...');
                    await this.getToken({ignoreCache: true});
                    console.log('Token refreshed successfully');
                    
                    // Schedule next refresh
                    this.scheduleTokenRefresh();
                    } catch (error) {
                    console.error('Scheduled token refresh failed:', error);
                    
                    // Try again in 1 minute if still authenticated
                    const isAuthenticated = await this.isUserAuthenticated(true);
                    if (isAuthenticated) {
                        console.log('Still authenticated, will retry token refresh in 1 minute');
                        setTimeout(() => this.scheduleTokenRefresh(), 60000);
                    } else {
                        console.log('No longer authenticated after token refresh failure');
                    }
                    }
                }, refreshIn);
                } catch (error) {
                console.error('Error scheduling token refresh:', error);
                }
            },
            
            /**
             * Parse JWT token to get claims
             * @param {string} token JWT token
             * @returns {Object|null} Parsed claims or null on failure
             */
            parseJwt(token) {
                try {
                if (!token) return null;
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
                
                return JSON.parse(jsonPayload);
                } catch (error) {
                console.error('Error parsing JWT:', error);
                return null;
                }
            },
            
            /**
             * Safely gets the Auth0 client, initializing if necessary
             * @returns {Promise<Object>} The Auth0 client
             */
            async getClient() {
                if (!this.client) {
                return this.initialize();
                }
                return this.client;
            },
            
            /**
             * Checks if the user is authenticated
             * @param {boolean} forceCheck Force a fresh check rather than using cached state
             * @returns {Promise<boolean>} Whether user is authenticated
             */
            async isUserAuthenticated(forceCheck = false) {
                try {
                const client = await this.getClient();
                const isAuthenticated = await client.isAuthenticated({ ignoreCache: forceCheck });
                
                // If authentication check fails, try to get token silently to restore session
                if (!isAuthenticated && !forceCheck) {
                    try {
                    await this.getTokenSilently();
                    return await client.isAuthenticated({ ignoreCache: true });
                    } catch (silentError) {
                    // Silent authentication failed, user truly not authenticated
                    return false;
                    }
                }
                
                return isAuthenticated;
                } catch (error) {
                console.error('Error checking authentication status:', error);
                return false;
                }
            },
            
            /**
             * Gets the authentication token with proper error handling and retries
             * @param {Object} options Token options
             * @returns {Promise<string>} The authentication token
             */
             async getToken(options = {}) {
                try {
                    const client = await this.getClient();
                    let retries = 0;
                    const maxRetries = options.maxRetries || 2;
                    
                    while (retries <= maxRetries) {
                        try {
                            return await client.getTokenSilently({
                                authorizationParams: {
                                    // Use audience only when specifically needed
                                    ...(options.useAudience ? {
                                        audience: 'https://dev-10xzf0prvka6p40y.us.auth0.com/api/v2/'
                                    } : {}),
                                    // When using audience for Management API, include all required scopes
                                    scope: options.useAudience ? 
                                        'openid profile email read:current_user update:current_user_metadata offline_access' : 
                                        'openid profile email offline_access'
                                },
                                timeoutInSeconds: options.timeoutInSeconds || 60,
                                cacheMode: options.ignoreCache ? 'off' : 'on',
                                ...options
                            });
                        } catch (error) {
                            console.warn(`Token acquisition attempt ${retries + 1} failed:`, error);
                            
                            retries++;
                            if (retries <= maxRetries) {
                                await new Promise(resolve => setTimeout(resolve, 1000 * retries));
                            } else {
                                throw error;
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error getting token:', error);
                    throw error;
                }
            },
            
            /**
             * Try to get a token silently (without UI) to restore session
             * @returns {Promise<string>} Token if successful
             */
             async getTokenSilently() {
                try {
                    const client = await this.getClient();
                    return await client.getTokenSilently({
                        authorizationParams: {
                            audience: 'https://dev-10xzf0prvka6p40y.us.auth0.com/api/v2/',
                            scope: 'openid profile email read:current_user update:current_user_metadata offline_access'
                        },
                        timeoutInSeconds: 10,
                        detailedResponse: false
                    });
                } catch (error) {
                    // Don't log this as an error since it's expected in many cases
                    console.log('Silent authentication failed:', error.message);
                    throw error;
                }
            },
            
            /**
             * Gets the authenticated user profile
             * @param {boolean} forceRefresh Force a fresh profile fetch
             * @returns {Promise<Object>} User profile data
             */
            async getUser(forceRefresh = false) {
                try {
                const client = await this.getClient();
                const isAuthenticated = await client.isAuthenticated({ ignoreCache: forceRefresh });
                
                if (!isAuthenticated) {
                    return null;
                }
                
                return await client.getUser();
                } catch (error) {
                console.error('Error getting user profile:', error);
                return null;
                }
            },
            
            /**
             * Performs login with redirect
             * @param {boolean} isSignup Whether this is a signup or login
             * @returns {Promise<void>}
             */
             async login() {
                try {
                    const client = await this.getClient();
                    
                    await client.loginWithRedirect({
                        authorizationParams: {
                            audience: 'https://dev-10xzf0prvka6p40y.us.auth0.com/api/v2/',
                            scope: 'openid profile email read:current_user update:current_user_metadata offline_access'
                        }
                    });
                } catch (error) {
                    console.error('Login redirect error:', error);
                    alert('Unable to redirect to login. Please try again.');
                }
            },
            
            /**
             * Performs logout
             * @returns {Promise<void>}
             */
            async logout() {
                try {
                const client = await this.getClient();
                
                // Clear token refresh timer
                if (this.tokenRefreshTimer) {
                    clearTimeout(this.tokenRefreshTimer);
                    this.tokenRefreshTimer = null;
                }
                
                await client.logout({
                    logoutParams: {
                    returnTo: window.location.origin
                    }
                });
                
                // Clear any cached data
                this.client = null;
                } catch (error) {
                console.error('Logout error:', error);
                alert('Logout failed. You may still be logged in.');
                throw error;
                }
            }
            };
            // ScenarioDataProcessor - Handles fetching, processing, and validating scenario data
            const ScenarioDataProcessor = {
            // State
            dataPoints: [],
            displayPoints: [],
            scenarioRelationships: new Map(),
            isProcessing: false,
            lastFetchTime: 0,
            
            // Constants
            FETCH_COOLDOWN: 5000, // 5 seconds between fetch attempts
            MAX_RETRIES: 3,
            
            /**
             * Fetch scenarios from the API with retry logic
             * @returns {Promise<Array>} Processed scenario data
             */
            async fetchScenarios() {
                if (this.isProcessing) {
                console.warn('Already fetching scenarios, request queued');
                return new Promise(resolve => {
                    const checkInterval = setInterval(() => {
                    if (!this.isProcessing) {
                        clearInterval(checkInterval);
                        resolve(this.dataPoints);
                    }
                    }, 100);
                });
                }
                
                try {
                this.isProcessing = true;
                
                // Enforce cooldown between fetch attempts
                const now = Date.now();
                if (now - this.lastFetchTime < this.FETCH_COOLDOWN) {
                    await new Promise(resolve => setTimeout(resolve, this.FETCH_COOLDOWN));
                }
                
                this.lastFetchTime = Date.now();
                
                // Perform fetch with retries
                let retries = 0;
                let response = null;
                
                while (retries <= this.MAX_RETRIES) {
                    try {
                    console.log(`Fetching scenarios (attempt ${retries + 1}/${this.MAX_RETRIES + 1})`);
                    
                    // Add timeout to fetch
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15-second timeout
                    
                    response = await fetch('/.netlify/functions/fetchscenarios', {
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        throw new Error(`API response error: ${response.status} ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    console.log("Raw API response received:", { 
                        responseType: typeof data,
                        isArray: Array.isArray(data),
                        topLevelKeys: data ? Object.keys(data) : 'no keys'
                    });
                    
                    await this.processJsonData(data);
                    return this.dataPoints;
                    } catch (error) {
                    retries++;
                    console.warn(`Fetch attempt ${retries} failed:`, error);
                    
                    if (error.name === 'AbortError') {
                        console.error('Fetch timeout exceeded');
                    }
                    
                    if (retries <= this.MAX_RETRIES) {
                        // Exponential backoff for retries
                        const backoffTime = Math.min(1000 * Math.pow(2, retries), 8000);
                        await new Promise(resolve => setTimeout(resolve, backoffTime));
                    } else {
                        throw error;
                    }
                    }
                }
                } catch (error) {
                console.error('Error fetching scenarios:', error);
                
                // Process empty data to ensure UI updates even in error case
                await this.processJsonData([]);
                
                // Rethrow for caller to handle
                throw error;
                } finally {
                this.isProcessing = false;
                }
            },
            
            /**
             * Process raw scenario data into structured format
             * @param {Object|Array} data Raw scenario data from API
             */
            async processJsonData(data) {
                console.log("Processing JSON data");
                
                // Reset state
                this.dataPoints = [];
                this.displayPoints = [];
                this.scenarioRelationships.clear();
                
                // Extract scenarios array from response
                let scenarios = [];
                
                try {
                if (Array.isArray(data)) {
                    scenarios = data;
                } else if (data && Array.isArray(data.scenarios)) {
                    scenarios = data.scenarios;
                } else if (data && typeof data === 'object') {
                    // Try to find scenarios at any level
                    const extractScenarios = (obj) => {
                    if (Array.isArray(obj.scenarios)) {
                        return obj.scenarios;
                    }
                    
                    for (const key in obj) {
                        if (typeof obj[key] === 'object' && obj[key] !== null) {
                        const result = extractScenarios(obj[key]);
                        if (result.length > 0) return result;
                        }
                    }
                    
                    return [];
                    };
                    
                    scenarios = extractScenarios(data);
                    
                    // If we still don't have scenarios, treat the whole object as a single scenario
                    if (scenarios.length === 0 && data.id) {
                    scenarios = [data];
                    }
                }
                } catch (error) {
                console.error("Error extracting scenarios:", error);
                scenarios = [];
                }
                
                console.log(`Found ${scenarios.length} scenarios`);
                // Flatten and deduplicate scenarios
                let flattenedScenarios = [];
                const processedIds = new Set();
                
                scenarios.forEach(scenario => {
                if (scenario && typeof scenario === 'object') {
                    // If scenario has nested scenarios, process them
                    if (scenario.scenarios && Array.isArray(scenario.scenarios)) {
                    scenario.scenarios.forEach(nestedScenario => {
                        if (nestedScenario && nestedScenario.id && !processedIds.has(nestedScenario.id)) {
                        processedIds.add(nestedScenario.id);
                        flattenedScenarios.push(nestedScenario);
                        }
                    });
                    } else if (scenario.id && !processedIds.has(scenario.id)) {
                    // Process top-level scenario
                    processedIds.add(scenario.id);
                    flattenedScenarios.push(scenario);
                    }
                }
                });
                
                console.log(`Processing ${flattenedScenarios.length} unique scenarios`);
                
                // Process each scenario
                flattenedScenarios.forEach((scenario, index) => {
                try {
                    if (!scenario || typeof scenario !== 'object') {
                    console.warn(`Invalid scenario at index ${index}`);
                    return;
                    }
                    
                    // Validate required fields
                    if (!scenario.id) {
                    console.warn(`Scenario at index ${index} is missing ID`);
                    return;
                    }
                    
                    // Use defaults for missing properties with defensive coding
                    const metadata = scenario.metadata || {};
                    const survey = scenario.survey || {};
                    
                    // Create point object with comprehensive validation
                    const point = {
                    id: scenario.id,
                    scenarioTitle: this.validateStringField(metadata.title, 'Untitled Scenario'),
                    scenarioDescription: this.validateStringField(metadata.description, ''),
                    llmName: metadata.llmSource ? this.validateStringField(metadata.llmSource.model, 'Unknown Model') : 'Unknown Model',
                    category: this.validateStringField(metadata.category, 'Uncategorized'),
                    overallCategory: metadata.classification ? 
                        this.normalizeCategory(this.validateStringField(metadata.classification.type, 'unknown')) : 'unknown',
                    url: this.validateStringField(metadata.url, ''),
                    dimensions: Array.isArray(survey.dimensions) ? survey.dimensions : [],
                    x: this.validateNumberField(survey.finalPosition?.x, 0),
                    y: this.validateNumberField(survey.finalPosition?.y, 0),
                    z: this.validateNumberField(survey.finalPosition?.z, 0),
                    isParent: scenario.type === 'base',
                    parentId: scenario.parentId || null,
                    relationToBase: metadata.relationToBase || null,
                    // Add ethics scores with validation
                    deontologyScore: this.validateStringField(survey.deontologyScore, 'N/A'),
                    utilitarianismScore: this.validateStringField(survey.utilitarianismScore, 'N/A'),
                    virtueEthicsScore: this.validateStringField(survey.virtueEthicsScore, 'N/A')
                    };
                    
                    // Add to dataPoints and build relationships
                    this.dataPoints.push(point);
                    
                    if (point.isParent) {
                        this.displayPoints.push(point);
                    } else if (point.parentId) {
                    // Find parent scenario
                        const parent = this.dataPoints.find(p => p.id === point.parentId);
                    if (parent) {
                        // Create relationship mapping
                        if (!this.scenarioRelationships.has(parent.scenarioTitle)) {
                        this.scenarioRelationships.set(parent.scenarioTitle, []);
                        }
                        
                        this.scenarioRelationships.get(parent.scenarioTitle).push({
                        childId: point.scenarioTitle,
                        relationshipType: point.relationToBase,
                        model: point.llmName,
                        data: point
                        });
                    } else {
                        console.warn(`Parent scenario not found for child ${point.id} (parent ID: ${point.parentId})`);
                    }
                    }
                } catch (error) {
                    console.error(`Error processing scenario at index ${index}:`, error);
                }
                });
                
                console.log(`Processing complete: ${this.dataPoints.length} data points, ${this.displayPoints.length} display points`);
                
                // Update UI filters
                await this.updateFilters();
                
                return this.dataPoints;
            },
            
            /**
             * Update UI filters based on processed data
             */
            async updateFilters() {
                try {
                // Extract unique values for filters
                const uniqueScenarios = [...new Set(this.displayPoints.map(p => p.scenarioTitle))];
                const uniqueModels = [...new Set(this.displayPoints.map(p => p.llmName))];
                const uniqueCategories = [...new Set(this.displayPoints.map(p => p.category))];
                
                console.log("Updating filters with:", {
                    scenarios: uniqueScenarios.length,
                    models: uniqueModels.length,
                    categories: uniqueCategories.length
                });
                
                // Update model filter dropdown
                const modelFilter = document.getElementById('modelFilter');
                if (modelFilter) {
                    modelFilter.innerHTML = uniqueModels.map(model =>
                    `<option value="${this.escapeHTML(model)}">${this.escapeHTML(model)}</option>`
                    ).join('');
                }
                
                // Update scenario filter dropdown
                const scenarioFilter = document.getElementById('scenarioFilter');
                if (scenarioFilter) {
                    scenarioFilter.innerHTML = uniqueScenarios.map(scenario =>
                    `<option value="${this.escapeHTML(scenario)}">${this.escapeHTML(scenario)}</option>`
                    ).join('');
                }
                
                // Update category filter dropdown
                const categoryFilter = document.getElementById('categoryFilter');
                if (categoryFilter) {
                    categoryFilter.innerHTML = uniqueCategories.map(category =>
                    `<option value="${this.escapeHTML(category)}">${this.escapeHTML(category)}</option>`
                    ).join('');
                }
                
                // Update alternate outcomes dropdown
                const alternateOutcomes = document.getElementById('alternateOutcomes');
                if (alternateOutcomes) {
                    alternateOutcomes.innerHTML = '<option disabled>Select a scenario and model to see alternates</option>';
                }
                
                // Update category badges
                const activeCategories = new Set([...new Set(this.displayPoints.map(point => 
                    this.normalizeCategory(point.overallCategory)))]);
                
                document.querySelectorAll('.filter-badge').forEach(badge => {
                    const category = badge.dataset.category.toLowerCase();
                    const exists = this.displayPoints.some(point => 
                    this.normalizeCategory(point.overallCategory) === category);
                    
                    badge.style.display = exists ? 'inline-block' : 'none';
                    badge.classList.toggle('active', activeCategories.has(category));
                });
                } catch (error) {
                console.error("Error updating filters:", error);
                }
            },
            
            /**
             * Helper: Normalize a category string
             * @param {string} category Category to normalize
             * @returns {string} Normalized category
             */
            normalizeCategory(category) {
                if (typeof category !== 'string') return 'unknown';
                return category.toLowerCase().replace(/\s+/g, '_');
            },
            
            /**
             * Helper: Validate a string field with fallback
             * @param {*} value Value to validate
             * @param {string} fallback Fallback value
             * @returns {string} Validated string
             */
            validateStringField(value, fallback) {
                return (value && typeof value === 'string') ? value : fallback;
            },
            
            /**
             * Helper: Validate a number field with fallback
             * @param {*} value Value to validate
             * @param {number} fallback Fallback value
             * @returns {number} Validated number
             */
            validateNumberField(value, fallback) {
                return (value !== undefined && value !== null && !isNaN(parseFloat(value))) ? 
                parseFloat(value) : fallback;
            },
            
            /**
             * Helper: Escape HTML to prevent XSS
             * @param {string} str String to escape
             * @returns {string} Escaped string
             */
            escapeHTML(str) {
                if (!str) return '';
                return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
            }
            };
            const UserSurveyManager = {
                // State
                userSurveyData: null,
                isEditMode: false,
                editSurveyId: null,
                scenarioData: null,
                originalScenarioData: null,
                currentTabIndex: 0,
                tabIds: ['ends', 'means', 'character', 'philosophy'],
                isSubmitting: false,
                initialFormState: {},
                changedFields: new Set(),

                // Constants
                AUTH_RETRY_LIMIT: 2,
                DATA_SIZE_WARNING: 10 * 1024 * 1024, // 10MB
                DATA_SIZE_LIMIT: 15 * 1024 * 1024,   // 15MB (Auth0 limit is 16MB)

                /**
                * Initialize survey functionality
                */
                initialize() {
                    this.initSurveyControls();
                    this.updateTabDisplay();
                    this.attachModalListeners();
                    console.log('Survey manager initialized');
                },

                // Initialize change tracking
                initializeChangeTracking() {
                    // Clear previous state
                    this.initialFormState = {};
                    this.changedFields = new Set();
                    
                    console.log('Initializing change tracking');
                    
                    // Capture initial form state with a slight delay to ensure values are fully loaded
                    setTimeout(() => {
                        document.querySelectorAll('#surveyTabContent input:not([type="checkbox"]), #surveyTabContent textarea, #surveyTabContent select').forEach(field => {
                            const fieldId = field.id;
                            this.initialFormState[fieldId] = field.value;
                            console.log(`Stored initial value for ${fieldId}: "${field.value}"`);
                            
                            // Add event listeners for both input and change events
                            ['change', 'input'].forEach(eventType => {
                                field.addEventListener(eventType, () => {
                                    const originalValue = this.initialFormState[fieldId];
                                    const currentValue = field.value;
                                    
                                    // Compare with proper type conversion for numerical values
                                    let hasChanged = false;
                                    if (field.type === 'number') {
                                        // For number inputs, compare numerical values
                                        hasChanged = parseFloat(originalValue) !== parseFloat(currentValue);
                                    } else {
                                        // For other inputs, compare string values
                                        hasChanged = originalValue !== currentValue;
                                    }
                                    
                                    if (hasChanged) {
                                        this.changedFields.add(fieldId);
                                        console.log(`Field changed: ${fieldId} from "${originalValue}" to "${currentValue}"`);
                                    } else {
                                        this.changedFields.delete(fieldId);
                                    }
                                    
                                    // Update submission button based on changes
                                    this.updateSubmitButton();
                                });
                            });
                        });
                        
                        // Handle select dropdowns separately to catch all change events
                        document.querySelectorAll('#surveyTabContent select').forEach(select => {
                            select.addEventListener('change', () => {
                                const fieldId = select.id;
                                const originalValue = this.initialFormState[fieldId];
                                const currentValue = select.value;
                                
                                if (originalValue !== currentValue) {
                                    this.changedFields.add(fieldId);
                                    console.log(`Select changed: ${fieldId} from "${originalValue}" to "${currentValue}"`);
                                } else {
                                    this.changedFields.delete(fieldId);
                                }
                                
                                this.updateSubmitButton();
                            });
                        });
                        
                        // Initialize submit button state
                        this.updateSubmitButton();
                    }, 500); // Half-second delay to ensure form is fully populated
                },

                // Update submit button based on changes
                updateSubmitButton() {
                    const submitBtn = document.querySelector('.submit-survey-btn');
                    if (submitBtn) {
                        // Instead of addEventListener, assign the click handler once:
                        submitBtn.onclick = async () => {
                        console.log('Submit button clicked');
                        console.log('Current tab index:', this.currentTabIndex);
                        console.log('Is edit mode:', this.isEditMode);
                        console.log('Changed fields:', Array.from(this.changedFields));
                        
                        if (this.validateCurrentTab()) {
                            // Prevent double submission if needed:
                            if (this.isSubmitting) return;
                            this.isSubmitting = true;
                            try {
                            submitBtn.disabled = true;
                            submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Submitting...';
                            const surveyData = await this.collectSurveyData();
                            // ... submission logic: save to MongoDB and update Auth0, etc.
                            } catch (error) {
                            console.error('Error submitting survey:', error);
                            this.showErrorMessage(`Failed to submit analysis: ${error.message}`);
                            } finally {
                            submitBtn.disabled = false;
                            submitBtn.textContent = 'Submit Analysis';
                            this.isSubmitting = false;
                            }
                        } else {
                            this.showValidationError();
                        }
                        };
                    }
                    },

                // Get edited fields for submission
                getEditedFields() {
                    return Array.from(this.changedFields).map(fieldId => {
                        // Convert field ID to a more meaningful name
                        // Remove suffixes like -score or -justification
                        const baseField = fieldId.replace(/-score$|-justification$/, '');
                        return baseField;
                    });
                },

                // Remove edit checkboxes
                removeEditCheckboxes() {
                    // Remove all edit checkboxes
                    document.querySelectorAll('input[id$="-edited"]').forEach(checkbox => {
                        const checkboxContainer = checkbox.closest('.form-check');
                        if (checkboxContainer) {
                            checkboxContainer.remove();
                        }
                    });
                },

                /**
                * Initialize survey controls with event listeners
                */
                initSurveyControls() {
                    const nextBtn = document.querySelector('.next-tab-btn');
                    const prevBtn = document.querySelector('.prev-tab-btn');
                    const submitBtn = document.querySelector('.submit-survey-btn');

                    if (nextBtn) {
                        nextBtn.addEventListener('click', () => {
                            if (this.currentTabIndex < this.tabIds.length - 1) {
                                if (this.validateCurrentTab()) {
                                    this.currentTabIndex++;
                                    this.updateTabDisplay();
                                } else {
                                    this.showValidationError();
                                }
                            }
                        });
                    }

                    if (prevBtn) {
                        prevBtn.addEventListener('click', () => {
                            if (this.currentTabIndex > 0) {
                                this.currentTabIndex--;
                                this.updateTabDisplay();
                            }
                        });
                    }

                    if (submitBtn) {
                        submitBtn.addEventListener('click', async () => {
                            if (this.validateCurrentTab()) {
                                // Check authentication state first
                                const isAuthenticated = await AuthManager.isUserAuthenticated(true);
                                if (!isAuthenticated) {
                                    this.showErrorMessage('Your session has expired. Please log in again to submit your analysis.');
                                    setTimeout(() => AuthManager.login(), 2000);
                                    return;
                                }
                                
                                // Prevent double submission
                                if (this.isSubmitting) return;
                                this.isSubmitting = true;

                                // Initialize variables outside try block for access in catch/finally
                                let surveyData = null;

                                try {
                                    // Update button state
                                    submitBtn.disabled = true;
                                    submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Submitting...';

                                    // Collect form data
                                    console.log('Collecting survey data...');
                                    surveyData = await this.collectSurveyData();
                                    console.log('Survey data collected successfully');

                                    // Save based on mode (edit vs new)
                                    if (this.isEditMode && this.editSurveyId) {
                                        console.log(`Updating existing survey (ID: ${this.editSurveyId})...`);
                                        
                                        // Save to MongoDB first (more reliable)
                                        console.log('Saving to MongoDB...');
                                        const mongoResult = await this.saveToMongoDB(surveyData);
                                        console.log('MongoDB save result:', mongoResult);
                                        
                                        // Then update Auth0 metadata
                                        console.log('Updating survey in Auth0...');
                                        await this.updateSurvey(this.editSurveyId, surveyData);
                                        
                                        this.showSuccessMessage('Survey edits submitted successfully!');
                                    } else {
                                        console.log('Submitting new survey...');
                                        
                                        // Save to MongoDB first (more reliable)
                                        console.log('Saving to MongoDB...');
                                        const mongoResult = await this.saveToMongoDB(surveyData);
                                        console.log('MongoDB save result:', mongoResult);
                                        
                                        // Then save to Auth0 metadata
                                        console.log('Saving survey to Auth0...');
                                        await this.submitSurvey(surveyData);
                                        
                                        this.showSuccessMessage('Analysis submitted successfully!');
                                    }

                                    // Reset form and close modal
                                    this.resetSurveyForm();
                                    $('#surveyModal').modal('hide');
                                    
                                    // Refresh user surveys list
                                    this.loadUserSurveys();
                                    
                                } catch (error) {
                                    // Enhanced error logging
                                    console.error('Error submitting survey:', error);
                                    
                                    if (surveyData) {
                                        // Log the data that failed, but truncate to avoid console flooding
                                        const dataStr = JSON.stringify(surveyData);
                                        console.error('Survey data that failed submission (truncated):', 
                                            dataStr.length > 500 ? dataStr.substring(0, 500) + '...' : dataStr);
                                    }
                                    
                                    // Show friendly error message
                                    this.showErrorMessage(`Failed to submit analysis: ${error.message || 'Unknown error'}`);
                                    
                                    // If authentication error, trigger login
                                    if (error.message && (
                                        error.message.includes('token') || 
                                        error.message.includes('auth') || 
                                        error.message.includes('unauthenticated')
                                    )) {
                                        console.log('Authentication error detected, will prompt to log in');
                                        setTimeout(() => {
                                            if (confirm('Your session may have expired. Would you like to log in again?')) {
                                                AuthManager.login();
                                            }
                                        }, 1000);
                                    }
                                } finally {
                                    // Always reset button state
                                    submitBtn.disabled = false;
                                    submitBtn.textContent = 'Submit Analysis';
                                    this.isSubmitting = false;
                                }
                            } else {
                                // Form validation failed
                                this.showValidationError();
                            }
                        });
                        
                        // Add debug button event listener
                        const debugBtn = document.getElementById('debug-survey-btn');
                        if (debugBtn) {
                            debugBtn.addEventListener('click', async () => {
                                try {
                                    console.log('---- SURVEY DEBUG INFO ----');
                                    const isAuth = await AuthManager.isUserAuthenticated(true);
                                    console.log('Is authenticated:', isAuth);
                                    
                                    if (isAuth) {
                                        const token = await AuthManager.getToken({
                                            timeoutInSeconds: 10,
                                            ignoreCache: false
                                        });
                                        const tokenInfo = this.parseJwt ? this.parseJwt(token) : null;
                                        console.log('Token scopes:', tokenInfo?.scope);
                                        console.log('Token expires in:', 
                                            Math.round((tokenInfo?.exp * 1000 - Date.now()) / 1000 / 60), 'minutes');
                                    }
                                    
                                    console.log('Form validation state:', this.validateCurrentTab());
                                    console.log('Current tab index:', this.currentTabIndex);
                                    console.log('Is edit mode:', this.isEditMode);
                                    console.log('Changed fields:', Array.from(this.changedFields || []));
                                    
                                    // Try to collect form data without submitting
                                    const formData = await this.collectSurveyData().catch(e => ({error: e.message}));
                                    console.log('Form data preview:', 
                                        formData.id,
                                        formData.metadata?.title,
                                        formData.metadata?.classification?.type);
                                    
                                    alert('Debug info logged to console');
                                } catch (error) {
                                    console.error('Debug error:', error);
                                    alert('Error during debugging: ' + error.message);
                                }
                            });
                        }
                    }
                    
                    // Add input change listeners to track edits
                    document.querySelectorAll(
                        '#surveyTabContent input:not([type="checkbox"]), #surveyTabContent textarea, #surveyTabContent select'
                    ).forEach(input => {
                        input.addEventListener('change', () => {
                            this.updateProgressBar();

                            // Check if this is an edit
                            const questionId = input.id.replace('-score', '').replace('-justification', '');
                            const editCheckbox = document.getElementById(`${questionId}-edited`);
                            if (editCheckbox) {
                                editCheckbox.checked = true;
                            }
                        });
                    });
                    
                    // Create new survey button
                    const createNewSurveyBtn = document.getElementById('create-new-survey-btn');
                    if (createNewSurveyBtn) {
                        createNewSurveyBtn.addEventListener('click', () => {
                            $('#userSurveysModal').modal('hide');
                            this.loadAvailableScenarios();
                            $('#scenarioSelectModal').modal('show');
                        });
                    }

                    // Scenario search functionality
                    const scenarioSearch = document.getElementById('scenario-search');
                    if (scenarioSearch) {
                        scenarioSearch.addEventListener('input', () => {
                            this.filterScenariosList(scenarioSearch.value);
                        });
                    }
                },

                /**
                * Attach modal-related event listeners
                */
                attachModalListeners() {
                    // Reset form when survey modal is closed
                    $('#surveyModal').on('hidden.bs.modal', () => {
                        this.resetSurveyForm();
                    });

                    // My Surveys button
                    const mySurveysBtn = document.getElementById('my-surveys-btn');
                    if (mySurveysBtn) {
                        mySurveysBtn.addEventListener('click', async () => {
                            const authenticated = await isUserAuthenticated();
                            if (authenticated) {
                                await this.loadUserSurveys();
                                $('#userSurveysModal').modal('show');
                            } else {
                                showLoginPrompt();
                            }
                        });
                    }
                },

                /**
                * Update tab display based on current tab index
                */
                updateTabDisplay() {
                    try {
                        // Hide all tabs
                        document.querySelectorAll('.tab-pane').forEach(tab => {
                            tab.classList.remove('show', 'active');
                        });

                        // Show current tab
                        const currentTab = document.getElementById(this.tabIds[this.currentTabIndex]);
                        if (currentTab) {
                            currentTab.classList.add('show', 'active');
                        }

                        // Update active tab in nav
                        document.querySelectorAll('.nav-link').forEach(link => {
                            link.classList.remove('active');
                        });
                        const tabLink = document.querySelector(`#${this.tabIds[this.currentTabIndex]}-tab`);
                        if (tabLink) {
                            tabLink.classList.add('active');
                        }

                        // Update buttons
                        const prevBtn = document.querySelector('.prev-tab-btn');
                        const nextBtn = document.querySelector('.next-tab-btn');
                        const submitBtn = document.querySelector('.submit-survey-btn');

                        if (prevBtn) prevBtn.disabled = this.currentTabIndex === 0;

                        if (nextBtn && submitBtn) {
                            if (this.currentTabIndex === this.tabIds.length - 1) {
                                nextBtn.style.display = 'none';
                                submitBtn.style.display = 'block';
                            } else {
                                nextBtn.style.display = 'block';
                                submitBtn.style.display = 'none';
                            }
                        }

                        // Update progress bar
                        this.updateProgressBar();
                    } catch (error) {
                        console.error('Error updating tab display:', error);
                    }
                },

                /**
                * Update the progress bar based on form completion
                */
                updateProgressBar() {
                    try {
                        const progressBar = document.querySelector('.progress-bar');
                        if (!progressBar) return;

                        // Define tab weights (each contributes 25% to total)
                        const tabWeights = {
                            'ends': 0.25,
                            'means': 0.25, 
                            'character': 0.25,
                            'philosophy': 0.25
                        };
                        
                        // Calculate completion percentage for each tab
                        const tabCompletions = {};
                        
                        this.tabIds.forEach(tabId => {
                            const formFields = document.querySelectorAll(
                                `#${tabId} input:not([disabled]):not([readonly]):not([type="checkbox"]), ` +
                                `#${tabId} textarea:not([disabled]):not([readonly]), ` +
                                `#${tabId} select:not([disabled]):not([readonly])`
                            );
                            
                            const totalFields = formFields.length;
                            const completedFields = [...formFields].filter(field => {
                                if (field.tagName.toLowerCase() === 'select') {
                                    return field.value !== '' && field.value !== null && field.selectedIndex !== -1;
                                } else if (field.tagName.toLowerCase() === 'textarea') {
                                    return field.value.trim() !== '';
                                } else {
                                    return field.value !== '' && field.value !== null;
                                }
                            }).length;
                            
                            tabCompletions[tabId] = totalFields > 0 ? (completedFields / totalFields) : 0;
                        });
                        
                        // Calculate overall weighted completion
                        let totalCompletion = 0;
                        for (const [tabId, completion] of Object.entries(tabCompletions)) {
                            totalCompletion += completion * tabWeights[tabId];
                        }
                        
                        // Calculate completion percentage (0-100)
                        const completionPercentage = Math.floor(totalCompletion * 100);
                        
                        // Update progress bar
                        progressBar.style.width = `${completionPercentage}%`;
                        progressBar.setAttribute('aria-valuenow', completionPercentage);
                        progressBar.textContent = `${completionPercentage}%`;
                        
                        // Update progress bar color
                        if (completionPercentage < 30) {
                            progressBar.className = 'progress-bar bg-danger';
                        } else if (completionPercentage < 70) {
                            progressBar.className = 'progress-bar bg-warning';
                        } else {
                            progressBar.className = 'progress-bar bg-success';
                        }
                    } catch (error) {
                        console.error('Error updating progress bar:', error);
                    }
                },

                /**
                * Validate the current tab
                * @returns {boolean} Whether the current tab is valid
                */
                // Fix the tab validation function
                validateCurrentTab() {
                    try {
                        const currentTab = this.tabIds[this.currentTabIndex];
                        const requiredFields = document.querySelectorAll(
                            `#${currentTab} input[type="number"]:not([readonly]), 
                            #${currentTab} select:not([disabled]):not([readonly])`
                        );

                        let isValid = true;

                        // Only validate fields that are actually visible
                        requiredFields.forEach(field => {
                            // Skip validation if field is hidden or part of a hidden container
                            if (!this.isElementVisible(field)) return;
                            
                            // For number inputs, check if it's a valid number within range
                            if (field.type === 'number') {
                                const value = parseFloat(field.value);
                                const min = parseFloat(field.min);
                                const max = parseFloat(field.max);
                                
                                // Only validate if boundaries are set and value is outside them
                                if ((!isNaN(min) && value < min) || (!isNaN(max) && value > max)) {
                                    field.classList.add('is-invalid');
                                    isValid = false;
                                } else if (field.value === '' || field.value === null) {
                                    field.classList.add('is-invalid');
                                    isValid = false;
                                } else {
                                    field.classList.remove('is-invalid');
                                }
                            } else if (field.value === '' || field.value === null) {
                                field.classList.add('is-invalid');
                                isValid = false;
                            } else {
                                field.classList.remove('is-invalid');
                            }
                        });

                        // Special case for first tab (moral classification)
                        if (this.currentTabIndex === 0) {
                            const moralClassification = document.getElementById('moral-classification');
                            if (moralClassification && !moralClassification.value) {
                                moralClassification.classList.add('is-invalid');
                                isValid = false;
                            } else if (moralClassification) {
                                moralClassification.classList.remove('is-invalid');
                            }
                        }
                        
                        // Log validation result for debugging
                        console.log(`Tab ${currentTab} validation result: ${isValid}`);
                        
                        // If validation fails, show which fields failed
                        if (!isValid) {
                            const invalidFields = document.querySelectorAll(`#${currentTab} .is-invalid`);
                            console.log(`Invalid fields: ${invalidFields.length}`);
                            invalidFields.forEach(field => {
                                console.log(`Invalid field: ${field.id}`);
                            });
                        }

                        return isValid;
                    } catch (error) {
                        console.error('Error validating tab:', error);
                        // Return true in case of error to prevent blocking user
                        return true;
                    }
                },

                // Helper function to check if an element is visible
                isElementVisible(element) {
                    if (!element) return false;
                    
                    // Check if element or any parent is hidden
                    let current = element;
                    while (current) {
                        // Check computed style
                        const style = window.getComputedStyle(current);
                        if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
                            return false;
                        }
                        
                        // Move up to parent
                        current = current.parentElement;
                    }
                    
                    return true;
                },

                /**
                * Filter the scenarios list based on search input
                * @param {string} searchText Text to search for
                */
                filterScenariosList(searchText) {
                    try {
                        if (!searchText) {
                            // Show all if search is empty
                            document.querySelectorAll('#scenarios-body tr').forEach(row => {
                                row.style.display = '';
                            });
                            return;
                        }

                        const searchLower = searchText.toLowerCase();

                        document.querySelectorAll('#scenarios-body tr').forEach(row => {
                            // Get text content of first two cells (title and category)
                            const title = row.cells[0]?.textContent.toLowerCase() || '';
                            const category = row.cells[1]?.textContent.toLowerCase() || '';

                            // Show row if title or category contains search text
                            if (title.includes(searchLower) || category.includes(searchLower)) {
                                row.style.display = '';
                            } else {
                                row.style.display = 'none';
                            }
                        });
                    } catch (error) {
                        console.error('Error filtering scenarios list:', error);
                    }
                },

                /**
                * Validate score is within expected range for a dimension and question
                * @param {string} dimensionId Dimension ID (e.g., 'Ends', 'Means', 'Character')
                * @param {string} questionId Question ID
                * @param {number} score Score value to validate
                * @throws {Error} If score is outside valid range
                */
                validateScoreRange(dimensionId, questionId, score) {
                    // Skip validation for philosophical questions that use string values
                    if (dimensionId === 'PhilosophicalAnalysis') {
                        return true;
                    }
                    
                    // Define valid ranges for each dimension/question
                    const rangeMap = {
                        'Ends': {
                            'Societal Needs': { min: 0, max: 4 },
                            'Others Needs': { min: 0, max: 4 },
                            'Others Wants': { min: 0, max: 4 },
                            'Personal Needs': { min: -4, max: 0 },
                            'Personal Wants': { min: -4, max: 0 }
                        },
                        'Means': {
                            'Future Self-Sacrifice': { min: -4, max: 0 },
                            'Number of Individuals Affected': { min: -6, max: 0 },
                            'Type of Sacrifice': { min: -4, max: 0 },
                            'Duration of Sacrifice': { min: -4, max: 0 },
                            'Magnitude of Life Impacted': { min: 0.01, max: 1.2 }
                        },
                        'Character': {
                            'Unconscious vs Conscious': { min: 0, max: 1 },
                            'Present Self-Sacrifice': { min: 0, max: 2 },
                            'Habit vs Will Power': { min: 0, max: 4 },
                            'Unintentional vs Intentional': { min: 0, max: 1 }
                        },
                        'PhilosophicalAnalysis': {
                            // Philosophical questions don't need numeric validation as they use text values
                        }
                    };
                    
                    // Skip validation for dimensions or questions without defined ranges
                    if (!rangeMap[dimensionId] || !rangeMap[dimensionId][questionId]) {
                        return true;
                    }
                    
                    // Ensure score is treated as a number for comparison
                    const numericScore = parseFloat(score);
                    
                    // Check if score is a valid number
                    if (isNaN(numericScore)) {
                        throw new Error(`Score for ${questionId} must be a number`);
                    }
                    
                    const range = rangeMap[dimensionId][questionId];
                    
                    // Check if score is within range
                    if (numericScore < range.min || numericScore > range.max) {
                        throw new Error(`Score for ${questionId} must be between ${range.min} and ${range.max}`);
                    }
                    
                    return true;
                },

                /**
                * Process form data for a question
                * @param {string} questionId Base ID of the question (without -score or -justification)
                * @param {boolean} noScore Whether this question doesn't have a score field
                * @returns {Object} Processed question data
                */
                processQuestionData(questionId, noScore = false) {
                    // Direct mapping to ensure exact match with expected format
                    const EXACT_QUESTION_NAMES = {
                        'societal-needs': 'Societal Needs',
                        'others-needs': 'Others Needs',
                        'others-wants': 'Others Wants', 
                        'personal-needs': 'Personal Needs',
                        'personal-wants': 'Personal Wants',
                        'future-sacrifice': 'Future Self-Sacrifice', // Critical fix
                        'individuals-affected': 'Number of Individuals Affected',
                        'sacrifice-type': 'Type of Sacrifice',
                        'sacrifice-duration': 'Duration of Sacrifice',
                        'life-magnitude': 'Magnitude of Life Impacted',
                        'consciousness': 'Unconscious vs Conscious',
                        'present-sacrifice': 'Present Self-Sacrifice',
                        'willpower': 'Habit vs Will Power',
                        'intentionality': 'Unintentional vs Intentional',
                        'wills': 'Wills at Play',
                        'deontology': 'Deontology',
                        'utilitarianism': 'Utilitarianism',
                        'virtue-ethics': 'Virtue Ethics'
                    };

                    const scoreField = document.getElementById(`${questionId}-score`);
                    const justField = document.getElementById(`${questionId}-justification`);
                    
                    // Use exact mapping to ensure consistency
                    const exactQuestionName = EXACT_QUESTION_NAMES[questionId];
                    if (!exactQuestionName) {
                        console.error(`Missing question name mapping for field ID: ${questionId}`);
                    }
                    
                    const question = {
                        question: exactQuestionName || questionId,
                        justification: justField?.value || ''
                    };
                    
                    if (!noScore && scoreField) {
                        if (scoreField.tagName.toLowerCase() === 'select') {
                            question.score = scoreField.value;
                        } else {
                            question.score = parseFloat(scoreField.value) || 0;
                        }
                    }
                    
                    return question;
                },

                /**
                * Calculate final x/y/z position from form values
                * @returns {Object} Position coordinates
                */
                calculateFinalPosition() {
                    try {
                        // Calculate X axis (Ends)
                        const societalNeedsScore = parseFloat(document.getElementById('societal-needs-score')?.value) || 0;
                        const othersNeedsScore = parseFloat(document.getElementById('others-needs-score')?.value) || 0;
                        const othersWantsScore = parseFloat(document.getElementById('others-wants-score')?.value) || 0;
                        const personalNeedsScore = parseFloat(document.getElementById('personal-needs-score')?.value) || 0;
                        const personalWantsScore = parseFloat(document.getElementById('personal-wants-score')?.value) || 0;
                        
                        // Calculate Y axis (Means)
                        const futureSacrificeScore = parseFloat(document.getElementById('future-sacrifice-score')?.value) || 0;
                        const individualsAffectedScore = parseFloat(document.getElementById('individuals-affected-score')?.value) || 0;
                        const sacrificeTypeScore = parseFloat(document.getElementById('sacrifice-type-score')?.value) || 0;
                        const sacrificeDurationScore = parseFloat(document.getElementById('sacrifice-duration-score')?.value) || 0;
                        const lifeMagnitudeScore = parseFloat(document.getElementById('life-magnitude-score')?.value) || 0;
                        
                        // Calculate Z axis (Character)
                        const consciousnessScore = parseFloat(document.getElementById('consciousness-score')?.value) || 0;
                        const presentSacrificeScore = parseFloat(document.getElementById('present-sacrifice-score')?.value) || 0;
                        const willpowerScore = parseFloat(document.getElementById('willpower-score')?.value) || 0;
                        const intentionalityScore = parseFloat(document.getElementById('intentionality-score')?.value) || 0;
                        
                        // Final calculations
                        const x = ((societalNeedsScore + othersNeedsScore + othersWantsScore) - 
                                Math.abs(personalNeedsScore) - Math.abs(personalWantsScore));
                                
                        const y = ((futureSacrificeScore + individualsAffectedScore + 
                                sacrificeTypeScore + sacrificeDurationScore) * -1) * 
                                lifeMagnitudeScore;
                                
                        const z = consciousnessScore + presentSacrificeScore + 
                                willpowerScore + intentionalityScore;
                        
                        return {
                            x: parseFloat(x.toFixed(2)),
                            y: parseFloat(y.toFixed(2)),
                            z: parseFloat(z.toFixed(2))
                        };
                    } catch (error) {
                        console.error('Error calculating final position:', error);
                        return { x: 0, y: 0, z: 0 };
                    }
                },

                /**
                * Populate model answers in the form
                * @param {Object} scenario Scenario data
                */
                /**
                * Enhanced version for philosophy tab population
                */
                populateModelAnswers(scenario) {
                    try {
                        if (!scenario.dimensions) return;
                        
                        console.log("Populating model answers from scenario:", scenario.scenarioTitle);
                        
                        // Map of dimension IDs to tab IDs
                        const dimensionTabMap = {
                            'Ends': 'ends',
                            'Means': 'means',
                            'Character': 'character',
                            'PhilosophicalAnalysis': 'philosophy'
                        };
                        
                        // Map of question IDs to form field IDs
                        const questionFieldMap = {
                            'Societal Needs': 'societal-needs',
                            'Others Needs': 'others-needs',
                            'Others Wants': 'others-wants',
                            'Personal Needs': 'personal-needs',
                            'Personal Wants': 'personal-wants',
                            'Future Self-Sacrifice': 'future-sacrifice',
                            'Number of Individuals Affected': 'individuals-affected',
                            'Type of Sacrifice': 'sacrifice-type',
                            'Duration of Sacrifice': 'sacrifice-duration',
                            'Magnitude of Life Impacted': 'life-magnitude',
                            'Unconscious vs Conscious': 'consciousness',
                            'Present Self-Sacrifice': 'present-sacrifice',
                            'Habit vs Will Power': 'willpower',
                            'Unintentional vs Intentional': 'intentionality',
                            'Wills at Play': 'wills',
                            'Deontology': 'deontology',
                            'Utilitarianism': 'utilitarianism',
                            'Virtue Ethics': 'virtue-ethics'
                        };
                        
                        // Process each dimension and its questions
                        scenario.dimensions.forEach(dimension => {
                            const tabId = dimensionTabMap[dimension.id];
                            if (!tabId) return;
                            
                            // Process all questions in this dimension
                            (dimension.questions || []).forEach(question => {
                                const fieldBase = questionFieldMap[question.question];
                                if (!fieldBase) {
                                    console.warn(`Unknown question: ${question.question}`);
                                    return;
                                }
                                
                                // Set score field
                                const scoreField = document.getElementById(`${fieldBase}-score`);
                                if (scoreField) {
                                    // Handle select elements (for philosophy)
                                    if (scoreField.tagName.toLowerCase() === 'select') {
                                        // Try to match option by value or text
                                        let optionFound = false;
                                        const scoreValue = String(question.score);
                                        
                                        // First try matching by value
                                        Array.from(scoreField.options).forEach(option => {
                                            if (option.value === scoreValue) {
                                                option.selected = true;
                                                optionFound = true;
                                            }
                                        });
                                        
                                        // If no match by value, try matching by text content
                                        if (!optionFound) {
                                            Array.from(scoreField.options).forEach(option => {
                                                if (option.textContent.includes(scoreValue)) {
                                                    option.selected = true;
                                                    optionFound = true;
                                                }
                                            });
                                        }
                                        
                                        // If still no match, use first non-disabled option
                                        if (!optionFound && scoreField.options.length > 0) {
                                            for (let i = 0; i < scoreField.options.length; i++) {
                                                if (!scoreField.options[i].disabled) {
                                                    scoreField.options[i].selected = true;
                                                    break;
                                                }
                                            }
                                        }
                                    } else if (question.score !== undefined) {
                                        // For number inputs
                                        scoreField.value = question.score;
                                        
                                        // Update slider if it exists
                                        const slider = document.getElementById(`${fieldBase}-slider`);
                                        if (slider) {
                                            slider.value = question.score;
                                        }
                                    }
                                    
                                    // Trigger change event
                                    const event = new Event('change', { bubbles: true });
                                    scoreField.dispatchEvent(event);
                                }
                                
                                // Set justification field
                                const justField = document.getElementById(`${fieldBase}-justification`);
                                if (justField && question.justification) {
                                    // Ensure it's editable
                                    justField.readOnly = false;
                                    justField.disabled = false;
                                    
                                    // Set value
                                    justField.value = question.justification;
                                    
                                    // Trigger change event
                                    const event = new Event('change', { bubbles: true });
                                    justField.dispatchEvent(event);
                                }
                            });
                        });
                        
                        // Set classification justification if available
                        if (scenario.metadata?.classification?.justification) {
                            const justField = document.getElementById('classification-justification');
                            if (justField) {
                                justField.value = scenario.metadata.classification.justification;
                            }
                        }
                        
                        // Make sure all fields are editable
                        this.ensureFormFieldsEditable();
                        
                    } catch (error) {
                        console.error('Error populating model answers:', error);
                    }
                },

                /**
                * Specifically handle philosophy tab population
                */
                populatePhilosophyTab(dimension) {
                    // Direct field mappings
                    const PHILOSOPHY_FIELD_MAP = {
                        'Deontology': 'deontology',
                        'Utilitarianism': 'utilitarianism',
                        'Virtue Ethics': 'virtue-ethics'
                    };
                    
                    // Process each philosophy question
                    (dimension.questions || []).forEach(question => {
                        const questionName = question.question;
                        const fieldBase = PHILOSOPHY_FIELD_MAP[questionName];
                        
                        if (!fieldBase) {
                            console.warn(`Unknown philosophy question: ${questionName}`);
                            return;
                        }
                        
                        console.log(`Populating philosophy field: ${fieldBase} with score: ${question.score}`);
                        
                        // Get form elements
                        const scoreSelect = document.getElementById(`${fieldBase}-score`);
                        const justField = document.getElementById(`${fieldBase}-justification`);
                        
                        // Populate score dropdown
                        if (scoreSelect && question.score) {
                            // Try exact match first
                            let optionFound = false;
                            Array.from(scoreSelect.options).forEach(option => {
                                if (option.value === String(question.score)) {
                                    option.selected = true;
                                    optionFound = true;
                                }
                            });
                            
                            // If no exact match, try matching text content
                            if (!optionFound) {
                                Array.from(scoreSelect.options).forEach(option => {
                                    if (option.textContent.trim() === String(question.score) ||
                                        option.textContent.trim().toLowerCase() === String(question.score).toLowerCase()) {
                                        option.selected = true;
                                    }
                                });
                            }
                            
                            // Force a change event
                            const changeEvent = new Event('change', { bubbles: true });
                            scoreSelect.dispatchEvent(changeEvent);
                        }
                        
                        // Populate justification text
                        if (justField && question.justification) {
                            // Make sure it's not readonly
                            justField.readOnly = false;
                            justField.disabled = false;
                            
                            // Set the value
                            justField.value = question.justification;
                            
                            // Force a change event
                            const changeEvent = new Event('change', { bubbles: true });
                            justField.dispatchEvent(changeEvent);
                        }
                    });
                },

                /**
                * Handle standard dimensions
                */
                populateStandardDimension(dimension) {
                    // Question field mapping
                    const QUESTION_FIELD_MAP = {
                        'Societal Needs': 'societal-needs',
                        'Others Needs': 'others-needs',
                        'Others Wants': 'others-wants',
                        'Personal Needs': 'personal-needs',
                        'Personal Wants': 'personal-wants',
                        'Future Self-Sacrifice': 'future-sacrifice',
                        'Number of Individuals Affected': 'individuals-affected',
                        'Type of Sacrifice': 'sacrifice-type',
                        'Duration of Sacrifice': 'sacrifice-duration',
                        'Magnitude of Life Impacted': 'life-magnitude',
                        'Unconscious vs Conscious': 'consciousness',
                        'Present Self-Sacrifice': 'present-sacrifice',
                        'Habit vs Will Power': 'willpower',
                        'Unintentional vs Intentional': 'intentionality',
                        'Wills at Play': 'wills'
                    };
                    
                    // Process each question
                    (dimension.questions || []).forEach(question => {
                        const questionName = question.question;
                        const fieldBase = QUESTION_FIELD_MAP[questionName];
                        
                        if (!fieldBase) {
                            console.warn(`Unknown question for ${dimension.id}: ${questionName}`);
                            return;
                        }
                        
                        // Set score field
                        const scoreField = document.getElementById(`${fieldBase}-score`);
                        if (scoreField && question.score !== undefined) {
                            scoreField.value = question.score;
                            
                            // Update slider if it exists
                            const slider = document.getElementById(`${fieldBase}-slider`);
                            if (slider) {
                                slider.value = question.score;
                            }
                            
                            // Force a change event
                            const changeEvent = new Event('change', { bubbles: true });
                            scoreField.dispatchEvent(changeEvent);
                        }
                        
                        // Set justification field
                        const justField = document.getElementById(`${fieldBase}-justification`);
                        if (justField && question.justification) {
                            justField.value = question.justification;
                            
                            // Force a change event
                            const changeEvent = new Event('change', { bubbles: true });
                            justField.dispatchEvent(changeEvent);
                        }
                    });
                },

                /**
                * Generate a unique ID
                * @returns {string} Unique ID
                */
                generateId() {
                    return `survey_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
                },
                /**
                * Ensure all form fields are editable
                */
                ensureFormFieldsEditable() {
                    // Enable all fields in form
                    document.querySelectorAll('#surveyTabContent textarea, #surveyTabContent select, #surveyTabContent input').forEach(field => {
                        field.disabled = false;
                        field.readOnly = false;
                    });
                    
                    // Specifically target philosophy fields which might have special handling
                    document.querySelectorAll('#philosophy textarea, #philosophy select').forEach(field => {
                        field.disabled = false;
                        field.readOnly = false;
                    });
                    
                    console.log("All form fields are now editable");
                },
                /**
                * Collect survey data from form
                * @returns {Promise<Object>} Collected survey data
                */
                async collectSurveyData() {
                    try {
                        // Ensure user is authenticated
                        const isAuthenticated = await AuthManager.isUserAuthenticated();
                        if (!isAuthenticated) {
                        throw new Error('User is not authenticated');
                        }
                        
                        // Get user information
                        const user = await AuthManager.getUser();
                        
                        // Get and log required fields
                        const scenarioId = document.getElementById('scenario-id')?.value;
                        const scenarioTitle = document.getElementById('scenario-title-display')?.value;
                        const moralClassification = document.getElementById('moral-classification')?.value;
                        
                        console.log("collectSurveyData: scenarioId:", scenarioId, 
                                    "scenarioTitle:", scenarioTitle, 
                                    "moralClassification:", moralClassification);
                        
                        if (!scenarioId || !scenarioTitle || !moralClassification) {
                        throw new Error('Missing required fields: scenario ID, title, or classification');
                        }
                        
                        // Create survey data with proper structure
                        const surveyData = {
                            id: scenarioId || this.generateId(),
                            type: document.getElementById('scenario-type')?.value || 'base',
                            parentId: document.getElementById('scenario-parent-id')?.value || null,
                            metadata: {
                                title: scenarioTitle,
                                description: document.getElementById('scenario-description-display')?.value || '',
                                category: document.getElementById('scenario-category-display')?.value || '',
                                llmSource: {
                                    model: "Human",
                                    version: "1.0",
                                    provider: "Human"
                                },
                                classification: {
                                    type: moralClassification,
                                    justification: document.getElementById('classification-justification')?.value || ''
                                },
                                url: document.getElementById('scenario-url')?.value || ''
                            },
                            survey: {
                                dimensions: [
                                    {
                                        id: "Ends",
                                        axis: "x",
                                        label: "Motivation",
                                        questions: [
                                            this.processQuestionData('societal-needs'),
                                            this.processQuestionData('others-needs'),
                                            this.processQuestionData('others-wants'),
                                            this.processQuestionData('personal-needs'),
                                            this.processQuestionData('personal-wants')
                                        ]
                                    },
                                    {
                                        id: "Means",
                                        axis: "y",
                                        label: "Sacrifice",
                                        questions: [
                                            this.processQuestionData('future-sacrifice'),
                                            this.processQuestionData('individuals-affected'),
                                            this.processQuestionData('sacrifice-type'),
                                            this.processQuestionData('sacrifice-duration'),
                                            this.processQuestionData('life-magnitude')
                                        ]
                                    },
                                    {
                                        id: "Character",
                                        axis: "z",
                                        label: "Habit > Will Power",
                                        questions: [
                                            this.processQuestionData('consciousness'),
                                            this.processQuestionData('present-sacrifice'),
                                            this.processQuestionData('willpower'),
                                            this.processQuestionData('intentionality'),
                                            this.processQuestionData('wills', true) // No score
                                        ]
                                    },
                                    {
                                        id: "PhilosophicalAnalysis",
                                        axis: null,
                                        label: "Philosophical Perspectives",
                                        questions: [
                                            this.processQuestionData('deontology'),
                                            this.processQuestionData('utilitarianism'),
                                            this.processQuestionData('virtue-ethics')
                                        ]
                                    }
                                ],
                                finalPosition: this.calculateFinalPosition()
                            },
                            edits: {
                                editedBy: user?.sub || null,
                                editDate: new Date().toISOString(),
                                editedFields: this.getEditedFields()
                            },
                            created: new Date().toISOString(),
                            lastModified: new Date().toISOString()
                        };
                        
                        return surveyData;
                    } catch (error) {
                        console.error('Error collecting survey data:', error);
                        throw error;
                    }
                },

                /**
                * Enhance the survey UI with better user experience
                */
                enhanceSurveyUI() {
                    document.querySelectorAll('[id$="-slider-container"]').forEach(container => {
                        container.remove();
                    });
                    try {
                        // Make modal scrollable and larger
                        const modalDialog = document.querySelector('#surveyModal .modal-dialog');
                        if (modalDialog) {
                            modalDialog.classList.add('modal-dialog-scrollable');
                            
                            // Remove any existing max-height style
                            const modalBody = document.querySelector('#surveyModal .modal-body');
                            if (modalBody) {
                                modalBody.style.maxHeight = 'none';
                                modalBody.style.overflow = 'initial';
                            }
                        }
                        
                        // Add sliders for numeric inputs
                        document.querySelectorAll('#surveyTabContent input[type="number"]').forEach(input => {
                            const inputId = input.id;
                            const baseId = inputId.replace('-score', '');
                            
                            // Check if a slider container for this input already exists.
                            if (document.getElementById(`${baseId}-slider-container`)) {
                                return; // Skip creating another slider if one is already present.
                            }
                            
                            // Create the slider container
                            const sliderContainer = document.createElement('div');
                            sliderContainer.className = 'form-group mt-2';
                            sliderContainer.id = `${baseId}-slider-container`;
                            
                            // Get min, max, and step values from the original input
                            const min = parseFloat(input.min) || 0;
                            const max = parseFloat(input.max) || 4;
                            const step = parseFloat(input.step) || 0.1;
                            
                            // Create the slider element
                            const slider = document.createElement('input');
                            slider.type = 'range';
                            slider.className = 'form-control-range';
                            slider.id = `${baseId}-slider`;
                            slider.min = min;
                            slider.max = max;
                            slider.step = step;
                            // Ensure the slider is synchronized with the original input value.
                            slider.value = input.value || 0;
                            
                            // Add a label for the slider (optional)
                            const sliderLabel = document.createElement('label');
                            sliderLabel.htmlFor = slider.id;
                            sliderLabel.className = 'd-flex justify-content-between';
                            sliderLabel.innerHTML = `
                                <small>${min}</small>
                                <small>Adjust Value</small>
                                <small>${max}</small>
                            `;
                            
                            // Add event listeners to keep the slider and input in sync
                            slider.addEventListener('input', () => {
                                input.value = slider.value;
                            });
                            input.addEventListener('input', () => {
                                slider.value = input.value;
                            });
                            
                            // Append the label and slider to the container
                            sliderContainer.appendChild(sliderLabel);
                            sliderContainer.appendChild(slider);
                            
                            // Insert the slider container after the input's form group
                            const inputGroup = input.closest('.form-group');
                            if (inputGroup) {
                                inputGroup.parentNode.insertBefore(sliderContainer, inputGroup.nextElementSibling);
                            }
                            });

                        
                        // Enhance the progress bar
                        this.updateProgressBar();
                        
                    } catch (error) {
                        console.error('Error enhancing survey UI:', error);
                    }
                    // Add after enhanceSurveyUI
                this.ensureFormFieldsEditable();
                },
                
                /**
                * Reset the survey form
                */
                resetSurveyForm() {
                    try {
                        this.isEditMode = false;
                        this.editSurveyId = null;
                        
                        // Reset all input fields
                        document.querySelectorAll('#surveyTabContent input:not([type="checkbox"]), #surveyTabContent textarea, #surveyTabContent select').forEach(input => {
                            if (input.tagName.toLowerCase() === 'select') {
                                input.selectedIndex = 0;
                            } else {
                                input.value = '';
                            }
                        });
                        
                        // Uncheck all checkboxes
                        document.querySelectorAll('#surveyTabContent input[type="checkbox"]').forEach(checkbox => {
                            checkbox.checked = false;
                        });
                        
                        // Remove any existing sliders
                        document.querySelectorAll('[id$="-slider-container"]').forEach(container => {
                            container.remove();
                        });
                        
                        // Reset tabs
                        this.currentTabIndex = 0;
                        this.updateTabDisplay();
                        
                        // Clear scenario data
                        this.scenarioData = null;
                        this.originalScenarioData = null;
                        
                        // Reset progress bar
                        const progressBar = document.querySelector('.progress-bar');
                        if (progressBar) {
                            progressBar.style.width = '0%';
                            progressBar.setAttribute('aria-valuenow', 0);
                            progressBar.textContent = '0%';
                        }

                        // Clear changed fields
                        this.changedFields.clear();
                        this.initialFormState = {};
                    } catch (error) {
                        console.error('Error resetting survey form:', error);
                    }
                },

                // Placeholder methods to be implemented later
                loadUserSurveys() {
                    console.log('Loading user surveys...');
                    // Implementation will be added later
                    return Promise.resolve([]);
                },
                
                loadAvailableScenarios() {
                    console.log('Loading available scenarios...');
                    // Implementation will be added later
                },
                
                showValidationError() {
                    console.log('Validation error');
                    alert('Please complete all required fields before proceeding.');
                },
                
                showSuccessMessage(message) {
                    console.log('Success:', message);
                    alert(message);
                },
                
                showErrorMessage(message) {
                    console.error('Error:', message);
                    alert(message);
                },
                
                async getUserSurveys() {
                    // Return empty array to prevent errors
                    return [];
                },
                
                async submitSurvey() {
                    // Dummy implementation
                    return { success: true };
                },
                
                async updateSurvey() {
                    // Dummy implementation
                    return { success: true };
                },
                
                async checkAuthentication() {
                    return await AuthManager.isUserAuthenticated();
                },

                /**
                * Save survey data to MongoDB via Netlify function
                * @param {Object} surveyData Survey data to save
                * @returns {Promise<Object>} Result of the operation
                */
                async saveToMongoDB(surveyData) {
                    try {
                        console.log('Saving to MongoDB:', JSON.stringify(surveyData).substring(0, 200) + '...');
                        
                        // Request token with explicit audience and required Management API scopes
                        const token = await AuthManager.getToken({
                            useAudience: true,
                            authorizationParams: {
                                scope: 'openid profile email read:current_user update:current_user_metadata offline_access'
                            },
                            timeoutInSeconds: 60,
                            maxRetries: this.AUTH_RETRY_LIMIT
                        });
                        
                        // Log token information for debugging (safely)
                        const tokenInfo = this.parseJwt(token);
                        console.log('Token obtained with scopes:', tokenInfo?.scope);
                        console.log('Token expires at:', new Date(tokenInfo?.exp * 1000).toISOString());
                        
                        // Add timeout handling for MongoDB save
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 20000); // 20-second timeout
                        
                        try {
                            console.log('Sending survey data to Netlify function...');
                            const response = await fetch('/.netlify/functions/saveSurvey', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${token}`
                                },
                                body: JSON.stringify({
                                    survey: surveyData,
                                    timestamp: new Date().toISOString()
                                }),
                                signal: controller.signal
                            });
                            
                            clearTimeout(timeoutId);
                            
                            // Log response status for debugging
                            console.log('Netlify function response status:', response.status);
                            
                            if (!response.ok) {
                                let errorMessage = 'Unknown error';
                                try {
                                    const errorData = await response.json();
                                    errorMessage = errorData.message || `Status: ${response.status}`;
                                    console.error('Error response from server:', errorData);
                                } catch (parseError) {
                                    errorMessage = await response.text() || `HTTP error: ${response.status}`;
                                    console.error('Error text from server:', errorMessage);
                                }
                                throw new Error(`Failed to save survey: ${errorMessage}`);
                            }
                            
                            const responseData = await response.json();
                            console.log('Survey successfully saved to MongoDB:', responseData);
                            return responseData;
                        } catch (fetchError) {
                            clearTimeout(timeoutId);
                            
                            if (fetchError.name === 'AbortError') {
                                console.error('Save operation timed out');
                                throw new Error('Save operation timed out. Please try again.');
                            }
                            
                            console.error('Fetch error:', fetchError);
                            throw fetchError;
                        }
                    } catch (error) {
                        console.error('Error saving survey to MongoDB:', error);
                        throw error;
                    }
                }
            };
            // Base VisualizationManager definition
            const VisualizationManager = {
            // State
            selectedScenarios: [],
            selectedModels: [],
            selectedCategories: [],
            selectedAlternateOutcomes: [],
            activeCategories: new Set(['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building']),
            currentMediaUrl: "",
            isUpdatingVisuals: false,
            scenarioColorMapping: {},
            selectedComparison: [], // IDs of scenarios selected for comparison
            
            // Constants
            MAX_SELECTIONS: 4,
            MAX_COMPARISON: 2,
            BORDER_COLORS: ["purple", "blue", "black", "pink", "dark green", "orange", "teal", "brown"],
            
            /**
             * Initialize filter event listeners and media controls.
             */
            initialize() {
                this.attachFilterListeners();
                this.attachComparisonCardHandlers();
                this.initializeMediaControls();
                console.log("Visualization manager initialized");
            },
            
            /**
             * Attach event listeners to all filter controls.
             */
            attachFilterListeners() {
                const modelFilter = document.getElementById('modelFilter');
                if (modelFilter) {
                modelFilter.addEventListener('change', (e) => this.handleModelFilterChange(e));
                }
                
                const scenarioFilter = document.getElementById('scenarioFilter');
                if (scenarioFilter) {
                scenarioFilter.addEventListener('change', (e) => this.handleScenarioFilterChange(e));
                }
                
                const categoryFilter = document.getElementById('categoryFilter');
                if (categoryFilter) {
                categoryFilter.addEventListener('change', (e) => this.handleCategoryFilterChange(e));
                }
                
                const alternateOutcomes = document.getElementById('alternateOutcomes');
                if (alternateOutcomes) {
                alternateOutcomes.addEventListener('change', (e) => this.handleAlternateOutcomesChange(e));
                }
                
                document.querySelectorAll('.filter-badge').forEach(badge => {
                badge.addEventListener('click', (e) => this.handleCategoryBadgeClick(e));
                });
                
                const clearFiltersBtn = document.getElementById('clearFilters');
                if (clearFiltersBtn) {
                clearFiltersBtn.addEventListener('click', () => this.clearAllFilters());
                }
                
                // "Read more" links in cards
                document.addEventListener('click', (e) => {
                if (e.target.classList.contains('read-more')) {
                    this.handleReadMoreClick(e);
                }
                });
                
                // Login link in user surveys section
                const loginToAnalyzeLink = document.getElementById('login-to-analyze');
                if (loginToAnalyzeLink) {
                    loginToAnalyzeLink.addEventListener('click', () => {
                        AuthManager.login();
                    });
                }
            },
            
            /**
             * Handle model filter changes.
             * @param {Event} e Change event.
             */
            handleModelFilterChange(e) {
                if (this.isUpdatingVisuals) return;
                this.selectedModels = Array.from(e.target.selectedOptions).map(option => option.value);
                if (this.selectedModels.length > this.MAX_SELECTIONS) {
                this.showWarningMessage(`Please select a maximum of ${this.MAX_SELECTIONS} models for comparison`);
                this.selectedModels = this.selectedModels.slice(0, this.MAX_SELECTIONS);
                this.updateSelectionUI(e.target, this.selectedModels);
                }
                if (this.selectedScenarios.length > 1 && !this.selectedModels.includes("GPT")) {
                const gptOption = Array.from(e.target.options).find(opt => opt.value === "GPT");
                if (gptOption) {
                    gptOption.selected = true;
                    this.selectedModels = ["GPT"];
                }
                }
                this.updateAlternateOutcomesDropdown();
                this.updateVisualization();
            },
            
            /**
             * Handle scenario filter changes.
             * @param {Event} e Change event.
             */
            handleScenarioFilterChange(e) {
                if (this.isUpdatingVisuals) return;
                this.selectedModels = [];
                this.selectedAlternateOutcomes = [];
                const modelFilter = document.getElementById('modelFilter');
                if (modelFilter) {
                Array.from(modelFilter.options).forEach(opt => { opt.selected = false; });
                }
                const alternateOutcomes = document.getElementById('alternateOutcomes');
                if (alternateOutcomes) {
                alternateOutcomes.innerHTML = '<option disabled>Select a model first</option>';
                alternateOutcomes.disabled = true;
                }
                this.selectedScenarios = Array.from(e.target.selectedOptions).map(option => option.value);
                if (this.selectedScenarios.length > this.MAX_SELECTIONS) {
                this.showWarningMessage(`Please select a maximum of ${this.MAX_SELECTIONS} scenarios for comparison`);
                this.selectedScenarios = this.selectedScenarios.slice(0, this.MAX_SELECTIONS);
                this.updateSelectionUI(e.target, this.selectedScenarios);
                }
                const options = Array.from(e.target.options);
                options.forEach(option => {
                option.style.display = this.selectedScenarios.length < this.MAX_SELECTIONS || this.selectedScenarios.includes(option.value)
                    ? 'block'
                    : 'none';
                });
                this.updateAvailableModels();
                this.updateVisualization();
            },
            showModelSelectionModal: function(scenarioId, scenarioTitle) {
                // Create modal if it doesn't exist
                let modelModal = document.getElementById('modelSelectionModal');
                
                if (!modelModal) {
                    // Create modal HTML
                    const modalHTML = `
                    <div class="modal fade" id="modelSelectionModal" tabindex="-1" role="dialog">
                        <div class="modal-dialog" role="document">
                            <div class="modal-content">
                                <div class="modal-header">
                                    <h5 class="modal-title">Choose Analysis Method</h5>
                                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                                        <span aria-hidden="true">&times;</span>
                                    </button>
                                </div>
                                <div class="modal-body">
                                    <h6 id="model-scenario-title"></h6>
                                    <p>How would you like to analyze this scenario?</p>
                                    
                                    <div class="list-group mb-3" id="model-options">
                                        <button type="button" class="list-group-item list-group-item-action" id="own-analysis-btn">
                                            <i class="fas fa-user mr-2"></i> Enter my own analysis
                                        </button>
                                    </div>
                                    
                                    <div class="text-center text-muted" id="loading-models">
                                        <div class="spinner-border spinner-border-sm" role="status">
                                            <span class="sr-only">Loading models...</span>
                                        </div>
                                        <span>Loading available AI models...</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    `;
                    
                    // Add modal to body
                    const modalContainer = document.createElement('div');
                    modalContainer.innerHTML = modalHTML;
                    document.body.appendChild(modalContainer);
                    
                    modelModal = document.getElementById('modelSelectionModal');
                }
                
                // Update scenario title
                const titleElement = document.getElementById('model-scenario-title');
                if (titleElement) {
                    titleElement.textContent = `Scenario: ${scenarioTitle}`;
                }
                
                // Clear previous model options and show loading
                const modelOptions = document.getElementById('model-options');
                const loadingElement = document.getElementById('loading-models');
                
                if (modelOptions && loadingElement) {
                    // Keep only the "own analysis" button
                    const ownAnalysisBtn = document.getElementById('own-analysis-btn');
                    modelOptions.innerHTML = '';
                    modelOptions.appendChild(ownAnalysisBtn);
                    
                    // Show loading indicator
                    loadingElement.style.display = 'block';
                    
                    // Find available models for this scenario
                    setTimeout(() => {
                        // Get all available models for this scenario title
                        const scenarioPoints = ScenarioDataProcessor.dataPoints.filter(p => 
                            p.scenarioTitle === scenarioTitle
                        );
                        
                        // Get unique models
                        const availableModels = [...new Set(scenarioPoints.map(p => p.llmName))];
                        
                        // Add model buttons
                        availableModels.forEach(model => {
                            const modelBtn = document.createElement('button');
                            modelBtn.className = 'list-group-item list-group-item-action';
                            modelBtn.innerHTML = `<i class="fas fa-robot mr-2"></i> Use ${ScenarioDataProcessor.escapeHTML(model)} analysis`;
                            
                            modelBtn.addEventListener('click', () => {
                                // Find the scenario for this model
                                const modelScenario = scenarioPoints.find(p => p.llmName === model);
                                if (modelScenario) {
                                    // Close modal
                                    $('#modelSelectionModal').modal('hide');
                                    
                                    // Use this model's analysis
                                    this.selectScenarioForAnalysis(modelScenario.id, true);
                                }
                            });
                            
                            modelOptions.appendChild(modelBtn);
                        });
                        
                        // Hide loading indicator
                        loadingElement.style.display = 'none';
                        
                        // Set up own analysis button
                        const ownAnalysisBtn = document.getElementById('own-analysis-btn');
                        if (ownAnalysisBtn) {
                            ownAnalysisBtn.addEventListener('click', () => {
                                // Close modal
                                $('#modelSelectionModal').modal('hide');
                                
                                // Start fresh analysis
                                this.selectScenarioForAnalysis(scenarioId, false);
                            });
                        }
                    }, 500);
                }
                
                // Close the scenario selection modal
                $('#scenarioSelectModal').modal('hide');
                
                // Show the model selection modal
                $('#modelSelectionModal').modal('show');
            },
            /**
             * Update available models based on selected scenarios.
             */
            updateAvailableModels() {
                try {
                const modelFilter = document.getElementById('modelFilter');
                if (!modelFilter) return;
                if (this.selectedScenarios.length === 0) {
                    const allModels = [...new Set(ScenarioDataProcessor.dataPoints.map(p => p.llmName))];
                    modelFilter.innerHTML = allModels.map(model =>
                    `<option value="${ScenarioDataProcessor.escapeHTML(model)}">${ScenarioDataProcessor.escapeHTML(model)}</option>`
                    ).join('');
                    modelFilter.disabled = false;
                    return;
                }
                const availableModels = new Set();
                let isFirstScenario = true;
                this.selectedScenarios.forEach(scenario => {
                    const scenarioData = ScenarioDataProcessor.dataPoints.filter(point => point.scenarioTitle === scenario);
                    const scenarioModels = new Set(scenarioData.map(data => data.llmName));
                    if (isFirstScenario) {
                    scenarioModels.forEach(model => availableModels.add(model));
                    isFirstScenario = false;
                    } else {
                    [...availableModels].forEach(model => {
                        if (!scenarioModels.has(model)) {
                        availableModels.delete(model);
                        }
                    });
                    }
                });
                if (availableModels.size > 0) {
                    modelFilter.innerHTML = [...availableModels].map(model =>
                    `<option value="${ScenarioDataProcessor.escapeHTML(model)}">${ScenarioDataProcessor.escapeHTML(model)}</option>`
                    ).join('');
                    modelFilter.disabled = false;
                } else {
                    modelFilter.innerHTML = '<option disabled>No models available for selected scenarios</option>';
                    modelFilter.disabled = true;
                }
                } catch (error) {
                console.error('Error updating available models:', error);
                }
            },
            
            /**
             * Handle category filter changes.
             * @param {Event} e Change event.
             */
            handleCategoryFilterChange(e) {
                if (this.isUpdatingVisuals) return;
                this.selectedCategories = Array.from(e.target.selectedOptions).map(option => option.value);
                this.resetFilters(['scenarios', 'models', 'alternates']);
                this.updateVisualization();
            },
            
            /**
             * Handle alternate outcomes dropdown changes.
             * @param {Event} e Change event.
             */
            handleAlternateOutcomesChange(e) {
                if (this.isUpdatingVisuals) return;
                this.selectedAlternateOutcomes = Array.from(e.target.selectedOptions).map(opt => opt.value);
                const MAX_ALTERNATES = 3;
                if (this.selectedAlternateOutcomes.length > MAX_ALTERNATES) {
                this.showWarningMessage(`Please select a maximum of ${MAX_ALTERNATES} alternate scenarios`);
                this.selectedAlternateOutcomes = this.selectedAlternateOutcomes.slice(0, MAX_ALTERNATES);
                this.updateSelectionUI(e.target, this.selectedAlternateOutcomes);
                }
                this.updateAlternateVisualization();
            },
            
            /**
             * Update visualization for alternate outcomes selection.
             */
            updateAlternateVisualization() {
                let updatedPoints = [];
                try {
                if (this.selectedScenarios.length === 1 && this.selectedModels.length === 1) {
                    const parentScenarioTitle = this.selectedScenarios[0];
                    const selModel = this.selectedModels[0];
                    const parentPoint = ScenarioDataProcessor.dataPoints.find(p =>
                    p.scenarioTitle === parentScenarioTitle &&
                    p.llmName === selModel &&
                    p.isParent
                    );
                    const rels = ScenarioDataProcessor.scenarioRelationships.get(parentScenarioTitle) || [];
                    const alternatePoints = rels
                    .filter(child => child.model === selModel && this.selectedAlternateOutcomes.includes(child.childId))
                    .map(child => child.data);
                    if (parentPoint) {
                    updatedPoints = [parentPoint, ...alternatePoints];
                    }
                }
                if (updatedPoints.length > 0) {
                    this.createPlot(updatedPoints);
                    this.populateOverview(updatedPoints);
                }
                } catch (error) {
                console.error('Error updating alternate visualization:', error);
                }
            },
            
            /**
             * Handle category badge clicks.
             * @param {Event} e Click event.
             */
            handleCategoryBadgeClick(e) {
                if (this.isUpdatingVisuals) return;
                const badge = e.target;
                const category = badge.dataset.category;
                if (!category) return;
                document.querySelectorAll('.filter-badge').forEach(b => {
                b.classList.remove('active');
                b.style.opacity = '0.3';
                });
                if (this.activeCategories.size === 1 && this.activeCategories.has(category)) {
                this.activeCategories = new Set(['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building']);
                document.querySelectorAll('.filter-badge').forEach(b => {
                    b.classList.add('active');
                    b.style.opacity = '1';
                });
                } else {
                this.activeCategories = new Set([category]);
                badge.classList.add('active');
                badge.style.opacity = '1';
                }
                this.resetFilters(['scenarios', 'models', 'categories', 'alternates']);
                this.updateVisualization();
            },
            
            /**
             * Handle "read more" clicks in scenario cards.
             * @param {Event} e Click event.
             */
            handleReadMoreClick(e) {
                const card = e.target.closest('.comparison-card');
                if (!card) return;
                card.classList.toggle('expanded');
                e.target.textContent = card.classList.contains('expanded') ? 'Show less' : 'Read more';
            },
            
            /**
             * Reset specified filters.
             * @param {Array<string>} filters Filters to reset.
             */
            resetFilters(filters) {
                this.isUpdatingVisuals = true;
                try {
                if (filters.includes('scenarios')) {
                    this.selectedScenarios = [];
                    const scenarioFilter = document.getElementById('scenarioFilter');
                    if (scenarioFilter) scenarioFilter.selectedIndex = -1;
                }
                if (filters.includes('models')) {
                    this.selectedModels = [];
                    const modelFilter = document.getElementById('modelFilter');
                    if (modelFilter) modelFilter.selectedIndex = -1;
                }
                if (filters.includes('categories')) {
                    this.selectedCategories = [];
                    const categoryFilter = document.getElementById('categoryFilter');
                    if (categoryFilter) categoryFilter.selectedIndex = -1;
                }
                if (filters.includes('alternates')) {
                    this.selectedAlternateOutcomes = [];
                    const alternateOutcomes = document.getElementById('alternateOutcomes');
                    if (alternateOutcomes) {
                    alternateOutcomes.innerHTML = '<option disabled>Select one scenario and one model</option>';
                    alternateOutcomes.disabled = true;
                    }
                }
                } finally {
                this.isUpdatingVisuals = false;
                }
            },
            
            /**
             * Clear all filters and reset to initial state.
             */
            clearAllFilters() {
                this.isUpdatingVisuals = true;
                try {
                this.selectedModels = [];
                this.selectedScenarios = [];
                this.selectedCategories = [];
                this.selectedAlternateOutcomes = [];
                this.selectedComparison = [];
                this.activeCategories = new Set(['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building']);
                document.getElementById('modelFilter').selectedIndex = -1;
                document.getElementById('scenarioFilter').selectedIndex = -1;
                document.getElementById('categoryFilter').selectedIndex = -1;
                const alternateOutcomes = document.getElementById('alternateOutcomes');
                if (alternateOutcomes) {
                    alternateOutcomes.innerHTML = '<option disabled>Select one scenario and one model</option>';
                    alternateOutcomes.disabled = true;
                }
                document.querySelectorAll('.filter-badge').forEach(badge => {
                    badge.classList.add('active');
                    badge.style.opacity = '1';
                });
                document.querySelectorAll('.comparison-card').forEach(card => {
                    card.classList.remove('selected-card');
                });
                const scenarioAccordion = document.getElementById('scenarioAccordion');
                if (scenarioAccordion) {
                    scenarioAccordion.innerHTML = `
                    <div class="text-center text-muted p-3">
                        Select two scenario cards above to compare details
                    </div>
                    `;
                }
                const parentScenarios = ScenarioDataProcessor.dataPoints.filter(point => point.isParent);
                this.createPlot(parentScenarios);
                this.populateOverview(parentScenarios.slice(0, 4));
                this.updateSelectedMedia();
                } catch (error) {
                console.error('Error clearing filters:', error);
                } finally {
                this.isUpdatingVisuals = false;
                }
            },
            
            /**
             * Update selection UI for dropdown.
             * @param {HTMLElement} dropdown The dropdown element.
             * @param {Array<string>} selectedValues Values that should be selected.
             */
            updateSelectionUI(dropdown, selectedValues) {
                if (!dropdown) return;
                Array.from(dropdown.options).forEach(option => {
                option.selected = selectedValues.includes(option.value);
                });
            },
            
            /**
             * Update alternate outcomes dropdown based on selected scenario and model.
             */
            updateAlternateOutcomesDropdown() {
                const alternateOutcomes = document.getElementById('alternateOutcomes');
                if (!alternateOutcomes) return;
                try {
                if (this.selectedScenarios.length !== 1 || this.selectedModels.length !== 1) {
                    alternateOutcomes.innerHTML = '<option disabled>Select one scenario and one model</option>';
                    alternateOutcomes.disabled = true;
                    return;
                }
                const parentScenario = this.selectedScenarios[0];
                const selModel = this.selectedModels[0];
                const relationships = ScenarioDataProcessor.scenarioRelationships.get(parentScenario) || [];
                const alternatives = relationships.filter(child => child.model === selModel);
                if (alternatives && alternatives.length > 0) {
                    alternateOutcomes.setAttribute('multiple', 'true');
                    alternateOutcomes.size = Math.min(alternatives.length, 6);
                    const currentSelections = Array.from(alternateOutcomes.selectedOptions || [])
                    .map(opt => opt.value)
                    .filter(val => alternatives.some(alt => alt.childId === val));
                    alternateOutcomes.innerHTML = alternatives.map(alt => {
                    const isSelected = currentSelections.includes(alt.childId) ? 'selected' : '';
                    return `
                        <option value="${ScenarioDataProcessor.escapeHTML(alt.childId)}" ${isSelected}>
                        ${ScenarioDataProcessor.escapeHTML(alt.childId)} 
                        ${alt.relationshipType ? `(${ScenarioDataProcessor.escapeHTML(alt.relationshipType)})` : ''}
                        </option>
                    `;
                    }).join('');
                    alternateOutcomes.disabled = false;
                    alternateOutcomes.style.opacity = '1';
                } else {
                    alternateOutcomes.innerHTML = '<option disabled>No alternate outcomes available</option>';
                    alternateOutcomes.disabled = true;
                    alternateOutcomes.style.opacity = '0.5';
                }
                } catch (error) {
                console.error('Error updating alternate outcomes dropdown:', error);
                alternateOutcomes.innerHTML = '<option disabled>Error loading alternatives</option>';
                alternateOutcomes.disabled = true;
                }
            },
            
            /**
             * Master update visualization function.
             */
            updateVisualization() {
                if (this.isUpdatingVisuals) return;
                this.isUpdatingVisuals = true;
                try {
                let filteredPoints = [...ScenarioDataProcessor.dataPoints];
                if (this.activeCategories.size !== 6) {
                    filteredPoints = filteredPoints.filter(point =>
                    this.activeCategories.has(ScenarioDataProcessor.normalizeCategory(point.overallCategory))
                    );
                    this.updateFilterRelevance(filteredPoints);
                }
                if (this.selectedCategories.length > 0) {
                    filteredPoints = filteredPoints.filter(point =>
                    this.selectedCategories.includes(point.category)
                    );
                }
                if (this.selectedScenarios.length > 0) {
                    filteredPoints = filteredPoints.filter(point =>
                    this.selectedScenarios.includes(point.scenarioTitle)
                    );
                    this.updateModelRelevance(filteredPoints);
                }
                if (this.selectedModels.length > 0) {
                    filteredPoints = filteredPoints.filter(point =>
                    this.selectedModels.includes(point.llmName)
                    );
                    this.updateScenarioRelevance(filteredPoints);
                }
                if (filteredPoints.length === 0) {
                    this.showWarningMessage('No data points match the current filters.');
                    return;
                }
                if (this.selectedScenarios.length === 1 && this.selectedModels.length === 1 &&
                    this.selectedAlternateOutcomes.length > 0) {
                    const parentScenarioTitle = this.selectedScenarios[0];
                    const selModel = this.selectedModels[0];
                    const parentPoint = filteredPoints.find(p =>
                    p.scenarioTitle === parentScenarioTitle &&
                    p.llmName === selModel &&
                    p.isParent
                    );
                    if (parentPoint) {
                    let points = [parentPoint];
                    const rels = ScenarioDataProcessor.scenarioRelationships.get(parentScenarioTitle) || [];
                    const alternatePoints = rels
                        .filter(child =>
                        child.model === selModel &&
                        this.selectedAlternateOutcomes.includes(child.childId)
                        )
                        .map(child => child.data);
                    filteredPoints = [...points, ...alternatePoints];
                    }
                }
                this.updateScenarioColorMapping(filteredPoints);
                if (this.selectedScenarios.length > 0) {
                    const compData = filteredPoints.filter(point =>
                    this.selectedScenarios.includes(point.scenarioTitle)
                    );
                    this.populateOverview(compData);
                } else if (this.selectedModels.length === 2) {
                    const compData = this.selectedModels.map(model =>
                    filteredPoints.find(point => point.llmName === model)
                    ).filter(Boolean);
                    this.populateOverview(compData);
                } else {
                    const compData = filteredPoints.slice(0, 4);
                    this.populateOverview(compData);
                }
                if (this.selectedComparison.length === 2) {
                    const compData = ScenarioDataProcessor.dataPoints.filter(point =>
                    this.selectedComparison.includes(point.id)
                    );
                    this.populateScenarioDetails(compData);
                }
                this.createPlot(filteredPoints);
                this.updateSelectedMedia();
                this.updateUserSurveysPreview();
                } catch (error) {
                console.error('Error updating visualization:', error);
                this.showErrorMessage('Error updating visualization. Please try refreshing the page.');
                } finally {
                this.isUpdatingVisuals = false;
                }
            },
            
            /**
             * Update the user surveys preview section
             */
            async updateUserSurveysPreview() {
                const container = document.getElementById('user-surveys-preview');
                if (!container) return;
                
                try {
                    const isAuthenticated = await AuthManager.isUserAuthenticated();
                    
                    if (!isAuthenticated) {
                        container.innerHTML = `
                            <div class="login-prompt">
                                <span>Log in to view your analyses or <span class="login-link" id="login-to-analyze">create a new one</span></span>
                            </div>
                        `;
                        // Reattach event listener
                        const loginToAnalyzeLink = document.getElementById('login-to-analyze');
                        if (loginToAnalyzeLink) {
                            loginToAnalyzeLink.addEventListener('click', () => {
                                AuthManager.login();
                            });
                        }
                        return;
                    }
                    
                    // Get user surveys
                    try {
                        const userSurveys = await UserSurveyManager.getUserSurveys();
                        
                        if (!userSurveys || userSurveys.length === 0) {
                            container.innerHTML = `
                                <div class="no-surveys-message">
                                    You haven't submitted any analyses yet. 
                                    Click the "Analyze Scenario" button to get started.
                                </div>
                            `;
                            return;
                        }
                        
                        // Sort by date (newest first)
                        const sortedSurveys = [...userSurveys].sort((a, b) => {
                            const dateA = a.edits?.editDate ? new Date(a.edits.editDate) : 
                                         a.created ? new Date(a.created) : new Date(0);
                            const dateB = b.edits?.editDate ? new Date(b.edits.editDate) : 
                                         b.created ? new Date(b.created) : new Date(0);
                            return dateB - dateA;
                        });
                        
                        // Display most recent 5 surveys
                        const recentSurveys = sortedSurveys.slice(0, 5);
                        
                        const surveyItems = recentSurveys.map(survey => {
                            const title = ScenarioDataProcessor.escapeHTML(survey.metadata?.title || 'Untitled');
                            const date = new Date(survey.edits?.editDate || survey.created || Date.now()).toLocaleDateString();
                            
                            return `
                                <li data-survey-id="${ScenarioDataProcessor.escapeHTML(survey.id)}">
                                    <strong>${title}</strong>
                                    <span class="text-muted"> (${date})</span>
                                </li>
                            `;
                        }).join('');
                        
                        container.innerHTML = `
                            <ul class="user-surveys-list">
                                ${surveyItems}
                            </ul>
                        `;
                        
                        // Add click event listeners
                        document.querySelectorAll('.user-surveys-list li').forEach(item => {
                            item.addEventListener('click', () => {
                                const surveyId = item.getAttribute('data-survey-id');
                                if (surveyId) {
                                    UserSurveyManager.viewUserSurvey(surveyId);
                                }
                            });
                        });
                    } catch (error) {
                        console.error('Error loading user surveys preview:', error);
                        container.innerHTML = `
                            <div class="text-danger">
                                Error loading your analyses. Please try refreshing.
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error('Error checking authentication for survey preview:', error);
                }
            },

            updateFilterRelevance(filteredPoints) {
                try {
                const availScenarios = new Set(filteredPoints.map(p => p.scenarioTitle));
                const scenarioFilter = document.getElementById('scenarioFilter');
                if (scenarioFilter) {
                    Array.from(scenarioFilter.options).forEach(option => {
                    option.style.display = availScenarios.has(option.value) ? 'block' : 'none';
                    if (availScenarios.has(option.value)) option.classList.add('relevant-option');
                    else option.classList.remove('relevant-option');
                    });
                }
                const availModels = new Set(filteredPoints.map(p => p.llmName));
                const modelFilter = document.getElementById('modelFilter');
                if (modelFilter) {
                    Array.from(modelFilter.options).forEach(option => {
                    option.style.display = availModels.has(option.value) ? 'block' : 'none';
                    if (availModels.has(option.value)) option.classList.add('relevant-option');
                    else option.classList.remove('relevant-option');
                    });
                }
                const relCats = new Set(filteredPoints.map(point =>
                    ScenarioDataProcessor.normalizeCategory(point.overallCategory))
                );
                document.querySelectorAll('.filter-badge').forEach(badge => {
                    const cat = badge.dataset.category;
                    const hasFilters = this.selectedScenarios.length > 0 ||
                                    this.selectedModels.length > 0 ||
                                    this.activeCategories.size !== 6;
                    badge.style.opacity = hasFilters ? (relCats.has(cat) ? '1' : '0.3') : '1';
                    if (relCats.has(cat)) badge.classList.add('relevant-badge');
                    else badge.classList.remove('relevant-badge');
                });
                } catch (error) {
                console.error('Error updating filter relevance:', error);
                }
            },
            
            updateModelRelevance(filteredPoints) {
                try {
                const relModels = new Set(filteredPoints.map(p => p.llmName));
                const modelFilter = document.getElementById('modelFilter');
                if (modelFilter) {
                    Array.from(modelFilter.options).forEach(option => {
                    const isRelevant = relModels.has(option.value);
                    option.style.display = isRelevant ? 'block' : 'none';
                    if (isRelevant) {
                        option.classList.add('relevant-option');
                    } else {
                        option.classList.remove('relevant-option');
                        option.selected = false;
                    }
                    });
                }
                } catch (error) {
                console.error('Error updating model relevance:', error);
                }
            },
            
            updateScenarioRelevance(filteredPoints) {
                try {
                const relScenarios = new Set(filteredPoints.map(p => p.scenarioTitle));
                const scenarioFilter = document.getElementById('scenarioFilter');
                if (scenarioFilter) {
                    Array.from(scenarioFilter.options).forEach(option => {
                    const isRelevant = relScenarios.has(option.value);
                    option.style.display = isRelevant ? 'block' : 'none';
                    if (isRelevant) {
                        option.classList.add('relevant-option');
                    } else {
                        option.classList.remove('relevant-option');
                        option.selected = false;
                    }
                    });
                }
                } catch (error) {
                console.error('Error updating scenario relevance:', error);
                }
            },
            
            updateScenarioColorMapping(filteredPoints) {
                try {
                const uniqueCompositeKeys = [...new Set(filteredPoints.map(p =>
                    p.scenarioTitle + '_' + p.llmName
                ))];
                this.scenarioColorMapping = {};
                uniqueCompositeKeys.forEach((key, index) => {
                    this.scenarioColorMapping[key] = this.BORDER_COLORS[index % this.BORDER_COLORS.length];
                });
                } catch (error) {
                console.error('Error updating scenario color mapping:', error);
                this.scenarioColorMapping = {};
                }
            },
            
            createPlot(points) {
                try {
                const meshData = {
                    type: 'mesh3d',
                    x: [-8, 12, 12, -8, -8, 12, 12, -8],
                    y: [0, 0, 0, 0, 8, 8, 8, 8],
                    z: [-21.6, -21.6, 0, 0, -21.6, -21.6, 0, 0],
                    i: [0, 0, 4, 4, 0, 0, 2, 2, 0, 1],
                    j: [1, 2, 5, 6, 1, 5, 3, 7, 0, 2],
                    k: [2, 3, 6, 7, 5, 4, 7, 6, 3, 3],
                    opacity: 0.1,
                    color: 'lightblue',
                    showlegend: false,
                    hoverinfo: 'none'
                };

                let plotData = [meshData];
                const parentPoints = points.filter(p => p.isParent);
                const childPoints = points.filter(p => !p.isParent);
                parentPoints.forEach(parentPoint => {
                    const childrenOfParent = childPoints.filter(p => p.parentId === parentPoint.id);
                    childrenOfParent.forEach(childPoint => {
                    plotData.push({
                        type: 'scatter3d',
                        x: [parentPoint.x, childPoint.x],
                        y: [parentPoint.z, childPoint.z],
                        z: [parentPoint.y, childPoint.y],
                        mode: 'lines',
                        line: { color: '#666', width: 2, dash: 'dash' },
                        hoverinfo: 'text',
                        hovertext: `${parentPoint.scenarioTitle} → ${childPoint.scenarioTitle}`,
                        showlegend: false
                    });
                    });
                });
                plotData.push({
                    type: 'scatter3d',
                    x: points.map(p => p.x),
                    y: points.map(p => p.z),
                    z: points.map(p => p.y),
                    mode: 'markers',
                    marker: {
                    size: points.map(p => p.isParent ? 8 : 6),
                    color: points.map(p => this.getColorByCategory(p.overallCategory)),
                    opacity: 0.8,
                    line: {
                        color: points.map(p => (this.scenarioColorMapping && this.scenarioColorMapping[p.scenarioTitle + '_' + p.llmName]) || '#000'),
                        width: points.map(p => p.isParent ? 6 : 4)
                    }
                    },
                    text: points.map(p => `
                    <b>${p.scenarioTitle}</b><br>
                    <b>Category:</b> ${p.overallCategory}<br>
                    <b>Model:</b> ${p.llmName}<br>
                    ${p.isParent ? '<b>Type:</b> Parent' : '<b>Type:</b> Alternative'}
                    `),
                    hoverinfo: 'text',
                    showlegend: false
                });
                const layout = {
                    margin: { l: 0, r: 0, b: 0, t: 0 },
                    scene: {
                    xaxis: { title: 'Altruistic - Self Motivated', range: [-8, 12], titlefont: { size: 10 } },
                    yaxis: { title: 'Habit/Instinct - Will Power', range: [0, 8], titlefont: { size: 10 } },
                    zaxis: { title: 'Small Sacrifice - Large sacrifice', range: [-21.6, 0], titlefont: { size: 10 } },
                    camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } },
                    aspectmode: 'cube',
                    aspectratio: { x: 1, y: 1, z: 1 }
                    }
                };
                Plotly.newPlot('cube-plot', plotData, layout, {
                    displayModeBar: false,
                    responsive: true
                });
                } catch (error) {
                console.error('Error creating plot:', error);
                const plotElement = document.getElementById('cube-plot');
                if (plotElement) {
                    plotElement.innerHTML = `
                    <div class="alert alert-danger">
                        Error creating visualization. Please try refreshing the page.
                    </div>
                    `;
                }
                }
            },
            
            getColorByCategory(category) {
                const colorMap = {
                'evil': '#dc3545',
                'virtue': '#28a745',
                'vice': '#ffc107',
                'sin': '#6c757d',
                'morally_grey': '#6610f2',
                'world_building': '#17a2b8',
                'unknown': '#6c757d'
                };
                return colorMap[category.toLowerCase()] || 'gray';
            }
            };
            
            // Define global utility functions
            async function isUserAuthenticated() {
                return await AuthManager.isUserAuthenticated();
            }


            function showLoginPrompt() {
            alert('You need to be logged in to use this feature.');
            AuthManager.login();
            }

            document.addEventListener('DOMContentLoaded', async function() {
                try {
                    console.log('Starting application initialization...');
                    
                    // Define UserSurveyManager if it doesn't exist to prevent errors
                    if (typeof UserSurveyManager === 'undefined') {
                        window.UserSurveyManager = {
                            initialize: function() {
                                console.log('Default UserSurveyManager initialized');
                            },
                            loadUserSurveys: function() {
                                console.log('UserSurveyManager.loadUserSurveys placeholder');
                                return Promise.resolve([]);
                            }
                        };
                    }
                    
                    // First initialize auth manager
                    if (typeof AuthManager !== 'undefined' && AuthManager.initialize) {
                        await AuthManager.initialize().catch(error => {
                            console.warn('Auth initialization warning:', error);
                            // Continuing without auth is acceptable - user can login later
                        });
                    }
                    
                    // Then initialize data processor
                    if (typeof ScenarioDataProcessor !== 'undefined' && ScenarioDataProcessor.fetchScenarios) {
                        await ScenarioDataProcessor.fetchScenarios().catch(error => {
                            console.error('Error fetching initial data:', error);
                            // Show user-friendly error message
                            alert('Unable to load scenario data. Please refresh the page or try again later.');
                        });
                    }
                    
                    // Verify VisualizationManager methods exist before initializing
                    if (typeof VisualizationManager !== 'undefined') {
                        if (!VisualizationManager.attachComparisonCardHandlers) {
                            console.error('Missing required method: VisualizationManager.attachComparisonCardHandlers');
                        }
                        
                        if (!VisualizationManager.comparisonCardHandler) {
                            console.error('Missing required method: VisualizationManager.comparisonCardHandler');
                        }
                        
                        if (!VisualizationManager.checkDescriptions) {
                            console.error('Missing required method: VisualizationManager.checkDescriptions');
                        }
                        
                        // Initialize visualization manager
                        if (VisualizationManager.initialize) {
                            VisualizationManager.initialize();
                        }
                    }
                    
                    // Initialize user survey manager
                    if (typeof UserSurveyManager !== 'undefined' && UserSurveyManager.initialize) {
                        UserSurveyManager.initialize();
                    }
                    
                    // Set up auth button event listeners
                    document.getElementById('login')?.addEventListener('click', () => {
                        if (typeof AuthManager !== 'undefined' && AuthManager.login) {
                            AuthManager.login(false);
                        } else {
                            alert('Login functionality is not available at the moment.');
                        }
                    });
                    
                    document.getElementById('logout')?.addEventListener('click', () => {
                        if (typeof AuthManager !== 'undefined' && AuthManager.logout) {
                            AuthManager.logout();
                        } else {
                            alert('Logout functionality is not available at the moment.');
                        }
                    });
                    
                    // Update auth UI
                    if (typeof updateAuthUI === 'function') {
                        await updateAuthUI();
                    }
                    
                    console.log('Application initialization completed successfully');
                } catch (error) {
                    console.error('Error during application initialization:', error);
                    alert('There was a problem initializing the application. Please refresh the page.');
                }
            });

            /**
             * Enhanced version of updateAuthUI with better session handling
             */
            async function updateAuthUI() {
            try {
                // Check if auth client is initialized
                const authClient = await AuthManager.getClient().catch(() => null);
                if (!authClient) {
                console.warn('Auth client not available when updating UI');
                displayLoggedOutState();
                return;
                }
                
                // Force fresh check of authentication status if needed
                const isAuthenticated = await AuthManager.isUserAuthenticated();
                
                if (isAuthenticated) {
                try {
                    // Get user details with error handling
                    const user = await AuthManager.getUser();
                    displayLoggedInState(user);
                    
                    // Ensure token refresh is scheduled
                    AuthManager.scheduleTokenRefresh().catch(error => {
                    console.warn('Failed to schedule token refresh during UI update:', error);
                    });
                } catch (profileError) {
                    console.error('Error fetching user profile:', profileError);
                    // If profile fetch fails but we're authenticated, still show logged in state
                    displayLoggedInState(null);
                }
                } else {
                displayLoggedOutState();
                }
            } catch (error) {
                console.error('Error updating auth UI:', error);
                // Fallback to logged-out state on error
                displayLoggedOutState();
            }
            }
            /**
             * Display logged in state UI elements
             * @param {Object} user User profile data
             */
            function displayLoggedInState(user) {
            // Login/logout buttons
            const loginBtn = document.getElementById('login');
            const userContainer = document.getElementById('user-container');
            const userAvatar = document.getElementById('user-avatar');
            const logoutBtn = document.getElementById('logout');
            
            if (loginBtn) loginBtn.style.display = 'none';
            if (userContainer) userContainer.classList.remove('d-none');
            if (logoutBtn) logoutBtn.style.display = 'block';
            
            // Set avatar if available
            if (user?.picture && userAvatar) {
                userAvatar.src = user.picture;
                userAvatar.style.display = 'block';
            }
            
            // Show authenticated-only elements
            document.querySelectorAll('.auth-only').forEach(el => {
                el.style.display = 'block';
            });
            
            // Update user surveys preview
            if (typeof VisualizationManager !== 'undefined' && 
                VisualizationManager.updateUserSurveysPreview) {
                VisualizationManager.updateUserSurveysPreview();
            }
            }

            /**
             * Display logged out state UI elements
             */
            function displayLoggedOutState() {
            // Login/logout buttons
            const loginBtn = document.getElementById('login');
            const userContainer = document.getElementById('user-container');
            const userAvatar = document.getElementById('user-avatar');
            const logoutBtn = document.getElementById('logout');
            
            if (loginBtn) loginBtn.style.display = 'block';
            if (userContainer) userContainer.classList.add('d-none');
            if (logoutBtn) logoutBtn.style.display = 'none';
            if (userAvatar) userAvatar.style.display = 'none';
            
            // Hide authenticated-only elements
            document.querySelectorAll('.auth-only').forEach(el => {
                el.style.display = 'none';
            });
            
            // Update user surveys preview for logged out state
            if (typeof VisualizationManager !== 'undefined' && 
                VisualizationManager.updateUserSurveysPreview) {
                VisualizationManager.updateUserSurveysPreview();
            }
            
            // Clear token refresh timer in AuthManager
            if (AuthManager.tokenRefreshTimer) {
                clearTimeout(AuthManager.tokenRefreshTimer);
                AuthManager.tokenRefreshTimer = null;
            }
            }
            // Extension of VisualizationManager object with the remaining methods
            Object.assign(VisualizationManager, {
                /**
                 * Populate overview cards with scenario data.
                 * @param {Array} data Data for overview cards.
                 */
                populateOverview(data) {
                    try {
                        const overviewDiv = document.getElementById('overview');
                        if (!overviewDiv) return;
                        
                        if (!Array.isArray(data)) {
                            data = [data];
                        }
                        
                        // Sort data to show parent scenarios first
                        data.sort((a, b) => (b.isParent ? 1 : 0) - (a.isParent ? 1 : 0));
                        data = data.slice(0, 4); // Limit to 4 items
                        
                        const getEthicsScores = (item) => {
                            try {
                                if (!item.dimensions) {
                                    return {
                                        deontologyScore: 'N/A',
                                        utilitarianismScore: 'N/A',
                                        virtueEthicsScore: 'N/A'
                                    };
                                }
                                
                                const philosophyDimension = item.dimensions.find(dim => 
                                    dim.id.trim().toLowerCase() === 'philosophical analysis' ||
                                    dim.id.trim().toLowerCase() === 'philosophicalanalysis'
                                );
                                
                                if (!philosophyDimension || !philosophyDimension.questions) {
                                    return {
                                        deontologyScore: 'N/A',
                                        utilitarianismScore: 'N/A',
                                        virtueEthicsScore: 'N/A'
                                    };
                                }
                                
                                const scores = {};
                                philosophyDimension.questions.forEach(q => {
                                    const questionType = q.question.trim().toLowerCase();
                                    if (questionType === 'deontology') {
                                        scores.deontologyScore = q.score;
                                    } else if (questionType === 'utilitarianism') {
                                        scores.utilitarianismScore = q.score;
                                    } else if (questionType === 'virtue ethics') {
                                        scores.virtueEthicsScore = q.score;
                                    }
                                });
                                
                                return scores;
                            } catch (error) {
                                console.error('Error extracting ethics scores:', error);
                                return {
                                    deontologyScore: 'N/A',
                                    utilitarianismScore: 'N/A',
                                    virtueEthicsScore: 'N/A'
                                };
                            }
                        };
                        
                        const getCategoryBadge = (category) => {
                            let normalizedCategory = category.toLowerCase().replace(/\s+/g, '-');
                            if (normalizedCategory === 'morally_grey' || normalizedCategory === 'morally-grey') {
                                normalizedCategory = 'morally-grey';
                            }
                            const categoryClass = `category-badge category-${normalizedCategory}`;
                            return `<span class="${categoryClass}">${ScenarioDataProcessor.escapeHTML(category)}</span>`;
                        };
                        
                        const getScenarioTitle = (item) => {
                            // Only include the link if a nonempty URL exists
                            if (item.url && item.url.trim() !== "") {
                                return `${ScenarioDataProcessor.escapeHTML(item.scenarioTitle)} 
                                        <a href="${ScenarioDataProcessor.escapeHTML(item.url)}" target="_blank" class="scenario-link">
                                        <i class="fas fa-external-link-alt"></i>
                                        </a>`;
                            }
                            return ScenarioDataProcessor.escapeHTML(item.scenarioTitle);
                        };
                        
                        const cards = data.map(item => {
                            const scores = getEthicsScores(item);
                            const borderColor = this.scenarioColorMapping[item.scenarioTitle + '_' + item.llmName] || '#000';
                            
                            return `
                                <div class="comparison-card" 
                                    data-scenario-id="${ScenarioDataProcessor.escapeHTML(item.id)}" 
                                    style="border: 2px solid ${borderColor};">
                                    <h4>
                                        ${getScenarioTitle(item)}
                                        <small>(${ScenarioDataProcessor.escapeHTML(item.llmName)} ${getCategoryBadge(item.overallCategory)})</small>
                                    </h4>
                                    <div class="scenario-description">
                                        <span class="description-text">
                                            ${ScenarioDataProcessor.escapeHTML(item.scenarioDescription || 'No description available')}
                                        </span>
                                        <span class="read-more">Read more</span>
                                    </div>
                                    <div class="ethics-scores">
                                        <div>Deontology: ${ScenarioDataProcessor.escapeHTML(String(scores.deontologyScore))}</div>
                                        <div>Utilitarianism: ${ScenarioDataProcessor.escapeHTML(String(scores.utilitarianismScore))}</div>
                                        <div>Virtue Ethics: ${ScenarioDataProcessor.escapeHTML(String(scores.virtueEthicsScore))}</div>
                                    </div>
                                </div>
                            `;
                        }).join('');
                        
                        overviewDiv.innerHTML = cards;
                        
                        // Restore selection state
                        document.querySelectorAll('.comparison-card').forEach(card => {
                            const id = card.getAttribute('data-scenario-id');
                            if (this.selectedComparison.includes(id)) {
                                card.classList.add('selected-card');
                            }
                        });
                        
                        // Check description lengths for "read more" visibility
                        this.checkDescriptions();
                        
                        // Attach event handlers to cards
                        this.attachComparisonCardHandlers();
                    } catch (error) {
                        console.error('Error populating overview:', error);
                        
                        const overviewDiv = document.getElementById('overview');
                        if (overviewDiv) {
                            overviewDiv.innerHTML = `
                                <div class="alert alert-danger">
                                    Error loading scenario cards. Please try refreshing the page.
                                </div>
                            `;
                        }
                    }
                },
                /**
                 * Handle analyze scenario button click
                 */
                handleAnalyzeScenarioClick: async function() {
                    try {
                        console.log('Handling analyze scenario click');
                        const isAuthenticated = await AuthManager.isUserAuthenticated();
                        if (!isAuthenticated) {
                            // Show login prompt
                            alert('Please log in to analyze scenarios');
                            AuthManager.login();
                            return;
                        }
                        
                        // Load available scenarios
                        await this.loadScenariosForAnalysis();
                        
                        // Show the scenario selection modal
                        $('#scenarioSelectModal').modal('show');
                    } catch (error) {
                        console.error('Error handling analyze scenario click:', error);
                        alert('An error occurred. Please try again.');
                    }
                },

                /**
                 * Load scenarios for analysis selection
                 */
                 loadScenariosForAnalysis: async function() {
                    console.log('Loading scenarios for analysis');
                    const scenariosBody = document.getElementById('scenarios-body');
                    if (!scenariosBody) {
                        console.error('Scenarios body element not found');
                        return;
                    }
                    
                    try {
                        // Show loading state
                        scenariosBody.innerHTML = '<tr><td colspan="5" class="text-center">Loading scenarios...</td></tr>';
                        
                        // Get all parent scenarios (to prevent duplicates)
                        const scenarios = ScenarioDataProcessor.displayPoints.filter(s => s.isParent) || [];
                        
                        if (scenarios.length === 0) {
                            scenariosBody.innerHTML = '<tr><td colspan="5" class="text-center">No scenarios available</td></tr>';
                            return;
                        }
                        
                        // Group scenarios by title to avoid duplicates
                        const uniqueScenarios = [];
                        const seenTitles = new Set();
                        
                        scenarios.forEach(scenario => {
                            if (!seenTitles.has(scenario.scenarioTitle)) {
                                seenTitles.add(scenario.scenarioTitle);
                                uniqueScenarios.push(scenario);
                            }
                        });
                        
                        // Sort scenarios by title
                        const sortedScenarios = uniqueScenarios.sort((a, b) => 
                            a.scenarioTitle.localeCompare(b.scenarioTitle));
                        
                        // Get currently selected scenario if any
                        const currentlySelected = this.selectedScenarios.length > 0 ? 
                            this.selectedScenarios[0] : null;
                        
                        // Create rows for each scenario
                        const rows = sortedScenarios.map(scenario => {
                            // Check if this is the currently selected scenario
                            const isSelected = scenario.scenarioTitle === currentlySelected;
                            
                            return `
                                <tr class="${isSelected ? 'table-primary' : ''}">
                                    <td>${ScenarioDataProcessor.escapeHTML(scenario.scenarioTitle)}</td>
                                    <td>${ScenarioDataProcessor.escapeHTML(scenario.category)}</td>
                                    <td>
                                        <button class="btn btn-sm btn-primary analyze-btn" 
                                                data-scenario-id="${ScenarioDataProcessor.escapeHTML(scenario.id)}"
                                                data-scenario-title="${ScenarioDataProcessor.escapeHTML(scenario.scenarioTitle)}">
                                            ${isSelected ? 'Currently Selected' : 'Select'}
                                        </button>
                                    </td>
                                </tr>
                            `;
                        }).join('');
                        
                        scenariosBody.innerHTML = rows;
                        
                        // Add event listeners to the analyze buttons
                        document.querySelectorAll('.analyze-btn').forEach(btn => {
                            btn.addEventListener('click', (e) => {
                                const scenarioId = e.target.getAttribute('data-scenario-id');
                                const scenarioTitle = e.target.getAttribute('data-scenario-title');
                                if (scenarioId && scenarioTitle) {
                                    // First show model selection modal
                                    this.showModelSelectionModal(scenarioId, scenarioTitle);
                                }
                            });
                        });
                        
                        // Set up search functionality
                        const searchInput = document.getElementById('scenario-search');
                        if (searchInput) {
                            searchInput.value = ''; // Clear previous search
                            searchInput.focus();
                            
                            // Add search functionality
                            searchInput.addEventListener('input', () => {
                                const searchText = searchInput.value.toLowerCase();
                                document.querySelectorAll('#scenarios-body tr').forEach(row => {
                                    const title = row.cells[0]?.textContent.toLowerCase() || '';
                                    const category = row.cells[1]?.textContent.toLowerCase() || '';
                                    row.style.display = (title.includes(searchText) || category.includes(searchText)) ? '' : 'none';
                                });
                            });
                        }
                        
                    } catch (error) {
                        console.error('Error loading scenarios for analysis:', error);
                        scenariosBody.innerHTML = '<tr><td colspan="5" class="text-center text-danger">Error loading scenarios</td></tr>';
                    }
                },

                /**
                 * Select scenario for analysis
                 * @param {string} scenarioId ID of scenario to analyze
                 */
                 selectScenarioForAnalysis: function(scenarioId, useModelAnswers = false) {
                    try {
                        console.log('Selecting scenario for analysis:', scenarioId);
                        // Find the scenario in data points
                        const scenario = ScenarioDataProcessor.dataPoints.find(p => p.id === scenarioId);
                        if (!scenario) {
                            console.error('Scenario not found:', scenarioId);
                            return;
                        }
                        
                        console.log('Selected scenario for analysis:', scenario.scenarioTitle);
                        
                        // Extend UserSurveyManager with enhanced scenario preparation
                        if (!UserSurveyManager.prepareScenarioForAnalysis) {
                            UserSurveyManager.prepareScenarioForAnalysis = function(scenario, useModelAnswers) {
                                try {
                                    console.log('Preparing scenario for analysis:', scenario.scenarioTitle);
                                    
                                    // Try to reset form first
                                    if (typeof this.resetSurveyForm === 'function') {
                                        this.resetSurveyForm();
                                    }
                                    
                                    // Set scenario data in form
                                    document.getElementById('scenario-id').value = scenario.id;
                                    document.getElementById('scenario-title-display').value = scenario.scenarioTitle;
                                    document.getElementById('scenario-description-display').value = scenario.scenarioDescription || '';
                                    document.getElementById('scenario-category-display').value = scenario.category || '';
                                    document.getElementById('scenario-type').value = 'analysis';
                                    document.getElementById('scenario-parent-id').value = scenario.isParent ? scenario.id : (scenario.parentId || '');
                                    document.getElementById('scenario-url').value = scenario.url || '';
                                    
                                    // Set classification if available
                                    if (scenario.overallCategory && document.getElementById('moral-classification')) {
                                        const classSelect = document.getElementById('moral-classification');
                                        const normalizedCategory = scenario.overallCategory.toLowerCase().replace(/\s+/g, '_');
                                        
                                        // Find matching option
                                        Array.from(classSelect.options).forEach(option => {
                                            if (option.value.toLowerCase() === normalizedCategory) {
                                                option.selected = true;
                                            }
                                        });
                                    }
                                    
                                    // If using model answers, populate form with those values
                                    if (useModelAnswers && scenario.dimensions) {
                                        this.populateModelAnswers(scenario);
                                    }
                                    
                                    // Reset tab to first tab if possible
                                    if (typeof this.currentTabIndex !== 'undefined' && typeof this.updateTabDisplay === 'function') {
                                        this.currentTabIndex = 0;
                                        this.updateTabDisplay();
                                    }
                                    
                                    // Update UI to show we're analyzing an existing scenario
                                    const modalTitle = document.getElementById('surveyModalLabel');
                                    if (modalTitle) {
                                        modalTitle.textContent = useModelAnswers ? 
                                            `${scenario.llmName} Analysis: ${scenario.scenarioTitle}` : 
                                            `Analyze: ${scenario.scenarioTitle}`;
                                    }
                                    
                                    // Add helper text if using model answers
                                    if (useModelAnswers) {
                                        const headerNotice = document.createElement('div');
                                        headerNotice.className = 'alert alert-info mb-3';
                                        headerNotice.innerHTML = `
                                            <i class="fas fa-info-circle mr-2"></i> 
                                            You're viewing ${scenario.llmName}'s analysis. You can adjust any values 
                                            to create your own version.
                                        `;
                                        
                                        const modalBody = document.querySelector('#surveyModal .modal-body');
                                        if (modalBody && modalBody.firstChild) {
                                            modalBody.insertBefore(headerNotice, modalBody.firstChild);
                                        }
                                    }
                                    
                                    console.log('Scenario prepared for analysis:', scenario.scenarioTitle);
                                    
                                    // Enhance survey UI with sliders and better scrolling
                                    this.enhanceSurveyUI();
                                    this.removeEditCheckboxes();
                                    this.initializeChangeTracking();
                                    this.ensureFormFieldsEditable();
                                    
                                    
                                } catch (error) {
                                    console.error('Error preparing scenario for analysis:', error);
                                    console.log("Scenario prepared:", {
                                    scenarioId: document.getElementById('scenario-id')?.value,
                                    scenarioTitle: document.getElementById('scenario-title-display')?.value,
                                    moralClassification: document.getElementById('moral-classification')?.value
                                })}
                            };
                            
                            // Add helper method to populate model answers
                            UserSurveyManager.populateModelAnswers = function(scenario) {
                                try {
                                    if (!scenario.dimensions) return;
                                    
                                    // Map of dimension IDs to tab IDs
                                    const dimensionTabMap = {
                                        'Ends': 'ends',
                                        'Means': 'means',
                                        'Character': 'character',
                                        'PhilosophicalAnalysis': 'philosophy'
                                    };
                                    
                                    // Map of question IDs to form field IDs
                                    const questionFieldMap = {
                                        'Societal Needs': 'societal-needs',
                                        'Others Needs': 'others-needs',
                                        'Others Wants': 'others-wants',
                                        'Personal Needs': 'personal-needs',
                                        'Personal Wants': 'personal-wants',
                                        'Future Self-Sacrifice': 'future-sacrifice',
                                        'Number of Individuals Affected': 'individuals-affected',
                                        'Type of Sacrifice': 'sacrifice-type',
                                        'Duration of Sacrifice': 'sacrifice-duration',
                                        'Magnitude of Life Impacted': 'life-magnitude',
                                        'Unconscious vs Conscious': 'consciousness',
                                        'Present Self-Sacrifice': 'present-sacrifice',
                                        'Habit vs Will Power': 'willpower',
                                        'Unintentional vs Intentional': 'intentionality',
                                        'Wills at Play': 'wills',
                                        'Deontology': 'deontology',
                                        'Utilitarianism': 'utilitarianism',
                                        'Virtue Ethics': 'virtue-ethics'
                                    };
                                    
                                    // Process each dimension and its questions
                                    scenario.dimensions.forEach(dimension => {
                                        const tabId = dimensionTabMap[dimension.id];
                                        if (!tabId) return;
                                        
                                        (dimension.questions || []).forEach(question => {
                                            const fieldBase = questionFieldMap[question.question];
                                            if (!fieldBase) return;
                                            
                                            // Set score field
                                            const scoreField = document.getElementById(`${fieldBase}-score`);
                                            if (scoreField && question.score !== undefined) {
                                                scoreField.value = question.score;
                                                
                                                // Update slider if it exists
                                                const slider = document.getElementById(`${fieldBase}-slider`);
                                                if (slider) {
                                                    slider.value = question.score;
                                                }
                                            }
                                            
                                            // Set justification field
                                            const justField = document.getElementById(`${fieldBase}-justification`);
                                            if (justField && question.justification) {
                                                justField.value = question.justification;
                                            }
                                            
                                            // For philosophy questions
                                            if (tabId === 'philosophy') {
                                                // Handle philosophy questions with select elements
                                                if (fieldBase === 'deontology' || fieldBase === 'utilitarianism' || fieldBase === 'virtue-ethics') {
                                                    const select = document.getElementById(`${fieldBase}-score`);
                                                    const justification = document.getElementById(`${fieldBase}-justification`);
                                                    
                                                    if (select && question.score) {
                                                        // Make sure score is treated as string for comparison with option values
                                                        const scoreValue = String(question.score);
                                                        
                                                        // Set dropdown value
                                                        Array.from(select.options).forEach(option => {
                                                            if (option.value === scoreValue) {
                                                                option.selected = true;
                                                            }
                                                        });
                                                    }
                                                    // Ensure justification is populated
                                                    if (justification && question.justification) {
                                                        justification.value = question.justification;
                                                    }
                                                }
                                            }
                                        });
                                    });
                                    
                                    // Set classification justification if available
                                    if (scenario.metadata?.classification?.justification) {
                                        const justField = document.getElementById('classification-justification');
                                        if (justField) {
                                            justField.value = scenario.metadata.classification.justification;
                                        }
                                    }
                                } catch (error) {
                                    console.error('Error populating model answers:', error);
                                }
                            };
                            
                            // Add method to enhance survey UI
                            UserSurveyManager.enhanceSurveyUI = function() {
                                document.querySelectorAll('[id$="-slider-container"]').forEach(container => {
                                    container.remove();
                                });
                                try {
                                    // Make modal scrollable and larger
                                    const modalDialog = document.querySelector('#surveyModal .modal-dialog');
                                    if (modalDialog) {
                                        modalDialog.classList.add('modal-dialog-scrollable');
                                        
                                        // Remove any existing max-height style
                                        const modalBody = document.querySelector('#surveyModal .modal-body');
                                        if (modalBody) {
                                            modalBody.style.maxHeight = 'none';
                                            modalBody.style.overflow = 'initial';
                                        }
                                    }
                                    
                                    // Add sliders for numeric inputs
                                    document.querySelectorAll('#surveyTabContent input[type="number"]').forEach(input => {
                                        const inputId = input.id;
                                        const baseId = inputId.replace('-score', '');
                                        
                                        // Create slider container
                                        const sliderContainer = document.createElement('div');
                                        sliderContainer.className = 'form-group mt-2';
                                        
                                        // Get min/max values from input
                                        const min = parseFloat(input.min) || 0;
                                        const max = parseFloat(input.max) || 4;
                                        const step = parseFloat(input.step) || 0.1;
                                        
                                        // Create slider
                                        const slider = document.createElement('input');
                                        slider.type = 'range';
                                        slider.className = 'form-control-range';
                                        slider.id = `${baseId}-slider`;
                                        slider.min = min;
                                        slider.max = max;
                                        slider.step = step;
                                        slider.value = input.value || 0;
                                        
                                        // Add slider label
                                        const sliderLabel = document.createElement('label');
                                        sliderLabel.htmlFor = slider.id;
                                        sliderLabel.className = 'd-flex justify-content-between';
                                        sliderLabel.innerHTML = `
                                            <small class="text-left">${min}</small>
                                            <small class="text-center">Adjust Value</small>
                                            <small class="text-right">${max}</small>
                                        `;
                                        
                                        // Add event listeners
                                        slider.addEventListener('input', () => {
                                            input.value = slider.value;
                                        });
                                        
                                        input.addEventListener('input', () => {
                                            slider.value = input.value;
                                        });
                                        
                                        // Add slider to container
                                        sliderContainer.appendChild(sliderLabel);
                                        sliderContainer.appendChild(slider);
                                        
                                        // Add slider after input's form group
                                        const inputGroup = input.closest('.form-group');
                                        if (inputGroup && inputGroup.nextElementSibling) {
                                            inputGroup.parentNode.insertBefore(sliderContainer, inputGroup.nextElementSibling);
                                        }
                                    });
                                    
                                    // Enhance the progress bar
                                    this.updateProgressBar();
                                    
                                } catch (error) {
                                    console.error('Error enhancing survey UI:', error);
                                }
                            };
                        }
                        
                        // Pre-populate survey form with scenario data
                        UserSurveyManager.prepareScenarioForAnalysis(scenario, useModelAnswers);
                        
                        // Show the survey modal
                        $('#surveyModal').modal('show');
                    } catch (error) {
                        console.error('Error selecting scenario for analysis:', error);
                        alert('Error selecting scenario. Please try again.');
                    }
                },
                /**
                 * Check if descriptions need "read more" links
                 */
                checkDescriptions() {
                    document.querySelectorAll('.scenario-description').forEach(function(desc) {
                        const textEl = desc.querySelector('.description-text');
                        const readMoreLink = desc.querySelector('.read-more');
                        
                        if (!textEl || !readMoreLink) return;
                        
                        // Compare scrollHeight (full content height) with clientHeight (visible height)
                        if (textEl.scrollHeight <= textEl.clientHeight) {
                            // Content fits, hide the read more link
                            readMoreLink.style.display = 'none';
                        } else {
                            readMoreLink.style.display = 'block';
                        }
                    });
                },

                /**
                 * Populate scenario details for comparison
                 * @param {Array} scenarioData Scenarios to compare
                 */
                populateScenarioDetails(scenarioData) {
                    try {
                        // Normalize input to array and limit to 2 scenarios for comparison
                        if (!Array.isArray(scenarioData)) {
                            scenarioData = [scenarioData];
                        }
                        if (scenarioData.length > 2) {
                            scenarioData = scenarioData.slice(0, 2);
                        }
                        
                        const scenarioAccordion = document.getElementById('scenarioAccordion');
                        if (!scenarioAccordion) return;
                        
                        // Early return if no valid data
                        if (!scenarioData.length || !scenarioData[0].dimensions) {
                            scenarioAccordion.innerHTML = '<div class="alert alert-info">No scenario data available.</div>';
                            return;
                        }
                        
                        // Get dimension score helper
                        function getDimensionScore(scenario, dimensionId) {
                            if (!['Ends', 'Means', 'Character'].includes(dimensionId)) return null;
                            
                            const scores = {
                                'Ends': scenario.x,
                                'Means': scenario.y,
                                'Character': scenario.z
                            };
                            return scores[dimensionId]?.toFixed(2) ?? null;
                        }
                        
                        // Get range value helper
                        function getRange(dimensionId, questionIndex) {
                            const rangeMap = {
                                'Ends': {
                                default: questionIndex < 3 ? "0 to 4" : "0 to -4"
                                },
                                'Means': {
                                0: "0 to -4",
                                1: "0 to -6",
                                2: "0 to -4",
                                3: "0 to -4",
                                4: "0.01 to 1.2"
                                },
                                'Character': {
                                0: "0 to 1",
                                1: "0 to 2",
                                2: "0 to 4",
                                3: "0 to 1"
                                }
                            };
                            
                            return rangeMap[dimensionId]?.[questionIndex] || 
                                    rangeMap[dimensionId]?.default || 
                                    "N/A";
                        }
                        
                        // Build table structure helper
                        function getTableStructure(isPhilosophical) {
                            if (isPhilosophical) {
                                return {
                                colgroup: `
                                    <col style="width:25%;">
                                    <col style="width:25%;">
                                    <col style="width:50%;">
                                `,
                                header: `
                                    <tr>
                                    <th>Question</th>
                                    <th>Score</th>
                                    <th>Justification</th>
                                    </tr>
                                `
                                };
                            }
                            
                            return {
                                colgroup: `
                                <col style="width:10%;">
                                <col style="width:10%;">
                                <col style="width:12.5%;">
                                <col style="width:70%;">
                                `,
                                header: `
                                <tr>
                                    <th>Question</th>
                                    <th>Score</th>
                                    <th>Range</th>
                                    <th>Justification</th>
                                </tr>
                                `
                            };
                        }
                        
                        // Create question row helper
                        function createQuestionRow(question, tooltip, range, isPhilosophical) {
                            const tooltipHTML = tooltip ? `
                                <div style="display: inline-flex; align-items: center; gap: 4px;">
                                <span class="tooltip-container">
                                    <i class="fas fa-info-circle tooltip-icon" aria-hidden="true"></i>
                                    <span class="tooltip-content" role="tooltip">${ScenarioDataProcessor.escapeHTML(tooltip.info)}</span>
                                </span>
                                <span class="tooltip-container">
                                    <i class="fas fa-question-circle tooltip-icon" aria-hidden="true"></i>
                                    <span class="tooltip-content" role="tooltip">${ScenarioDataProcessor.escapeHTML(tooltip.question)}</span>
                                </span>
                                </div>
                            ` : '';
                            
                            const score = typeof question.score === 'number' ? 
                                question.score.toFixed(1) : question.score;
                            
                            if (isPhilosophical) {
                                return `
                                <tr>
                                    <td>${ScenarioDataProcessor.escapeHTML(question.question)}${tooltipHTML}</td>
                                    <td>${ScenarioDataProcessor.escapeHTML(String(score))}</td>
                                    <td>${ScenarioDataProcessor.escapeHTML(question.justification)}</td>
                                </tr>
                                `;
                            }
                            
                            return `
                                <tr>
                                <td>${ScenarioDataProcessor.escapeHTML(question.question)}${tooltipHTML}</td>
                                <td>${ScenarioDataProcessor.escapeHTML(String(score))}</td>
                                <td>${ScenarioDataProcessor.escapeHTML(range)}</td>
                                <td>${ScenarioDataProcessor.escapeHTML(question.justification)}</td>
                                </tr>
                            `;
                        }
                        
                        // Create scenario table helper
                        function createScenarioTable(scenario, dimension, isPhilosophical, dimensionId, tableStructure) {
                            const dimensionScore = getDimensionScore(scenario, dimension.id);
                            const scoreDisplay = dimensionScore !== null && 
                                ['Ends', 'Means', 'Character'].includes(dimension.id) ?
                                ` (${dimension.id} Score: ${dimensionScore})` : '';
                            
                            const questionRows = (dimension.questions || []).map((question, index) => {
                                const range = !isPhilosophical ? getRange(dimension.id, index) : "N/A";
                                const tooltip = window.questionTooltips?.[question.question] || null;
                                return createQuestionRow(question, tooltip, range, isPhilosophical);
                            }).join('');
                            
                            return `
                                <div class="col-md-${scenarioData.length === 1 ? '12' : '6'} scenario-table-container">
                                <h5 class="mb-3">${ScenarioDataProcessor.escapeHTML(scenario.scenarioTitle)} 
                                    (${ScenarioDataProcessor.escapeHTML(scenario.llmName)})${scoreDisplay}</h5>
                                <table class="table table-bordered compact-table">
                                    <colgroup>${tableStructure.colgroup}</colgroup>
                                    <thead>${tableStructure.header}</thead>
                                    <tbody>${questionRows}</tbody>
                                </table>
                                </div>
                            `;
                        }
                        
                        // Main content generation
                        if (!scenarioData[0].dimensions || !Array.isArray(scenarioData[0].dimensions)) {
                            scenarioAccordion.innerHTML = '<div class="alert alert-info">No dimension data available for this scenario.</div>';
                            return;
                        }
                        
                        const dimensionContent = scenarioData[0].dimensions.map((dimension, index) => {
                            const dimensionId = `dimension${index}`;
                            const collapseId = `collapse${index}`;
                            const dimensionIdLower = String(dimension.id || '').trim().toLowerCase();
                            const isPhilosophical = dimensionIdLower === 'philosophical analysis' || 
                                                    dimensionIdLower === 'philosophicalanalysis';
                            const tableStructure = getTableStructure(isPhilosophical);
                            
                            // Ensure second scenario has matching dimension
                            const hasBothDimensions = scenarioData.length === 2 && 
                                                        scenarioData[1].dimensions && 
                                                        scenarioData[1].dimensions[index];
                            
                            // Create tables for each scenario
                            const scenarioTables = scenarioData
                                .filter((_, i) => i === 0 || hasBothDimensions)
                                .map(scenario => {
                                // Get matching dimension from this scenario
                                const scenarioDimension = scenario.dimensions[index];
                                if (!scenarioDimension) return '';
                                
                                return createScenarioTable(
                                    scenario, 
                                    scenarioDimension, 
                                    isPhilosophical, 
                                    dimensionId, 
                                    tableStructure
                                );
                                }).join('');
                            
                            return `
                                <div class="card">
                                <div class="card-header" id="${dimensionId}-header">
                                    <h2 class="mb-0">
                                    <button class="btn btn-link ${index === 0 ? '' : 'collapsed'}" 
                                            type="button" 
                                            data-toggle="collapse" 
                                            data-target="#${collapseId}">
                                        <strong>${ScenarioDataProcessor.escapeHTML(dimension.id)} 
                                        (${ScenarioDataProcessor.escapeHTML(dimension.label || '')})</strong>
                                    </button>
                                    </h2>
                                </div>
                                <div id="${collapseId}" 
                                    class="collapse ${index === 0 ? 'show' : ''}" 
                                    data-parent="#scenarioAccordion">
                                    <div class="card-body">
                                    <div class="row">
                                        ${scenarioTables}
                                    </div>
                                    </div>
                                </div>
                                </div>
                            `;
                        }).join('');
                        
                        scenarioAccordion.innerHTML = dimensionContent;
                    } catch (error) {
                        console.error('Error populating scenario details:', error);
                        
                        const scenarioAccordion = document.getElementById('scenarioAccordion');
                        if (scenarioAccordion) {
                            scenarioAccordion.innerHTML = `
                                <div class="alert alert-danger">
                                Error loading scenario details. Please try refreshing the page.
                                </div>
                            `;
                        }
                    }
                },
                
                /**
                 * Initialize media display controls
                 */
                initializeMediaControls() {
                    // Open in new window button
                    const openMediaBtn = document.getElementById('open-media');
                    if (openMediaBtn) {
                        openMediaBtn.addEventListener('click', () => {
                            if (this.currentMediaUrl) {
                                window.open(this.currentMediaUrl, '_blank');
                            }
                        });
                    }
                },
                
                /**
                 * Attach event handlers to comparison cards
                 */
                attachComparisonCardHandlers() {
                    console.log('Attaching comparison card handlers');
                    document.querySelectorAll('.comparison-card').forEach(card => {
                        // Remove existing handlers to prevent duplicates
                        card.removeEventListener('click', this.comparisonCardHandler);
                        
                        // Add handler
                        card.addEventListener('click', this.comparisonCardHandler.bind(this));
                    });
                },
                
                /**
                 * Comparison card click handler
                 * @param {Event} event Click event
                 */
                comparisonCardHandler(event) {
                    try {
                        const card = event.currentTarget;
                        if (!card) return;
                        
                        const id = card.getAttribute('data-scenario-id');
                        if (!id) return;
                        
                        // If already selected, unselect it
                        if (card.classList.contains('selected-card')) {
                            card.classList.remove('selected-card');
                            this.selectedComparison = this.selectedComparison.filter(selectedId => selectedId !== id);
                        } else {
                            // If already have 2 selected, clear all first
                            if (this.selectedComparison.length >= this.MAX_COMPARISON) {
                                document.querySelectorAll('.comparison-card').forEach(c => {
                                    c.classList.remove('selected-card');
                                });
                                this.selectedComparison = [];
                            }
                            
                            // Add new selection
                            card.classList.add('selected-card');
                            this.selectedComparison.push(id);
                        }
                        
                        // Update scenario details if 2 cards are selected
                        if (this.selectedComparison.length === this.MAX_COMPARISON) {
                            const compData = ScenarioDataProcessor.dataPoints.filter(point => 
                                this.selectedComparison.includes(point.id)
                            );
                            this.populateScenarioDetails(compData);
                        } else {
                            // Clear details if fewer than 2 selected
                            const scenarioAccordion = document.getElementById('scenarioAccordion');
                            if (scenarioAccordion) {
                                scenarioAccordion.innerHTML = `
                                    <div class="text-center text-muted p-3">
                                        Select two scenario cards above to compare details
                                    </div>
                                `;
                            }
                        }
                    } catch (error) {
                        console.error('Error handling card selection:', error);
                    }
                },

                
                /**
                 * Update selected media display based on scenario selection
                 */
                updateSelectedMedia() {
                    try {
                        console.log('Updating selected media');
                        
                        if (this.selectedScenarios.length === 0) {
                            console.log('No scenarios selected, clearing media');
                            this.updateMediaDisplay("");
                            return;
                        }
                        
                        if (this.selectedScenarios.length === 1) {
                            // Find all points that match the selected scenario title
                            const scenarioPoints = ScenarioDataProcessor.dataPoints.filter(p => 
                                p.scenarioTitle === this.selectedScenarios[0]
                            );
                            
                            console.log(`Found ${scenarioPoints.length} points for scenario: ${this.selectedScenarios[0]}`);
                            
                            // First try to find the parent scenario
                            let targetScenario = scenarioPoints.find(p => p.isParent);
                            
                            // If no parent found but we have points, use the first point
                            if (!targetScenario && scenarioPoints.length > 0) {
                                targetScenario = scenarioPoints[0];
                            }
                            
                            if (targetScenario && targetScenario.url) {
                                console.log('Updating media with URL:', targetScenario.url);
                                this.updateMediaDisplay(targetScenario.url);
                            } else {
                                console.log('No URL found for scenario:', this.selectedScenarios[0]);
                                this.updateMediaDisplay("");
                            }
                        } else {
                            console.log('Multiple scenarios selected, clearing media');
                            this.updateMediaDisplay("");
                        }
                    } catch (error) {
                        console.error('Error updating selected media:', error);
                        this.updateMediaDisplay("");
                    }
                },
                
                /**
                 * Update media display with the given URL
                 * @param {string} url Media URL to display
                 */
                updateMediaDisplay(url) {
                    try {
                        const container = document.getElementById('media-placeholder');
                        const openMediaButton = document.getElementById('open-media');
                        
                        if (!container) return;
                        
                        // Update the current URL
                        this.currentMediaUrl = url || "";
                        
                        // Enable/disable the "Open in New Window" button based on URL availability
                        if (openMediaButton) {
                            openMediaButton.disabled = !this.currentMediaUrl;
                        }
                        
                        if (!url) {
                            container.innerHTML = "<p class='text-center text-muted mt-3'>No media available for this selection</p>";
                            return;
                        }
                        
                        // Clear existing content
                        container.innerHTML = '';
                        
                        // Handle different types of URLs
                        if (url.includes("reddit.com")) {
                            this.embedRedditContent(container, url);
                        } else if (url.includes("youtube.com") || url.includes("youtu.be")) {
                            this.embedYouTubeContent(container, url);
                        } else {
                            this.embedGenericContent(container, url);
                        }
                    } catch (error) {
                        console.error('Error updating media display:', error);
                        
                        const container = document.getElementById('media-placeholder');
                        if (container) {
                            container.innerHTML = `
                                <p class='text-center text-muted mt-3'>
                                Unable to display media. 
                                <a href="${ScenarioDataProcessor.escapeHTML(url)}" target="_blank">Open externally</a>
                                </p>`;
                        }
                    }
                },
                
                /**
                 * Embed Reddit content
                 * @param {HTMLElement} container Container element
                 * @param {string} url Reddit URL
                 */
                embedRedditContent(container, url) {
                    try {
                        container.innerHTML = `
                        <blockquote class="reddit-embed" data-embed-media="true" data-height="500">
                            <a href="${ScenarioDataProcessor.escapeHTML(url)}">View this post on Reddit</a>
                        </blockquote>
                        `;
                        
                        // Reload Reddit embed script
                        let existingScript = document.getElementById('reddit-embed-script');
                        if (existingScript) {
                            existingScript.remove();
                        }
                        
                        let script = document.createElement('script');
                        script.id = 'reddit-embed-script';
                        script.async = true;
                        script.src = 'https://embed.reddit.com/widgets.js';
                        script.charset = 'UTF-8';
                        document.body.appendChild(script);
                    } catch (error) {
                        console.error('Error embedding Reddit content:', error);
                        this.showFallbackMediaDisplay(container, url);
                    }
                },
                
                /**
                 * Embed YouTube content
                 * @param {HTMLElement} container Container element
                 * @param {string} url YouTube URL
                 */
                embedYouTubeContent(container, url) {
                    try {
                        // Extract video ID from various YouTube URL formats
                        let videoId;
                        if (url.includes('youtube.com')) {
                            const urlParams = new URL(url).searchParams;
                            videoId = urlParams.get('v');
                        } else if (url.includes('youtu.be')) {
                            videoId = url.split('/').pop().split('?')[0];
                        }
                        
                        if (videoId) {
                            // Create a new iframe element
                            const iframe = document.createElement('iframe');
                            iframe.width = '100%';
                            iframe.height = '100%';
                            iframe.src = `https://www.youtube.com/embed/${videoId}`;
                            iframe.frameBorder = '0';
                            iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
                            iframe.allowFullscreen = true;
                            
                            // Append the new iframe
                            container.appendChild(iframe);
                        } else {
                            console.error('Could not extract YouTube video ID from URL:', url);
                            this.showFallbackMediaDisplay(container, url);
                        }
                    } catch (error) {
                        console.error('Error embedding YouTube content:', error);
                        this.showFallbackMediaDisplay(container, url);
                    }
                },
                
                /**
                 * Embed generic content in an iframe
                 * @param {HTMLElement} container Container element
                 * @param {string} url Content URL
                 */
                embedGenericContent(container, url) {
                    try {
                        // Create a new iframe
                        const iframe = document.createElement('iframe');
                        iframe.style.width = '100%';
                        iframe.style.height = '100%';
                        iframe.style.border = 'none';
                        iframe.src = url;
                        iframe.allowFullscreen = true;
                        
                        // Add error handler
                        iframe.onerror = () => {
                            this.showFallbackMediaDisplay(container, url);
                        };
                        
                        // Add load handler
                        iframe.onload = () => {
                            // X-Frame-Options might prevent loading, check if contentDocument is accessible
                            try {
                                const doc = iframe.contentDocument;
                                if (!doc) {
                                    this.showFallbackMediaDisplay(container, url);
                                }
                            } catch (e) {
                                // X-Frame-Options preventing access
                                this.showFallbackMediaDisplay(container, url);
                            }
                        };
                        
                        // Clear the container and append the new iframe
                        container.appendChild(iframe);
                    } catch (error) {
                        console.error('Error embedding generic content:', error);
                        this.showFallbackMediaDisplay(container, url);
                    }
                },
                
                /**
                 * Show fallback media display with link
                 * @param {HTMLElement} container Container element
                 * @param {string} url Content URL
                 */
                showFallbackMediaDisplay(container, url) {
                    container.innerHTML = `
                        <p class='text-center text-muted mt-3'>
                        Unable to display content. 
                        <a href="${ScenarioDataProcessor.escapeHTML(url)}" target="_blank">Open in new window</a>
                        </p>`;
                },
                
                /**
                 * Show a warning message to the user
                 * @param {string} message Warning message
                 */
                showWarningMessage(message) {
                    alert(message);
                },
                
                /**
                 * Show an error message to the user
                 * @param {string} message Error message
                 */
                showErrorMessage(message) {
                    alert(message);
                }
            });

            // Update the analyze button event listener
            document.addEventListener('DOMContentLoaded', function() {
                const analyzeScenarioBtn = document.getElementById('analyze-scenario-btn');
                if (analyzeScenarioBtn) {
                    // Clone the button to remove any existing event listeners
                    const newBtn = analyzeScenarioBtn.cloneNode(true);
                    if (analyzeScenarioBtn.parentNode) {
                        analyzeScenarioBtn.parentNode.replaceChild(newBtn, analyzeScenarioBtn);
                    }
                    
                    newBtn.addEventListener('click', function() {
                        if (VisualizationManager.handleAnalyzeScenarioClick) {
                            VisualizationManager.handleAnalyzeScenarioClick();
                        } else {
                            console.error('handleAnalyzeScenarioClick method not found');
                            alert('Analysis function not available');
                        }
                    });
                }
            });

            // Wait for document to be ready
            document.addEventListener('DOMContentLoaded', function() {
                // 1. Fix scenario selection modal columns
                const scenarioTableHeaders = document.querySelector('#scenarioSelectModal thead tr');
                if (scenarioTableHeaders) {
                    scenarioTableHeaders.innerHTML = `
                        <th>Title</th>
                        <th>Category</th>
                        <th>Action</th>
                    `;
                }
                
                // 2 & 3. Fix survey modal scrolling and slider issues
                $('#surveyModal').on('shown.bs.modal', function() {
                    // Fix scrolling
                    const modalDialog = document.querySelector('#surveyModal .modal-dialog');
                    if (modalDialog) {
                        modalDialog.classList.add('modal-dialog-scrollable');
                        modalDialog.classList.add('modal-xl');
                    }
                    
                    const modalBody = document.querySelector('#surveyModal .modal-body');
                    if (modalBody) {
                        modalBody.style.maxHeight = '70vh';
                        modalBody.style.overflow = 'auto';
                    }
                });
            });    
                
            
            // Complete the missing UserSurveyManager methods
            Object.assign(UserSurveyManager, {
                /**
                 * Get user surveys from Auth0
                 * @returns {Promise<Array>} User's surveys
                 */
                async getUserSurveys() {
                    try {
                        // Get authenticated user
                        const user = await AuthManager.getUser();
                        if (!user || !user.sub) {
                            throw new Error('User is not authenticated or missing user ID');
                        }
                        
                        // Get authentication token
                        const token = await AuthManager.getToken({
                            timeoutInSeconds: 60,
                            maxRetries: this.AUTH_RETRY_LIMIT
                        });
                        
                        // Add request timeout handling
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 15000); // 15-second timeout
                        
                        try {
                            // Fetch user data with proper error handling
                            const response = await fetch(`https://dev-10xzf0prvka6p40y.us.auth0.com/api/v2/users/${user.sub}`, {
                            headers: {
                                'Authorization': `Bearer ${token}`
                            },
                            signal: controller.signal
                            });
                            
                            clearTimeout(timeoutId);
                            
                            if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`Failed to fetch user data: ${response.status} - ${errorText}`);
                            }
                            
                            const userData = await response.json();
                            return userData.user_metadata?.surveys || [];
                        } catch (error) {
                            clearTimeout(timeoutId);
                            
                            if (error.name === 'AbortError') {
                            throw new Error('Request timed out. Please try again.');
                            }
                            throw error;
                        }
                    } catch (error) {
                        console.error('Error fetching user surveys:', error);
                        throw error;
                    }
                },
                
                /**
                 * Submit a new survey
                 * @param {Object} surveyData Survey data to submit
                 * @returns {Promise<Object>} Result of the submission
                 */
                 async submitSurvey(surveyData) {
                    try {
                        console.log('Submitting survey data:', JSON.stringify(surveyData));
                        
                        // Make sure we're authenticated
                        let isAuthenticated = await AuthManager.isUserAuthenticated();
                        if (!isAuthenticated) {
                            console.log('Not authenticated, attempting to refresh token');
                            // Try to refresh authentication
                            try {
                                await AuthManager.getToken({ 
                                    ignoreCache: true,
                                    timeoutInSeconds: 60 
                                });
                                isAuthenticated = await AuthManager.isUserAuthenticated(true);
                            } catch (authError) {
                                console.error('Failed to refresh authentication:', authError);
                            }
                            
                            if (!isAuthenticated) {
                                throw new Error('Authentication required. Please login again.');
                            }
                        }
                        
                        // Always run MongoDB save first as it's more reliable
                        try {
                            const mongoResult = await this.saveToMongoDB(surveyData);
                            console.log('Survey saved to MongoDB:', mongoResult);
                        } catch (mongoError) {
                            console.error('Error saving to MongoDB:', mongoError);
                            throw new Error(`Database error: ${mongoError.message}`);
                        }
                        
                        // Then try Auth0 metadata save for backward compatibility
                        try {
                            const auth0Result = await this.performUserDataOperation('add', surveyData);
                            console.log('Survey saved to Auth0:', auth0Result);
                            return auth0Result;
                        } catch (auth0Error) {
                            console.warn('Warning: Auth0 metadata save failed, but MongoDB save succeeded:', auth0Error);
                            // Don't fail the operation if MongoDB save worked but Auth0 save failed
                            return { 
                                success: true, 
                                operation: 'add',
                                data: surveyData,
                                warning: 'Saved to database but not to user profile'
                            };
                        }
                    } catch (error) {
                        console.error('Error in submitSurvey:', error);
                        throw error;
                    }
                },
                
                /**
                 * Update an existing survey
                 * @param {string} surveyId Survey ID to update
                 * @param {Object} updatedSurveyData Updated survey data
                 * @returns {Promise<Object>} Result of the update
                 */
                 async updateSurvey(surveyId, updatedSurveyData) {
                    try {
                        console.log(`Updating survey ID ${surveyId}:`, JSON.stringify(updatedSurveyData));
                        
                        // Make sure we're authenticated
                        let isAuthenticated = await AuthManager.isUserAuthenticated();
                        if (!isAuthenticated) {
                            console.log('Not authenticated, attempting to refresh token');
                            // Try to refresh authentication
                            try {
                                await AuthManager.getToken({ 
                                    ignoreCache: true,
                                    timeoutInSeconds: 60 
                                });
                                isAuthenticated = await AuthManager.isUserAuthenticated(true);
                            } catch (authError) {
                                console.error('Failed to refresh authentication:', authError);
                            }
                            
                            if (!isAuthenticated) {
                                throw new Error('Authentication required. Please login again.');
                            }
                        }
                        
                        // Save to MongoDB first
                        try {
                            const mongoResult = await this.saveToMongoDB(updatedSurveyData);
                            console.log('Survey updated in MongoDB:', mongoResult);
                        } catch (mongoError) {
                            console.error('Error updating in MongoDB:', mongoError);
                            throw new Error(`Database error: ${mongoError.message}`);
                        }
                        
                        // Then try Auth0 metadata update
                        try {
                            const auth0Result = await this.performUserDataOperation('update', updatedSurveyData, surveyId);
                            console.log('Survey updated in Auth0:', auth0Result);
                            return auth0Result;
                        } catch (auth0Error) {
                            console.warn('Warning: Auth0 metadata update failed, but MongoDB update succeeded:', auth0Error);
                            // Don't fail the operation if MongoDB save worked but Auth0 save failed
                            return { 
                                success: true, 
                                operation: 'update',
                                data: updatedSurveyData,
                                warning: 'Updated in database but not in user profile'
                            };
                        }
                    } catch (error) {
                        console.error('Error in updateSurvey:', error);
                        throw error;
                    }
                },
                
                /**
                 * Delete a survey
                 * @param {string} surveyId Survey ID to delete
                 * @returns {Promise<Object>} Result of the deletion
                 */
                async deleteSurvey(surveyId) {
                    try {
                        const result = await this.performUserDataOperation('delete', null, surveyId);
                        this.showSuccessMessage('Analysis deleted successfully');
                        this.loadUserSurveys();
                        return result;
                    } catch (error) {
                        console.error('Error deleting survey:', error);
                        this.showErrorMessage(`Failed to delete analysis: ${error.message}`);
                        throw error;
                    }
                },
                
                /**
                 * Perform user data operations with robust error handling
                 * @param {string} operation Operation to perform ('add', 'update', 'delete')
                 * @param {Object} surveyData Survey data (for 'add' and 'update')
                 * @param {string} surveyId Survey ID (for 'update' and 'delete')
                 * @returns {Promise<Object>} Updated user data
                 */
                async performUserDataOperation(operation, surveyData = null, surveyId = null) {
                    // Initialize variables to manage resources properly
                    let token = null;
                    let response = null;
                    
                    try {
                        // Validate client initialization and authentication
                        if (!await this.checkAuthentication()) {
                            throw new Error('User is not authenticated');
                        }
                        
                        // Get current user
                        const user = await AuthManager.getUser();
                        if (!user || !user.sub) {
                            throw new Error('User profile is incomplete or missing');
                        }
                        
                        // Get authentication token
                        token = await AuthManager.getToken({
                            timeoutInSeconds: 60,
                            maxRetries: this.AUTH_RETRY_LIMIT
                        });
                        
                        // Set up request timeout handling
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 15000); // 15-second timeout
                        
                        try {
                            // Fetch current user data
                            response = await fetch(`https://dev-10xzf0prvka6p40y.us.auth0.com/api/v2/users/${user.sub}`, {
                                headers: {
                                    'Authorization': `Bearer ${token}`
                                },
                                signal: controller.signal
                            });
                            
                            clearTimeout(timeoutId);
                            
                            if (!response.ok) {
                                const status = response.status;
                                let errorMessage = await response.text();
                                
                                // Provide helpful error messages for common status codes
                                if (status === 401) {
                                    throw new Error('Authentication token is invalid or expired');
                                } else if (status === 403) {
                                    throw new Error('Insufficient permissions to access user data');
                                } else if (status === 429) {
                                    throw new Error('Rate limit exceeded. Please try again later');
                                }
                                
                                throw new Error(`Failed to fetch user data: ${status} - ${errorMessage}`);
                            }
                            
                            const userData = await response.json();
                            const existingSurveys = userData.user_metadata?.surveys || [];
                            
                            // Perform the requested operation with proper validation
                            let updatedSurveys;
                            let changedData;
                            
                            switch (operation) {
                                case 'add':
                                    if (!surveyData) {
                                        throw new Error('Survey data is required for add operation');
                                    }
                                    
                                    // Validate surveyData has required properties
                                    this.validateSurveyData(surveyData);
                                    
                                    // Add timestamps and user info
                                    const newSurvey = {
                                        ...surveyData,
                                        created: new Date().toISOString(),
                                        lastModified: new Date().toISOString(),
                                        userId: user.sub
                                    };
                                    
                                    updatedSurveys = [...existingSurveys, newSurvey];
                                    changedData = newSurvey;
                                    break;
                                    
                                case 'update':
                                    if (!surveyData || !surveyId) {
                                        throw new Error('Survey data and ID are required for update operation');
                                    }
                                    
                                    // Verify the survey exists and belongs to the user
                                    const existingSurvey = existingSurveys.find(s => s.id === surveyId);
                                    if (!existingSurvey) {
                                        throw new Error(`Survey with ID ${surveyId} not found`);
                                    }
                                    
                                    // Validate surveyData
                                    this.validateSurveyData(surveyData);
                                    
                                    // Update the survey with latest timestamp
                                    updatedSurveys = existingSurveys.map(survey => 
                                        survey.id === surveyId ? {
                                            ...surveyData,
                                            edits: {
                                                ...surveyData.edits,
                                                editDate: new Date().toISOString(),
                                                editedBy: user.sub
                                            },
                                            lastModified: new Date().toISOString()
                                        } : survey
                                    );
                                    
                                    changedData = updatedSurveys.find(s => s.id === surveyId);
                                    break;
                                    
                                case 'delete':
                                    if (!surveyId) {
                                        throw new Error('Survey ID is required for delete operation');
                                    }
                                    
                                    // Verify the survey exists
                                    const surveyToDelete = existingSurveys.find(s => s.id === surveyId);
                                    if (!surveyToDelete) {
                                        throw new Error(`Survey with ID ${surveyId} not found`);
                                    }
                                    
                                    updatedSurveys = existingSurveys.filter(survey => survey.id !== surveyId);
                                    changedData = surveyToDelete;
                                    break;
                                    
                                default:
                                    throw new Error(`Unknown operation: ${operation}`);
                            }
                            
                            // Check for metadata size limits
                            const updatedMetadata = {
                                ...userData.user_metadata,
                                surveys: updatedSurveys
                            };
                            
                            const metadataSize = new TextEncoder().encode(JSON.stringify(updatedMetadata)).length;
                            
                            if (metadataSize > this.DATA_SIZE_WARNING) {
                                console.warn(`User metadata size (${metadataSize} bytes) approaching limit of 16MB.`);
                            }
                            
                            if (metadataSize > this.DATA_SIZE_LIMIT) {
                                throw new Error('The data is too large to save. Please reduce the size of your surveys or delete some old ones.');
                            }
                            
                            // Set up another request timeout for the update operation
                            const updateController = new AbortController();
                            const updateTimeoutId = setTimeout(() => updateController.abort(), 15000);
                            
                            try {
                                // Update user data with timeout protection
                                const updateResponse = await fetch(`https://dev-10xzf0prvka6p40y.us.auth0.com/api/v2/users/${user.sub}`, {
                                    method: 'PATCH',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'Authorization': `Bearer ${token}`
                                    },
                                    body: JSON.stringify({
                                        user_metadata: updatedMetadata
                                    }),
                                    signal: updateController.signal
                                });
                                
                                clearTimeout(updateTimeoutId);
                                
                                if (!updateResponse.ok) {
                                    const status = updateResponse.status;
                                    const errorText = await updateResponse.text();
                                    
                                    if (status === 413) {
                                        throw new Error('The data is too large to save. Please reduce the size of your survey or delete some old ones.');
                                    }
                                    
                                    throw new Error(`Failed to update user data: ${status} - ${errorText}`);
                                }
                                
                                // Return the updated user data
                                return {
                                    success: true,
                                    operation,
                                    data: changedData,
                                    userData: await updateResponse.json()
                                };
                            } catch (updateError) {
                                clearTimeout(updateTimeoutId);
                                
                                if (updateError.name === 'AbortError') {
                                    throw new Error('Update operation timed out. Please try again.');
                                }
                                
                                throw updateError;
                            }
                        } catch (fetchError) {
                            clearTimeout(timeoutId);
                            
                            if (fetchError.name === 'AbortError') {
                                throw new Error('Request timed out. Please check your network connection and try again.');
                            }
                            
                            throw fetchError;
                        }
                    } catch (error) {
                        console.error(`Error in ${operation} operation:`, error);
                        
                        // Check for authentication errors
                        if (error.message.includes('token') || error.message.includes('auth')) {
                            // Attempt token refresh for next time
                            AuthManager.getToken({ ignoreCache: true }).catch(() => {});
                        }
                        
                        // Rethrow with user-friendly message
                        throw new Error(`Failed to ${operation} survey: ${error.message}`);
                    }
                },
                
                /**
                 * Collect survey data from form
                 * @returns {Promise<Object>} Collected survey data
                 */
                 async collectSurveyData() {
                    try {
                        // Ensure user is authenticated
                        const isAuthenticated = await AuthManager.isUserAuthenticated();
                        if (!isAuthenticated) {
                            throw new Error('User is not authenticated');
                        }
                        
                        // Get user information
                        const user = await AuthManager.getUser();
                        
                        // Validate required fields
                        const scenarioId = document.getElementById('scenario-id')?.value;
                        const scenarioTitle = document.getElementById('scenario-title-display')?.value;
                        const moralClassification = document.getElementById('moral-classification')?.value;
                        
                        if (!scenarioId || !scenarioTitle || !moralClassification) {
                            throw new Error('Missing required fields: scenario ID, title, or classification');
                        }
                        
                        // Create survey data with proper structure
                        const surveyData = {
                            id: scenarioId || this.generateId(),
                            type: document.getElementById('scenario-type')?.value || 'base',
                            parentId: document.getElementById('scenario-parent-id')?.value || null,
                            metadata: {
                                title: scenarioTitle,
                                description: document.getElementById('scenario-description-display')?.value || '',
                                category: document.getElementById('scenario-category-display')?.value || '',
                                llmSource: {
                                    model: "Human",
                                    version: "1.0",
                                    provider: "Human"
                                },
                                classification: {
                                    type: moralClassification,
                                    justification: document.getElementById('classification-justification')?.value || ''
                                },
                                url: document.getElementById('scenario-url')?.value || ''
                            },
                            survey: {
                                dimensions: [
                                    {
                                        id: "Ends",
                                        axis: "x",
                                        label: "Motivation",
                                        questions: [
                                            this.processQuestionData('societal-needs'),
                                            this.processQuestionData('others-needs'),
                                            this.processQuestionData('others-wants'),
                                            this.processQuestionData('personal-needs'),
                                            this.processQuestionData('personal-wants')
                                        ]
                                    },
                                    {
                                        id: "Means",
                                        axis: "y",
                                        label: "Sacrifice",
                                        questions: [
                                            this.processQuestionData('future-sacrifice'),
                                            this.processQuestionData('individuals-affected'),
                                            this.processQuestionData('sacrifice-type'),
                                            this.processQuestionData('sacrifice-duration'),
                                            this.processQuestionData('life-magnitude')
                                        ]
                                    },
                                    {
                                        id: "Character",
                                        axis: "z",
                                        label: "Habit > Will Power",
                                        questions: [
                                            this.processQuestionData('consciousness'),
                                            this.processQuestionData('present-sacrifice'),
                                            this.processQuestionData('willpower'),
                                            this.processQuestionData('intentionality'),
                                            this.processQuestionData('wills', true) // No score
                                        ]
                                    },
                                    {
                                        id: "PhilosophicalAnalysis",
                                        axis: null,
                                        label: "Philosophical Perspectives",
                                        questions: [
                                            this.processQuestionData('deontology'),
                                            this.processQuestionData('utilitarianism'),
                                            this.processQuestionData('virtue-ethics')
                                        ]
                                    }
                                ],
                                finalPosition: this.calculateFinalPosition()
                            },
                            edits: {
                                editedBy: user?.sub || null,
                                editDate: new Date().toISOString(),
                                editedFields: this.getEditedFields()
                            },
                            created: new Date().toISOString(),
                            lastModified: new Date().toISOString()
                        };
                        
                        // Ensure required fields are editable before collection
                        this.ensureFormFieldsEditable();
                        
                        // Log the survey data structure for debugging
                        console.log("Survey data structure:", JSON.stringify(surveyData, null, 2));
                        
                        // Validate the survey data before returning
                        console.log("Validating survey data...");
                        this.validateSurveyData(surveyData);
                        console.log("Survey data validation successful");
                        
                        return surveyData;
                    } catch (error) {
                        console.error('Error collecting survey data:', error);
                        throw error;
                    }
                },

                /**
                 * Process form data for a question
                 * @param {string} questionId Base ID of the question (without -score or -justification)
                 * @param {boolean} noScore Whether this question doesn't have a score field
                 * @returns {Object} Processed question data
                 */
                processQuestionData(questionId, noScore = false) {
                    // Direct mapping to ensure exact match with expected format
                    const EXACT_QUESTION_NAMES = {
                        'societal-needs': 'Societal Needs',
                        'others-needs': 'Others Needs',
                        'others-wants': 'Others Wants', 
                        'personal-needs': 'Personal Needs',
                        'personal-wants': 'Personal Wants',
                        'future-sacrifice': 'Future Self-Sacrifice', // Critical fix
                        'individuals-affected': 'Number of Individuals Affected',
                        'sacrifice-type': 'Type of Sacrifice',
                        'sacrifice-duration': 'Duration of Sacrifice',
                        'life-magnitude': 'Magnitude of Life Impacted',
                        'consciousness': 'Unconscious vs Conscious',
                        'present-sacrifice': 'Present Self-Sacrifice',
                        'willpower': 'Habit vs Will Power',
                        'intentionality': 'Unintentional vs Intentional',
                        'wills': 'Wills at Play',
                        'deontology': 'Deontology',
                        'utilitarianism': 'Utilitarianism',
                        'virtue-ethics': 'Virtue Ethics'
                    };

                    const scoreField = document.getElementById(`${questionId}-score`);
                    const justField = document.getElementById(`${questionId}-justification`);
                    
                    // Use exact mapping to ensure consistency
                    const exactQuestionName = EXACT_QUESTION_NAMES[questionId];
                    if (!exactQuestionName) {
                        console.error(`Missing question name mapping for field ID: ${questionId}`);
                    }
                    
                    const question = {
                        question: exactQuestionName || questionId,
                        justification: justField?.value || ''
                    };
                    
                    if (!noScore && scoreField) {
                        if (scoreField.tagName.toLowerCase() === 'select') {
                            question.score = scoreField.value;
                        } else {
                            question.score = parseFloat(scoreField.value) || 0;
                        }
                    }
                    
                    return question;
                },

                /**
                 * Calculate final x/y/z position from form values
                 * @returns {Object} Position coordinates
                 */
                calculateFinalPosition() {
                    try {
                        // Calculate X axis (Ends)
                        const societalNeedsScore = parseFloat(document.getElementById('societal-needs-score')?.value) || 0;
                        const othersNeedsScore = parseFloat(document.getElementById('others-needs-score')?.value) || 0;
                        const othersWantsScore = parseFloat(document.getElementById('others-wants-score')?.value) || 0;
                        const personalNeedsScore = parseFloat(document.getElementById('personal-needs-score')?.value) || 0;
                        const personalWantsScore = parseFloat(document.getElementById('personal-wants-score')?.value) || 0;
                        
                        // Calculate Y axis (Means)
                        const futureSacrificeScore = parseFloat(document.getElementById('future-sacrifice-score')?.value) || 0;
                        const individualsAffectedScore = parseFloat(document.getElementById('individuals-affected-score')?.value) || 0;
                        const sacrificeTypeScore = parseFloat(document.getElementById('sacrifice-type-score')?.value) || 0;
                        const sacrificeDurationScore = parseFloat(document.getElementById('sacrifice-duration-score')?.value) || 0;
                        const lifeMagnitudeScore = parseFloat(document.getElementById('life-magnitude-score')?.value) || 0;
                        
                        // Calculate Z axis (Character)
                        const consciousnessScore = parseFloat(document.getElementById('consciousness-score')?.value) || 0;
                        const presentSacrificeScore = parseFloat(document.getElementById('present-sacrifice-score')?.value) || 0;
                        const willpowerScore = parseFloat(document.getElementById('willpower-score')?.value) || 0;
                        const intentionalityScore = parseFloat(document.getElementById('intentionality-score')?.value) || 0;
                        
                        // Final calculations
                        const x = ((societalNeedsScore + othersNeedsScore + othersWantsScore) - 
                                Math.abs(personalNeedsScore) - Math.abs(personalWantsScore));
                                
                        const y = ((futureSacrificeScore + individualsAffectedScore + 
                                sacrificeTypeScore + sacrificeDurationScore) * -1) * 
                                lifeMagnitudeScore;
                                
                        const z = consciousnessScore + presentSacrificeScore + 
                                willpowerScore + intentionalityScore;
                        
                        return {
                            x: parseFloat(x.toFixed(2)),
                            y: parseFloat(y.toFixed(2)),
                            z: parseFloat(z.toFixed(2))
                        };
                    } catch (error) {
                        console.error('Error calculating final position:', error);
                        return { x: 0, y: 0, z: 0 };
                    }
                },
                
                /**
                 * Reset the survey form
                 */
                resetSurveyForm() {
                    try {
                        this.isEditMode = false;
                        this.editSurveyId = null;
                        
                        // Reset all input fields
                        document.querySelectorAll('#surveyTabContent input:not([type="checkbox"]), #surveyTabContent textarea, #surveyTabContent select').forEach(input => {
                            if (input.tagName.toLowerCase() === 'select') {
                                input.selectedIndex = 0;
                            } else {
                                input.value = '';
                            }
                        });
                        
                        // Uncheck all checkboxes
                        document.querySelectorAll('#surveyTabContent input[type="checkbox"]').forEach(checkbox => {
                            checkbox.checked = false;
                        });
                        // Remove any existing sliders
                        document.querySelectorAll('[id$="-slider-container"]').forEach(container => {
                            container.remove();
                        });
                        
                        // Reset tabs
                        this.currentTabIndex = 0;
                        this.updateTabDisplay();
                        
                        // Clear scenario data
                        this.scenarioData = null;
                        this.originalScenarioData = null;
                        
                        // Reset progress bar
                        const progressBar = document.querySelector('.progress-bar');
                        if (progressBar) {
                            progressBar.style.width = '0%';
                            progressBar.setAttribute('aria-valuenow', 0);
                            progressBar.textContent = '0%';
                        }
                    } catch (error) {
                        console.error('Error resetting survey form:', error);
                    }
                },
                
                /**
                 * Validate survey data structure and content
                 * @param {Object} surveyData Survey data to validate
                 * @returns {boolean} Whether the data is valid
                 */
                validateSurveyData(surveyData) {
                    // Check for required top-level properties
                    if (!surveyData.id || !surveyData.metadata || !surveyData.survey) {
                        throw new Error('Missing required survey data properties');
                    }
                    
                    // Check for required metadata properties
                    if (!surveyData.metadata.title || surveyData.metadata.title.trim() === '') {
                        throw new Error('Scenario title is required');
                    }
                    
                    if (!surveyData.metadata.classification || !surveyData.metadata.classification.type) {
                        throw new Error('Moral classification is required');
                    }
                    
                    // Validate classification type is one of the allowed values
                    const validClassifications = ['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building'];
                    if (!validClassifications.includes(surveyData.metadata.classification.type.toLowerCase())) {
                        throw new Error(`Invalid classification type: ${surveyData.metadata.classification.type}`);
                    }
                    
                    // Ensure dimensions and questions are properly structured
                    if (!Array.isArray(surveyData.survey.dimensions) || surveyData.survey.dimensions.length === 0) {
                        throw new Error('Survey dimensions missing or invalid');
                    }
                    
                    // Define expected dimensions and their required questions
                    const expectedDimensions = {
                        'Ends': ['Societal Needs', 'Others Needs', 'Others Wants', 'Personal Needs', 'Personal Wants'],
                        'Means': ['Future Self-Sacrifice', 'Number of Individuals Affected', 
                                'Type of Sacrifice', 'Duration of Sacrifice', 'Magnitude of Life Impacted'],
                        'Character': ['Unconscious vs Conscious', 'Present Self-Sacrifice', 
                                    'Habit vs Will Power', 'Unintentional vs Intentional', 'Wills at Play'],
                        'PhilosophicalAnalysis': ['Deontology', 'Utilitarianism', 'Virtue Ethics']
                    };
                    
                    // Check each dimension and its questions
                    for (const [dimName, requiredQuestions] of Object.entries(expectedDimensions)) {
                        const dimension = surveyData.survey.dimensions.find(d => d.id === dimName);
                        
                        if (!dimension) {
                            throw new Error(`Required dimension "${dimName}" is missing`);
                        }
                        
                        if (!Array.isArray(dimension.questions) || dimension.questions.length === 0) {
                            throw new Error(`Dimension ${dimName} has missing or invalid questions`);
                        }
                        
                        // Verify all required questions are present
                        for (const reqQuestion of requiredQuestions) {
                            const foundQuestion = dimension.questions.find(q => q.question === reqQuestion);
                            
                            if (!foundQuestion) {
                                throw new Error(`Required question "${reqQuestion}" is missing from dimension "${dimName}"`);
                            }
                            
                            // Validate scores for all questions except 'Wills at Play'
                            if (reqQuestion !== 'Wills at Play') {
                                // Replace this entire if-block with the following code:
                                
                                // Check if this is a philosophical question that uses string values
                                const isPhilosophicalQuestion = dimName === 'PhilosophicalAnalysis';
                                
                                if (isPhilosophicalQuestion) {
                                    // For philosophical questions, verify that score is a non-empty string
                                    if (foundQuestion.score === null || foundQuestion.score === undefined || 
                                        foundQuestion.score.trim() === '') {
                                        throw new Error(`Question "${reqQuestion}" requires a valid answer`);
                                    }
                                    
                                    // Optional: Validate that philosophical scores are from allowed values
                                    if (reqQuestion === 'Deontology' || reqQuestion === 'Utilitarianism') {
                                        const validScores = ['Right', 'Wrong', 'Neutral', 'Complex'];
                                        if (!validScores.includes(foundQuestion.score)) {
                                            throw new Error(`Question "${reqQuestion}" must have one of these values: ${validScores.join(', ')}`);
                                        }
                                    } else if (reqQuestion === 'Virtue Ethics') {
                                        const validScores = ['Virtuous', 'Vicious', 'Mixed', 'Neutral'];
                                        if (!validScores.includes(foundQuestion.score)) {
                                            throw new Error(`Question "${reqQuestion}" must have one of these values: ${validScores.join(', ')}`);
                                        }
                                    }
                                } else {
                                    // For numeric questions, verify it's a valid number
                                    if (foundQuestion.score === null || foundQuestion.score === undefined || 
                                        typeof foundQuestion.score !== 'number' || isNaN(foundQuestion.score)) {
                                        throw new Error(`Question "${reqQuestion}" requires a numeric score`);
                                    }
                                    
                                    // Validate score ranges based on dimension and question
                                    this.validateScoreRange(dimName, reqQuestion, foundQuestion.score);
                                }
                            }
                            
                            // Validate justification text
                            if (!foundQuestion.justification || foundQuestion.justification.trim() === '') {
                                throw new Error(`Question "${reqQuestion}" requires a justification`);
                            }
                        }
                    }
                    
                    // Validate final position
                    const position = surveyData.survey.finalPosition;
                    if (!position || 
                        typeof position.x !== 'number' || isNaN(position.x) || 
                        typeof position.y !== 'number' || isNaN(position.y) || 
                        typeof position.z !== 'number' || isNaN(position.z)) {
                        throw new Error('Invalid final position coordinates');
                    }
                    
                    return true;
                }
            });

            // Enhanced Auth configuration with persistent session management
            async function initializeApplication() {
                try {
                    console.log('Starting enhanced application initialization...');
                    
                    // Add additional Auth0 client setup for persistent sessions
                    const authConfig = {
                        domain: 'dev-10xzf0prvka6p40y.us.auth0.com',
                        clientId: 'o7n479CCBo1GoASsEQI3s44cIXdyvzJh',
                        authorizationParams: {
                            redirect_uri: 'https://themoralcube.com',
                            // Only request Management API access when needed
                            scope: 'openid profile email offline_access'
                        },
                        // These settings specifically address third-party cookie issues
                        cacheLocation: 'localstorage',
                        useRefreshTokens: true,
                        useRefreshTokensFallback: true,
                        useCookiesForTransactions: true,
                        // Force a consistent login experience
                        cookieDomain: window.location.hostname,
                        // Important setting to help with third-party cookies
                        useFormData: true
                    };
                    
                    // Add JWT parsing function
                    AuthManager.parseJwt = function(token) {
                        try {
                            if (!token) return null;
                            const base64Url = token.split('.')[1];
                            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                            const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                            }).join(''));
                            
                            return JSON.parse(jsonPayload);
                        } catch (error) {
                            console.error('Error parsing JWT:', error);
                            return null;
                        }
                    };
                    
                    // Add silent token refresh method
                    AuthManager.getTokenSilently = async function() {
                        try {
                            const client = await this.getClient();
                            return await client.getTokenSilently({
                                authorizationParams: {
                                    audience: 'https://dev-10xzf0prvka6p40y.us.auth0.com/api/v2/',
                                    scope: 'openid profile email read:current_user update:current_user_metadata offline_access'
                                },
                                timeoutInSeconds: 10,
                                detailedResponse: false
                            });
                        } catch (error) {
                            // Don't log this as an error since it's expected in many cases
                            console.log('Silent authentication failed:', error.message);
                            throw error;
                        }
                    };
                    
                    // Override authentication check to try silent auth
                    AuthManager.isUserAuthenticated = async function(forceCheck = false) {
                        try {
                            const client = await this.getClient();
                            const isAuthenticated = await client.isAuthenticated({ ignoreCache: forceCheck });
                            
                            // If authentication check fails, try to get token silently to restore session
                            if (!isAuthenticated && !forceCheck) {
                                try {
                                    await this.getTokenSilently();
                                    return await client.isAuthenticated({ ignoreCache: true });
                                } catch (silentError) {
                                    // Silent authentication failed, user truly not authenticated
                                    return false;
                                }
                            }
                            
                            return isAuthenticated;
                        } catch (error) {
                            console.error('Error checking authentication status:', error);
                            return false;
                        }
                    };
                    
                    // Replace the current AuthManager.initialize() method with this simplified version
                    AuthManager.initialize = async function() {
                    // This method is now just a wrapper that calls the enhanced implementation
                    try {
                        if (this.client) return this.client;
                        
                        if (this.isInitializing) {
                        return new Promise((resolve, reject) => {
                            const checkInterval = setInterval(() => {
                            if (!this.isInitializing) {
                                clearInterval(checkInterval);
                                if (this.client) resolve(this.client);
                                else reject(this.initError || new Error("Auth0 client initialization failed"));
                            }
                            }, 100);
                        });
                        }
                        
                        this.isInitializing = true;
                        this.lastInitAttempt = Date.now();
                        
                        // Use the enhanced config from initializeApplication
                        const authConfig = {
                        domain: 'dev-10xzf0prvka6p40y.us.auth0.com',
                        clientId: 'o7n479CCBo1GoASsEQI3s44cIXdyvzJh', // Update this with your new key
                        authorizationParams: {
                            redirect_uri: 'https://themoralcube.com',
                            scope: 'openid profile email offline_access'
                        },
                        cacheLocation: 'localstorage',
                        useRefreshTokens: true,
                        useRefreshTokensFallback: true,
                        useCookiesForTransactions: true,
                        cookieDomain: window.location.hostname,
                        useFormData: true
                        };
                        
                        console.log('Initializing Auth0 client with enhanced configuration...');
                        this.client = await auth0.createAuth0Client(authConfig);
                        
                        // Handle redirect callback
                        if (window.location.search.includes("code=") && window.location.search.includes("state=")) {
                        try {
                            await this.client.handleRedirectCallback();
                            window.history.replaceState({}, document.title, window.location.pathname);
                        } catch (callbackError) {
                            console.error('Error handling redirect callback:', callbackError);
                        }
                        }
                        
                        // Set up automatic token refresh
                        if (await this.client.isAuthenticated()) {
                        console.log('User authenticated, scheduling token refresh');
                        this.scheduleTokenRefresh();
                        }
                        
                        return this.client;
                    } catch (error) {
                        console.error('Auth0 initialization failed:', error);
                        this.initError = error;
                        throw error;
                    } finally {
                        this.isInitializing = false;
                    }
                    };
                    
                    // Improved token refresh scheduling function
                    AuthManager.scheduleTokenRefresh = async function() {
                        // Clear any existing refresh timer
                        if (this.tokenRefreshTimer) {
                            clearTimeout(this.tokenRefreshTimer);
                            this.tokenRefreshTimer = null;
                        }
                        
                        try {
                            // Check if we're authenticated before scheduling refresh
                            if (!await this.isUserAuthenticated()) {
                                console.log("No authenticated session to refresh");
                                return;
                            }
                            
                            // Get current token claims to determine expiration
                            const token = await this.getToken({ignoreCache: false});
                            const claims = this.parseJwt(token);
                            
                            if (!claims || !claims.exp) {
                                console.error("Could not parse token expiration");
                                // Fall back to fixed interval if we can't get expiration
                                this.tokenRefreshTimer = setTimeout(async () => {
                                    try {
                                        await this.getToken({ ignoreCache: true });
                                        console.log('Token refreshed successfully (fallback)');
                                        this.scheduleTokenRefresh();
                                    } catch (error) {
                                        console.error('Token refresh failed:', error);
                                    }
                                }, 4.5 * 60 * 1000); // 4.5 minutes fallback
                                return;
                            }
                            
                            // Calculate when token expires (in milliseconds)
                            const expiresAt = claims.exp * 1000;
                            const now = Date.now();
                            
                            // Calculate when to refresh (5 minutes before expiration or sooner if already close)
                            const refreshIn = Math.max(0, expiresAt - now - (5 * 60 * 1000));
                            
                            console.log(`Token expires in ${Math.floor((expiresAt - now) / 1000)} seconds, scheduling refresh in ${Math.floor(refreshIn / 1000)} seconds`);
                            
                            // Schedule token refresh
                            this.tokenRefreshTimer = setTimeout(async () => {
                                try {
                                    // Try to refresh token silently
                                    await this.getToken({ ignoreCache: true });
                                    console.log('Token refreshed successfully');
                                    
                                    // Schedule next refresh
                                    this.scheduleTokenRefresh();
                                } catch (error) {
                                    console.error('Token refresh failed:', error);
                                    // If refresh fails, check if user is still authenticated
                                    const isAuthenticated = await this.isUserAuthenticated(true);
                                    if (isAuthenticated) {
                                        // Try again in 1 minute
                                        setTimeout(() => this.scheduleTokenRefresh(), 60000);
                                    }
                                }
                            }, refreshIn);
                        } catch (error) {
                            console.error('Error scheduling token refresh:', error);
                        }
                    };
                    
                    // Simplified login function that explicitly uses Google
                    AuthManager.login = async function() {
                        try {
                            const client = await this.getClient();
                            
                            await client.loginWithRedirect({
                                authorizationParams: {
                                    redirect_uri: window.location.origin,
                                    scope: 'openid profile email',
                                    connection: 'google-oauth2'  // Explicitly use Google
                                }
                            });
                        } catch (error) {
                            console.error('Login redirect error:', error);
                            alert('Unable to login. Please try again.');
                        }
                    };
                    
                    // Enhanced logout with cleanup
                    AuthManager.logout = async function() {
                        try {
                            // Clear token refresh timer
                            if (this.tokenRefreshTimer) {
                                clearTimeout(this.tokenRefreshTimer);
                                this.tokenRefreshTimer = null;
                            }
                            
                            const client = await this.getClient();
                            
                            await client.logout({
                                logoutParams: {
                                    returnTo: window.location.origin
                                }
                            });
                            
                            // Clear any cached data
                            this.client = null;
                            
                            // Update UI
                            updateAuthUI();
                        } catch (error) {
                            console.error('Logout error:', error);
                            alert('Logout failed. You may still be logged in.');
                        }
                    };
                    
                    // Initialize Auth manager first
                    await AuthManager.initialize().catch(error => {
                        console.warn('Enhanced auth initialization warning:', error);
                    });
                    
                    // Initialize data processor
                    await ScenarioDataProcessor.fetchScenarios().catch(error => {
                        console.error('Error fetching initial data:', error);
                        alert('Unable to load scenario data. Please refresh the page or try again later.');
                    });
                    
                    // Initialize visualization manager
                    VisualizationManager.initialize();
                    
                    // Initialize user survey manager
                    UserSurveyManager.initialize();
                    
                    // Set up global event listeners for auth buttons
                    document.getElementById('login')?.addEventListener('click', () => {
                        AuthManager.login(false);
                    });
                    
                    document.getElementById('logout')?.addEventListener('click', () => {
                        AuthManager.logout();
                    });
                    
                    // Update auth UI
                    await updateAuthUI();
                    
                    console.log('Enhanced application initialization complete');
                    
                    // Check authentication status periodically to maintain session
                    setInterval(async () => {
                        try {
                            const isAuthenticated = await AuthManager.isUserAuthenticated(true);
                            if (isAuthenticated) {
                                // Refresh token if needed
                                await AuthManager.getToken({ 
                                    timeoutInSeconds: 10,
                                    ignoreCache: true
                                }).catch(() => {});
                            }
                        } catch (error) {
                            console.warn('Session check error:', error);
                        }
                    }, 5 * 60 * 1000); // Check every 5 minutes
                    
                } catch (error) {
                    console.error('Error during enhanced application initialization:', error);
                    alert('There was a problem initializing the application. Please refresh the page.');
                }
            }

            // Call the enhanced initialization on DOMContentLoaded
            document.addEventListener('DOMContentLoaded', initializeApplication);

            /**
             * Update UI based on authentication state with improved error handling
             */
            async function updateAuthUI() {
                try {
                    // Force fresh check of authentication status 
                    const isAuthenticated = await AuthManager.isUserAuthenticated(true);
                    
                    const elements = {
                        loginBtn: document.getElementById('login'),
                        logoutBtn: document.getElementById('logout'),
                        userContainer: document.getElementById('user-container'),
                        userAvatar: document.getElementById('user-avatar'),
                        userSurveysPreview: document.getElementById('user-surveys-preview')
                    };

                    if (isAuthenticated) {
                        if (elements.loginBtn) elements.loginBtn.style.display = 'none';
                        if (elements.userContainer) elements.userContainer.classList.remove('d-none');
                        if (elements.logoutBtn) elements.logoutBtn.style.display = 'block';
                        
                        try {
                            const user = await AuthManager.getUser();
                            if (user?.picture && elements.userAvatar) {
                                elements.userAvatar.src = user.picture;
                                elements.userAvatar.style.display = 'block';
                            }
                            
                            // Schedule token refresh
                            AuthManager.scheduleTokenRefresh();
                            
                            // Update user surveys preview
                            if (VisualizationManager.updateUserSurveysPreview) {
                                VisualizationManager.updateUserSurveysPreview();
                            }
                        } catch (profileError) {
                            console.error('Error fetching user profile:', profileError);
                            // Continue showing authenticated UI even if profile fetch fails
                        }
                    } else {
                        if (elements.loginBtn) elements.loginBtn.style.display = 'block';
                        if (elements.userContainer) elements.userContainer.classList.add('d-none');
                        if (elements.logoutBtn) elements.logoutBtn.style.display = 'none';
                        if (elements.userAvatar) elements.userAvatar.style.display = 'none';
                        
                        // Update user surveys preview for logged out state
                        if (VisualizationManager.updateUserSurveysPreview) {
                            VisualizationManager.updateUserSurveysPreview();
                        }
                        
                        // Clear token refresh timer
                        if (AuthManager.tokenRefreshTimer) {
                            clearTimeout(AuthManager.tokenRefreshTimer);
                            AuthManager.tokenRefreshTimer = null;
                        }
                    }
                } catch (error) {
                    console.error('Error updating auth UI:', error);
                    // Fallback to logged-out state on error
                    const elements = {
                        loginBtn: document.getElementById('login'),
                        userContainer: document.getElementById('user-container')
                    };
                    
                    if (elements.loginBtn) elements.loginBtn.style.display = 'block';
                    if (elements.userContainer) elements.userContainer.classList.add('d-none');
                }
            }
        </script>
        <!-- Footer Component -->
        <footer style="background-color: #e9ecef; padding: 20px 0; text-align: center; margin-top: 40px; border-top: 1px solid #dee2e6;">
            <div class="container">
                <div class="row">
                    <div class="col-md-6 mx-auto">
                        <p>&copy; 2025 The Moral Cube. All rights reserved.</p>
                        <ul class="list-inline mb-0">
                            <li class="list-inline-item"><a href="/" style="color: #4A5568; text-decoration: none;">Home</a></li>
                            <li class="list-inline-item">|</li>
                            <li class="list-inline-item"><a href="/feedback.html" style="color: #4A5568; text-decoration: none;">Feedback</a></li>
                            <li class="list-inline-item">|</li>
                            <li class="list-inline-item"><a href="/privacy-policy.html" style="color: #4A5568; text-decoration: none;">Privacy Policy</a></li>
                            <li class="list-inline-item">|</li>
                            <li class="list-inline-item"><a href="/data-deletion.html" style="color: #4A5568; text-decoration: none;">Data Deletion</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </footer>
    </body>
</html>
                            