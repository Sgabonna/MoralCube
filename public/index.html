<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Moral Cube</title>
  <!-- External Libraries -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" />
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600&family=Inter:wght@400;500&display=swap" rel="stylesheet">

  <style>
    /* Global */
    body {
      padding: 20px;
      background-color: #f8f9fa;
      font-family: 'Inter', sans-serif;
    }
    .main-container {
      max-width: 1600px;
      margin: 0 auto;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      padding: 20px;
    }

    /* Header Layout */
    .page-header {
      background-color: #D7E8FF;
      padding: 20px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .page-header .d-flex {
      position: relative;
      justify-content: center;
      align-items: center;
      margin-bottom: 1.5rem;
    }
    .page-header .logo {
      position: absolute;
      left: 20px;
    }
    .page-header .title {
      margin: 0;
      font-family: 'Playfair Display', serif;
      font-size: 5.5rem;
      font-weight: 600;
      text-align: center;
    }

    /* Navbar */
    .navbar {
      padding: 0;
      border-top: 1px solid rgba(0,0,0,0.1);
      box-shadow: 0 -2px 4px rgba(0,0,0,0.05);
    }
    .navbar-nav {
      display: flex;
      justify-content: center;
      width: 100%;
      padding: 0.5rem 0;
    }
    .nav-item {
      margin: 0 1rem;
      position: relative;
    }
    .nav-link {
      font-family: 'Inter', sans-serif !important;
      font-weight: 500;
      font-size: 1.2rem;
      padding: 0.7rem 1.2rem;
      border-radius: 4px;
      transition: background-color 0.2s ease, color 0.2s ease;
      white-space: nowrap;
    }
    .nav-link:hover {
      background-color: rgba(255,255,255,0.4);
      color: #2c5282;
    }
    .nav-item:not(:last-child)::after {
      content: "";
      position: absolute;
      right: -10px;
      top: 50%;
      transform: translateY(-50%);
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background-color: #718096;
      opacity: 0.5;
    }

    /* Responsive Navbar */
    @media (max-width: 991.98px) {
      .navbar-collapse {
        display: flex !important;
        justify-content: center !important;
        width: 100% !important;
      }
      .navbar-nav {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
      }
      .navbar-nav::-webkit-scrollbar { display: none; }
      .nav-link { font-size: 1rem; padding: 0.5rem 0.8rem; }
      .nav-item { margin: 0 0.5rem; }
    }

    /* Plot Container */
    .plot-container {
      background-color: #fff;
      border-radius: 6px;
      padding: 5px;
      height: 400px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #cube-plot { width: 100%; height: 100%; }

    /* Category Badges */
    .category-badge {
      display: inline-block;
      padding: 0.25em 0.6em;
      font-size: 0.9rem;
      font-weight: 500;
      border-radius: 4px;
      margin-left: 0.5rem;
    }
    .category-evil           { background-color: #dc3545; color: #fff; }
    .category-virtue         { background-color: #28a745; color: #fff; }
    .category-vice           { background-color: #ffc107; color: #000; }
    .category-sin            { background-color: #6c757d; color: #fff; }
    .category-morally-grey   { background-color: #6610f2; color: #fff; }
    .category-world-building { background-color: #17a2b8; color: #fff; }

    /* Scenario Cards */
    .comparison-card {
      border: 2px solid transparent;
      cursor: pointer;
      transition: border-color 0.2s;
    }
    .comparison-card.category-evil           { border-color: #dc3545; }
    .comparison-card.category-virtue         { border-color: #28a745; }
    .comparison-card.category-vice           { border-color: #ffc107; }
    .comparison-card.category-sin            { border-color: #6c757d; }
    .comparison-card.category-morally-grey   { border-color: #6610f2; }
    .comparison-card.category-world-building { border-color: #17a2b8; }

    /* Full original CSS rules should be appended below to preserve functionality */
  </style>
</head>
<body>
    <div class="main-container">
        <div class="page-header" style="background-color: #D7E8FF; padding: 20px 20px 0 20px; position: relative;">
            <div class="container-fluid">
                <!-- Logo and Title Section -->
                <div class="d-flex justify-content-between align-items-center" style="margin-bottom: 1.5rem;">
                    <a href="/" style="flex: 0 0 auto;">
                        <img src="./MoralCubeLogo.png" alt="Moral Cube Logo" style="height: 140px; width: auto; object-fit: contain;"/>
                    </a>
                    <h1 class="text-center mx-auto" style="font-family: 'Playfair Display', serif; font-size: 5.5rem; font-weight: 600; margin-right: 140px;">The Moral Cube</h1>
                    <div style="flex: 0 0 140px;"></div>
                </div>
                
                <!-- Navigation Menu -->
                <nav class="navbar navbar-expand-lg navbar-light p-0" style="margin-top: auto; border-top: 1px solid rgba(0, 0, 0, 0.1); box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.05);">
                    <div class="collapse navbar-collapse justify-content-center" id="navbarNav">
                        <ul class="navbar-nav" style="padding: 0.5rem 0;">
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="/" style="font-family: 'Inter', sans-serif; font-weight: 500; font-size: 1.2rem;">Home</a>
                            </li>
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="#" data-toggle="modal" data-target="#whatIsModal" style="font-family: 'Inter', sans-serif; font-weight: 500; font-size: 1.2rem;">What is the Moral Cube?</a>
                            </li>
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="#" data-toggle="modal" data-target="#howToUseModal" style="font-family: 'Inter', sans-serif; font-weight: 500; font-size: 1.2rem;">How to use the Cube</a>
                            </li>
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="/feedback.html" style="font-family: 'Inter', sans-serif; font-weight: 500; font-size: 1.2rem;">Feedback</a>
                            </li>
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="https://www.youtube.com/watch?v=hauuDOrZQ1o" target="_blank" style="font-family: 'Inter', sans-serif; font-weight: 500; font-size: 1.2rem;">Learn More</a>
                            </li>
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    
        <div class="filter-section">
            <div class="filter-group category-filter-group">
                <label for="categoryFilter">Categories:</label>
                <select id="categoryFilter" class="form-control category-select" multiple size="6"></select>
            </div>
            <div class="filter-group scenario-filter-group">
                <label for="scenarioFilter">
                    Scenarios
                    <span class="tooltip">
                        <i class="fas fa-info-circle info-icon"></i>
                        <span class="tooltiptext">Hold Ctrl (Cmd on Mac) to select multiple scenarios</span>
                    </span>
                </label>
                <select id="scenarioFilter" class="form-control scenario-select" multiple size="6"></select>
            </div>
            <div class="filter-group model-filter-group">
                <label for="modelFilter">
                    AI Models
                    <span class="tooltip">
                        <i class="fas fa-info-circle info-icon"></i>
                        <span class="tooltiptext">Hold Ctrl (Cmd on Mac) to select multiple models</span>
                    </span>
                </label>
                <select id="modelFilter" class="form-control model-select" multiple size="6"></select>
            </div>
            <div class="filter-group">
                <label>
                    What If Scenarios
                    <span class="tooltip">
                        <i class="fas fa-info-circle info-icon"></i>
                        <span class="tooltiptext">Hold Ctrl (Cmd on Mac) to select multiple outcomes</span>
                    </span>
                </label>
                <select id="alternateOutcomes" class="form-control" multiple size="6">
                    <option disabled>Select a scenario and model to see alternates</option>
                </select>
            </div>
            <!-- New Clear Filters button underneath the four filters -->
            <div class="filter-group">
                <button id="clearFilters" class="btn btn-secondary">Reset Filters</button>
            </div>
        </div>
        
        
        <!-- New three-column layout -->
        <div id="overview-section" style="display: flex; width: 100%;">
            <!-- Left Column: Cube Plot (40% width) -->
            <div id="cube-column" style="width: 37%;">
            <div class="plot-container">
                <div id="cube-plot"></div>
            </div>
            <!-- Moral Category Filter with Clear Filters button underneath -->
            <div class="filter-group">
                <label>Filter by Moral Category:</label>
                <div class="filter-badges">
                    <span class="filter-badge category-evil active" data-category="evil">Evil</span>
                    <span class="filter-badge category-virtue active" data-category="virtue">Virtue</span>
                    <span class="filter-badge category-vice active" data-category="vice">Vice</span>
                    <span class="filter-badge category-sin active" data-category="sin">Sin</span>
                    <span class="filter-badge category-morally-grey active" data-category="morally_grey">Morally Grey</span>
                    <span class="filter-badge category-world-building active" data-category="world_building">World Building</span>
                </div>
            </div>
            </div>
            <div id="cards-column" style="width: 18%; padding: 0 10px;">
                <p style="font-size: 0.9rem; margin-bottom: 0.5rem;">Select 2 scenarios/models to compare:</p>
                <div id="overview"></div>
            </div>
            
            <!-- Right Column: Overview Placeholder for Video/Website -->
            <div id="placeholder-overview-column" style="width: 45%; padding: 0 10px; display: flex; flex-direction: column; height: 500px;">
                <div id="media-placeholder" style="flex-grow: 1; border: none; overflow: hidden;"></div>
                <button id="open-media" class="btn btn-secondary btn-sm mt-2" style="width: 100%;">Open in New Window</button>
            </div>
              
               
        </div>
  
  

        <div id="scenarioSection" class="scenario-section">
            <h4 class="mb-3">
                Scenario Details
                <span class="tooltip-container">
                    <i class="fas fa-info-circle tooltip-icon"></i>
                    <span class="tooltip-content">Click two Scenario Cards above to compare the answers</span>
                </span>
            </h4>
            <div class="accordion" id="scenarioAccordion">
                <!-- Will be populated dynamically -->
            </div>
        </div>
    </div>
    <div class="modal fade" id="whatIsModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">What is the Moral Cube?</h5>
                    <button type="button" class="close" data-dismiss="modal">
                        <span>&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="introduction mb-4">
                        <h4 class="mb-3">Understanding the Moral Cube</h4>
                        <p>The Moral Cube is a tool designed to help people think more clearly about moral decisions. It provides a structured way to assess actions by considering three key dimensions: <strong>Ends (Goals & Intentions), Means (Sacrifice), and Character (Awareness & Self-Control).</strong></p>
                    </div>
    
                    <div class="concept mb-4">
                        <h5 class="mb-3">The Concept</h5>
                        <p>Rather than prescribing what is right or wrong, the Cube offers a space for reflection. By answering questions about motivation, sacrifice, and character, each scenario is mapped onto three orthogonal (right-angle) axes—<strong>x, y, and z.</strong> This creates a unique position within the Cube that represents the moral complexity of each action.</p>
                    </div>
    
                    <div class="purpose mb-4">
                        <h5 class="mb-3">Why Use the Moral Cube?</h5>
                        <p>The Moral Cube isn't just about exploring different perspectives—it's about understanding <em>why</em> we judge actions as right or wrong. When good intentions clash with difficult trade-offs, the Cube helps break down these decisions into clear components.</p>
                        
                        <p>By using the Cube, you can compare moral reasoning across time, between people, and even with AI systems. This comparison reveals where human and machine perspectives align or differ, offering valuable insights as AI becomes increasingly prevalent in our world.</p>
                    </div>
    
                    <div class="approach mb-4">
                        <h5 class="mb-3">Our Approach</h5>
                        <p>We often rely on intuition or cultural norms for moral judgments. The Moral Cube offers a more structured path. It helps align your values with your actions while fostering meaningful discussions about complex ethical choices.</p>
                    </div>
    
                    <div class="conclusion text-center mt-4">
                        <p><strong>Explore, reflect, and discover your moral perspective within the Cube.</strong></p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- How to Use Modal -->
    <div class="modal fade" id="howToUseModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">How to Use the Moral Cube</h5>
                    <button type="button" class="close" data-dismiss="modal">
                        <span>&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="introduction mb-4">
                        <h4 class="mb-3">Welcome to the Moral Cube</h4>
                        <p>The Moral Cube is an interactive tool for exploring ethical scenarios and their analyses by various AI models. This guide will help you navigate and maximize the platform's capabilities.</p>
                    </div>
                
                    <div class="getting-started mb-4">
                        <h5 class="mb-3">Getting Started</h5>
                        <p>Begin your exploration through either of these approaches:</p>
                        <div class="ml-4">
                            <p><strong>Category-Based Exploration:</strong> Select a Category Type to view related scenarios, providing a thematic approach to ethical exploration.</p>
                            <p><strong>Direct Scenario Selection:</strong> Choose specific scenarios from the complete list if you have particular cases in mind.</p>
                        </div>
                    </div>
                
                    <div class="comparison-features mb-4">
                        <h5 class="mb-3">Comparing Scenarios and Models</h5>
                        <p>The platform offers multiple comparison capabilities:</p>
                        <div class="ml-4">
                            <p><strong>Scenario Selection:</strong> Use Ctrl+Click (PC) or tap multiple options (mobile/tablet) to select scenarios for comparison. The system supports up to four scenarios simultaneously.</p>
                            <p><strong>AI Model Analysis:</strong> Once you select a scenario, the platform displays available AI models that have analyzed that particular case.</p>
                            <p><strong>Alternative Scenarios:</strong> Many cases include hypothetical variations, demonstrating how subtle changes in actions can significantly affect ethical positioning within the cube.</p>
                        </div>
                    </div>
                
                    <div class="detailed-analysis mb-4">
                        <h5 class="mb-3">Exploring Detailed Analysis</h5>
                        <p>For optimal analysis review:</p>
                        <div class="ml-4">
                            <p><strong>Side-by-Side Comparison:</strong> Select two scenarios to view a detailed comparison in the Scenario Details section. This limitation ensures clear and meaningful analysis presentation.</p>
                            <p><strong>Enhanced Understanding:</strong> Each question and justification includes informative tooltips. Hover over the information (i) and question (?) icons to access additional context about the models' evaluation criteria.</p>
                        </div>
                    </div>
            </div>
        </div>
    </div>
    
    <script>
        // Initialize global variables
        let dataPoints = [];
        let activeCategories = new Set(['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building']);
        let selectedComparison = []; // Will hold the IDs of the two items selected for comparison
        let selectedCategories = [];
        let selectedScenarios = [];
        let selectedModels = [];
        let selectedAlternateOutcomes = [];
        let isCategoryFiltering = false;
        let isUpdatingFilters = false;
        let scenarioRelationships = new Map(); // Stores parent-child relationships
        let currentMediaUrl = "";

        // Fixed array of shared border colors.
        const sharedBorderColors = ["purple", "blue", "black", "pink", "dark green"];
        // Mapping from scenario title to a fixed border color.
        let scenarioColorMapping = {};

        const questionTooltips = {

                "Societal Needs": {
                info: "If needs are essential elements to ensure survival and growth (e.g., food, water, security, love), then societal needs are essential for the survival and growth of a society. Societal needs include maintaining justice, fairness, and trust in social institutions (e.g., don’t lie, keep promises, don’t steal, help others, uphold justice, avoid cruelty). When these societal needs are met, societies function harmoniously, promoting the well-being of individuals within them.",
                question: "To what extent was the action focused on fulfilling societal needs such as justice, fairness, equality, respect for persons, or promoting the common good?"
            },
                "Others Needs": {
                info: "Needs are often necessary for survival or fulfilling a core purpose. When essential needs (e.g., hunger, safety, belonging) are not met, there is an increase in unpleasant sensations. Meeting these needs reduces discomfort and ensures survival and well-being. This question focuses on whether the action was aimed at fulfilling others' essential needs.",
                question: "To what extent was the action focused on fulfilling others' needs related to physiology, safety, love/belonging, esteem, or self-actualization?"
            },
                "Others Wants": {
                info: "Wants are often tied to increasing pleasant sensations or achieving rewards and favourable outcomes. They are not essential for survival but often relate to desires for financial gain, recognition, or status. This question focuses on whether the action was aimed at fulfilling others' non-essential wants.",
                question: "To what extent was the action focused on fulfilling others' wants such as financial gain, social recognition, praise, power, appearance, conformity, reward, competition, or security?"
            },
            "Personal Needs": {
                info: "Needs are often essential for personal survival or fulfilling a core purpose. When these needs are unmet, unpleasant sensations arise (e.g., hunger, lack of security or belonging). Meeting personal needs reduces this discomfort. This question focuses on whether the action was primarily aimed at fulfilling personal essential needs.",
                question: "To what degree was the action motivated by fulfilling essential personal needs such as safety, physiological survival, or self-actualisation?"
            },
            "Personal Wants": {
                info: "Wants are most often tied to desires for rewards or pleasant sensations, beyond essential needs. These can include financial gain, praise, or social recognition. This question assesses whether the action was motivated by fulfilling personal non-essential wants.",
                question: "To what extent was the action focused on fulfilling personal wants such as financial gain, social recognition, praise, power, appearance, conformity, reward, competition, or security?"
            },
            "Future Self-Sacrifice": {
                info: "Our future selves don’t exist yet and morally speaking would be considered an “other”, treated as an agent yet to come. When we make decisions that negatively impact our future, it is similar to making a decision that impacts another person’s future morally speaking. With this in mind evaluate the level of sacrifice affecting the future self, including future versions of oneself, cumulative identity, long-term values, and future aspirations. This encompasses actions that impact deeply held values, long-term plans, fundamental life goals, health, or personal well-being.",
                question: "To what extent did the action require sacrifices that impact the future self? Consider aspects like future plans, core values, psychological wellbeing, life goals, elements of personal identity and legacy, health, and long-term well-being."
            },
            "Number of Individuals Affected": {
                info: "",
                question: "How many people were impacted by the sacrifice or harm?"
            },
            "Type of Sacrifice": {
                info: "",
                question: "What was the severity of the impact on each individual in terms of what they lost (time, money, resources, freedom, life)?"
            },
            "Duration of Sacrifice": {
                info: "",
                question: "How long do you think the sacrifice affected the individuals involved (short-term vs. long-term impact)?"
            },
            "Magnitude of Life Impacted": {
                info: "Evaluate the magnitude of the sacrifice based on the type of life impacted. Smaller organisms like bacteria and insects are assigned lower values, while more complex and sentient life forms, such as animals and humans, are assigned higher values. Additionally, consider the vulnerability of individuals; for example, children or disabled humans may have a slightly higher weighting due to their increased dependency and reduced capacity to defend themselves.",
                question: "To what extent did the action impact life, considering the type and vulnerability of the affected organism(s)? Use the following scale to assess the magnitude of impact per individual:"
            },
            "Unconscious vs Conscious": {
                info: "Evaluate the individual’s level of awareness regarding their actions and their consequences. Consider whether the action was performed reflexively, partially consciously, or with full mindfulness.",
                question: "To what extent was the individual conscious of their actions and consequences?"
            },
            "Present Self-Sacrifice": {
                info: "A component of Self-Control is self-sacrifice, as we don’t exercise self-control when we want to do something, only when we don’t want to. Evaluate the level of sacrifice affecting the immediate, present self. This includes sacrifices that impact short-term desires, impulses, and needs—such as loss of comfort, overcoming impulses, inconvenience, or minor financial costs.",
                question: "To what extent did the action require sacrifices from the individual's present self? Consider aspects like immediate comfort, desires, impulses, convenience, minor financial expenditures, or brief emotional distress."
            },
            "Habit vs Will Power": {
                info: "Our actions exist somewhere on the spectrum from a habit to an exertion of will power. When we’re doing something for the first time, or when we don’t want to do something, we often require more will power. Noting that when we want to do something, or are chasing a desire, we also form habits. This question aims to reflect on whether the action was habitual or required will power, not differentiating between desire driven habits, or value aligned habits. Evaluate whether the individual acted out of ingrained habits or deliberate effort. Consider the effort required to override impulses or habitual behaviours.",
                question: "To what extent was the action driven by willpower versus habitual responses?"
            },
            "Unintentional vs Intentional": {
                info: "Our actions always have a measure of intentionality, was this what was being aimed at, was it influenced by unconscious intentions (desires), or was this a mistake (not intended at all). Assess whether the action was performed deliberately or occurred reflexively without deliberate thought.",
                question: "To what extent was the action intentional?"
            },
            "Wills at Play": {
                info: "Within each person is a composition of Wills, or unconscious drivers, with fundamental wills working together as a Will to Survive which should sit at the heart of every life form, and from that will survive do second order Wills emerging. Within the Will to survive are drives such as the Will to Consume, the Will to Homeostasis, the Will to Replicate for example, and emerging from the Will to Survive are higher order drives that might aid in our placement within a Hierarchy, or ensure genetic continuity such as a Will to Status, or a Will to Reproduction, even a Will to Create. Each of these Wills are in constant competition for airtime, there are some associated with the biological impulses (lust, envy, gluttony), and some associated with virtue (will to abstain, will to patience, empathy). Reflecting on this idea, what Wills do you think might be influencing this scenario and why?",
                question: "List the Wills and provide a one sentence justification as to why that Will might have influenced the scenario."
            },
            "Deontology": {
                info: "",
                question: "In one paragraph could you explain why this action was right or wrong through a deontological lens?"
            },
            "Utilitarianism": {
                info: "",
                question: "In two paragraphs could you explain why this action was right or wrong from a utilitarian and negative utilitarian perspective?"
            },
            "Virtue Ethics": {
                info: "",
                question: "From an Aristotelian perspective could you explain what virtues or vices were at play within this action?"
            }
        };

        // *** New function: attachComparisonCardHandlers ***
        function attachComparisonCardHandlers() {
            document.querySelectorAll('.comparison-card').forEach(card => {
                card.addEventListener('click', function() {
                    const id = card.getAttribute('data-scenario-id');
                    
                    // If card is already selected, unselect it
                    if (card.classList.contains('selected-card')) {
                        card.classList.remove('selected-card');
                        selectedComparison = selectedComparison.filter(selectedId => selectedId !== id);
                    } else {
                        // If trying to select a third card
                        if (selectedComparison.length >= 2) {
                            // Clear all selections
                            document.querySelectorAll('.comparison-card').forEach(c => {
                                c.classList.remove('selected-card');
                            });
                            selectedComparison = [];
                            
                            // Select the new card
                            card.classList.add('selected-card');
                            selectedComparison.push(id);
                        } else {
                            // Select the card normally
                            card.classList.add('selected-card');
                            selectedComparison.push(id);
                        }
                    }
                    
                    // Update scenario details based on selection
                    if (selectedComparison.length === 2) {
                        const compData = dataPoints.filter(point => 
                            selectedComparison.includes(point.id)
                        );
                        populateScenarioDetails(compData);
                    } else {
                        // Clear scenario details if fewer than 2 cards selected
                        document.getElementById('scenarioAccordion').innerHTML = `
                            <div class="text-center text-muted p-3">
                                Select two scenario cards above to compare details
                            </div>
                        `;
                    }
                });
            });
        }

        function getEthicsScores(item) {
            try {
                if (!item.dimensions) {
                    return {
                        deontologyScore: 'N/A',
                        utilitarianismScore: 'N/A',
                        virtueEthicsScore: 'N/A'
                    };
                }
                
                const philosophyDimension = item.dimensions.find(dim => 
                    dim.id.trim().toLowerCase() === 'philosophical analysis'
                );
                
                if (!philosophyDimension || !philosophyDimension.questions) {
                    return {
                        deontologyScore: 'N/A',
                        utilitarianismScore: 'N/A',
                        virtueEthicsScore: 'N/A'
                    };
                }
                
                const scores = {};
                philosophyDimension.questions.forEach(q => {
                    const questionType = q.question.trim().toLowerCase();
                    if (questionType === 'deontology') {
                        scores.deontologyScore = q.score;
                    } else if (questionType === 'utilitarianism') {
                        scores.utilitarianismScore = q.score;
                    } else if (questionType === 'virtue ethics') {
                        scores.virtueEthicsScore = q.score;
                    }
                });
                
                return scores;
            } catch (error) {
                console.error('Error extracting ethics scores:', error);
                return {
                    deontologyScore: 'N/A',
                    utilitarianismScore: 'N/A',
                    virtueEthicsScore: 'N/A'
                };
            }
        }



        // Function to render the questions into the container
        function renderSurveyQuestions() {
        const container = document.getElementById('survey-questions');
        if (!container) return; // if the container doesn't exist, exit
        
        surveyQuestions.forEach(q => {
            const questionMarkup = `
            <div class="question-container mb-3" style="font-size: 1rem;">
                <strong>${q.short}</strong>
                <!-- Info icon hover -->
                ${q.info ? `
                <span class="tooltip">
                    <i class="fas fa-info-circle info-icon"></i>
                    <span class="tooltiptext" style="max-width: 300px;">${q.info}</span>
                </span>` : ''}
                <!-- Question icon hover -->
                ${q.question ? `
                <span class="tooltip">
                    <i class="fas fa-question-circle info-icon" style="margin-left: 0.5rem;"></i>
                    <span class="tooltiptext" style="max-width: 300px;">${q.question}</span>
                </span>` : ''}
            </div>
            `;
            // Append the markup to the container
            container.innerHTML += questionMarkup;
        });
        }
        


        function normalizeCategory(category) {
            // Convert category to lowercase and replace spaces with underscores
            return category.toLowerCase().replace(/\s+/g, '_');
        }

        function fetchScenarios() {
            console.log("Starting fetchScenarios...");
            
            fetch('/.netlify/functions/fetchscenarios')
                .then(response => {
                    console.log("Fetch response status:", response.status);
                    console.log("Response headers:", Object.fromEntries(response.headers.entries()));
                    
                    if (!response.ok) {
                        throw new Error(`Network response was not ok: ${response.status} ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Detailed logging of the response
                    console.log("Raw API response data:", data);
                    console.log("Response type:", typeof data);
                    console.log("Top-level keys:", Object.keys(data));
                    
                    let scenariosToProcess;
                    
                    // Determine data structure and extract scenarios
                    if (data && Array.isArray(data.scenarios)) {
                        console.log("Found scenarios array in data.scenarios");
                        console.log("Number of scenarios:", data.scenarios.length);
                        if (data.scenarios.length > 0) {
                            console.log("First scenario structure:", {
                                keys: Object.keys(data.scenarios[0]),
                                hasMetadata: !!data.scenarios[0].metadata,
                                hasId: !!data.scenarios[0].id,
                                hasMongoId: !!data.scenarios[0]._id
                            });
                        }
                        scenariosToProcess = data.scenarios;
                    } else if (Array.isArray(data)) {
                        console.log("Data is directly an array");
                        console.log("Number of items:", data.length);
                        if (data.length > 0) {
                            console.log("First item structure:", {
                                keys: Object.keys(data[0]),
                                hasMetadata: !!data[0].metadata,
                                hasId: !!data[0].id,
                                hasMongoId: !!data[0]._id
                            });
                        }
                        scenariosToProcess = data;
                    } else {
                        console.error("Unexpected data format:", {
                            dataType: typeof data,
                            isNull: data === null,
                            isUndefined: data === undefined,
                            keys: data ? Object.keys(data) : 'no keys'
                        });
                        
                        // Attempt to salvage data if possible
                        if (data && typeof data === 'object') {
                            if (data.scenarios) {
                                console.log("Attempting to use data.scenarios despite format issues");
                                scenariosToProcess = Array.isArray(data.scenarios) ? data.scenarios : [data.scenarios];
                            } else {
                                console.log("Attempting to use entire data object as single scenario");
                                scenariosToProcess = [data];
                            }
                        } else {
                            throw new Error("Could not extract valid scenarios from response");
                        }
                    }

                    // Pre-process validation
                    if (scenariosToProcess && scenariosToProcess.length > 0) {
                        console.log("Proceeding to process scenarios");
                        console.log("Sample of first scenario:", JSON.stringify(scenariosToProcess[0], null, 2));
                        processJsonData(scenariosToProcess);
                    } else {
                        console.warn("No scenarios to process!");
                        processJsonData([]); // Process empty array to ensure UI updates
                    }
                })
                .catch(error => {
                    console.error("Error in fetchScenarios:", {
                        message: error.message,
                        stack: error.stack,
                        type: error.name
                    });
                    
                    // Log additional context
                    console.error("Error details:", {
                        timeStamp: new Date().toISOString(),
                        errorType: error.constructor.name,
                        errorMessage: error.message
                    });
                    
                    // Ensure UI is updated even in error case
                    processJsonData([]);
                });
        







                function processJsonData(data) {
                    console.log("API response data:", data);
                    console.log("Response type:", typeof data);

                    // Clear existing relationships
                    scenarioRelationships.clear();
                    dataPoints = [];
                    let displayPoints = [];  // For parent scenarios

                    // In processJsonData function, modify the flattening step:
                    let flattenedScenarios = [];
                    // Remove duplicates by using a Set of IDs
                    const processedIds = new Set();

                    data.forEach(doc => {
                        if (doc.scenarios && Array.isArray(doc.scenarios)) {
                            doc.scenarios.forEach(scenario => {
                                if (!processedIds.has(scenario.id)) {
                                    processedIds.add(scenario.id);
                                    flattenedScenarios.push(scenario);
                                }
                            });
                        }
                    });

                    console.log("Flattened scenarios (unique):", flattenedScenarios);

                    flattenedScenarios.forEach((scenario, index) => {
                        console.log(`\n--- Processing scenario at index ${index} ---`);
                        console.log("Full scenario data:", scenario);

                        // Use scenario.id as it's already in the correct format
                        const documentId = scenario.id;
                        console.log("Document ID:", documentId);

                        // These should now be defined since we're using the correct nesting level
                        console.log("Metadata:", scenario.metadata);
                        console.log("Survey data:", scenario.survey);

                        // Check if metadata exists
                        if (!scenario.metadata) {
                            console.warn(`Scenario at index ${index} is missing metadata.`);
                        }
                        // Check if metadata.title exists
                        if (!scenario.metadata || !scenario.metadata.title) {
                            console.warn(`Scenario at index ${index} is missing a title.`);
                        }

                        // Use defaults if properties are missing
                        const metadata = scenario.metadata || {};
                        const survey = scenario.survey || {};
                        const point = {
                            id: documentId,
                            scenarioTitle: metadata.title || "Untitled Scenario",
                            scenarioDescription: metadata.description || "",
                            llmName: metadata.llmSource ? metadata.llmSource.model : "Unknown Model",
                            category: metadata.category || "Uncategorized",
                            overallCategory: metadata.classification ? normalizeCategory(metadata.classification.type) : "unknown",
                            url: metadata.url || "",
                            dimensions: survey.dimensions || [],
                            x: survey.finalPosition ? survey.finalPosition.x : 0,
                            y: survey.finalPosition ? survey.finalPosition.y : 0,
                            z: survey.finalPosition ? survey.finalPosition.z : 0,
                            isParent: scenario.type === 'base',
                            parentId: scenario.parentId || null,
                            relationToBase: metadata.relationToBase || null,
                            // Add the ethics scores if available in your data structure:
                            deontologyScore: survey.deontologyScore,           // Adjust as needed
                            utilitarianismScore: survey.utilitarianismScore,       // Adjust as needed
                            virtueEthicsScore: survey.virtueEthicsScore            // Adjust as needed
                        };


                        console.log(`Created point object:`, point);
                        console.log(`Point ID: ${point.id}`);
                        console.log(`Is Parent: ${point.isParent}`);
                        console.log(`Parent ID: ${point.parentId}`);

                        dataPoints.push(point);
                        if (point.isParent) {
                            displayPoints.push(point);
                            console.log(`Added to displayPoints as parent scenario`);
                        } else if (point.parentId) {
                            // Find the matching parent (using the parent's id)
                            const parent = dataPoints.find(p => p.id === point.parentId);
                            console.log(`Searching for parent with ID: ${point.parentId}`);
                            console.log(`Found parent:`, parent);
                            
                            if (parent) {
                                if (!scenarioRelationships.has(parent.scenarioTitle)) {
                                    scenarioRelationships.set(parent.scenarioTitle, []);
                                }
                                scenarioRelationships.get(parent.scenarioTitle).push({
                                    childId: point.scenarioTitle,
                                    relationshipType: point.relationToBase,
                                    model: point.llmName,
                                    data: point
                                });
                                console.log(`Added relationship: ${parent.scenarioTitle} -> ${point.scenarioTitle}`);
                            }
                        }
                    });

                    // Log the final collections
                    console.log("\n--- Final Data Collections ---");
                    console.log("Total dataPoints:", dataPoints.length);
                    console.log("Total displayPoints:", displayPoints.length);
                    console.log("Scenario relationships:", Array.from(scenarioRelationships.entries()));

                    // Update filters using parent scenarios only
                    const uniqueScenarios = [...new Set(displayPoints.map(p => p.scenarioTitle))];
                    const uniqueModels = [...new Set(displayPoints.map(p => p.llmName))];
                    const uniqueCategories = [...new Set(displayPoints.map(p => p.category))];

                    console.log("\n--- Filter Updates ---");
                    console.log("Unique scenarios:", uniqueScenarios);
                    console.log("Unique models:", uniqueModels);
                    console.log("Unique categories:", uniqueCategories);

                    document.getElementById('modelFilter').innerHTML = uniqueModels.map(model =>
                        `<option value="${model}">${model}</option>`
                    ).join('');

                    document.getElementById('scenarioFilter').innerHTML = uniqueScenarios.map(scenario =>
                        `<option value="${scenario}">${scenario}</option>`
                    ).join('');

                    document.getElementById('categoryFilter').innerHTML = uniqueCategories.map(category =>
                        `<option value="${category}">${category}</option>`
                    ).join('');

                    document.getElementById('alternateOutcomes').innerHTML =
                        '<option disabled>Select a scenario and model to see alternates</option>';

                    activeCategories = new Set([...new Set(displayPoints.map(point => 
                        normalizeCategory(point.overallCategory)))]);

                    console.log("Active categories:", Array.from(activeCategories));

                    document.querySelectorAll('.filter-badge').forEach(badge => {
                        const category = badge.dataset.category.toLowerCase();
                        const exists = displayPoints.some(point => 
                            normalizeCategory(point.overallCategory) === category);
                        badge.style.display = exists ? 'inline-block' : 'none';
                        badge.classList.toggle('active', activeCategories.has(category));
                    });

                    // Initial visualization: show parent scenarios only
                    console.log("\n--- Creating Initial Plot ---");
                    console.log("Display points for plot:", displayPoints);
                    createPlot(displayPoints);
                }
            }


        // Visualization functions
        function createPlot(points) {
            const meshData = {
                type: 'mesh3d',
                x: [-8, 12, 12, -8, -8, 12, 12, -8],
                y: [0, 0, 0, 0, 8, 8, 8, 8],
                z: [-21.6, -21.6, 0, 0, -21.6, -21.6, 0, 0],
                i: [0, 0, 4, 4, 0, 0, 2, 2, 0, 1],
                j: [1, 2, 5, 6, 1, 5, 3, 7, 0, 2],
                k: [2, 3, 6, 7, 5, 4, 7, 6, 3, 3],
                opacity: 0.1,
                color: 'lightblue',
                showlegend: false,
                hoverinfo: 'none'
            };

            let data = [meshData];

            // Draw relationship lines (if applicable)
            const parentPoint = points.find(p => p.isParent);
            if (parentPoint && scenarioRelationships.has(parentPoint.scenarioTitle)) {
                const childPoints = points.filter(p => !p.isParent);
                childPoints.forEach(childPoint => {
                data.push({
                    type: 'scatter3d',
                    x: [parentPoint.x, childPoint.x],
                    y: [parentPoint.z, childPoint.z],
                    z: [parentPoint.y, childPoint.y],
                    mode: 'lines',
                    line: { color: '#666', width: 2, dash: 'dash' },
                    hoverinfo: 'text',
                    hovertext: `${parentPoint.scenarioTitle} → ${childPoint.scenarioTitle}`,
                    showlegend: false
                });
                });
            }

            // Plot the data points (markers)
            data.push({
                type: 'scatter3d',
                x: points.map(p => p.x),
                y: points.map(p => p.z),
                z: points.map(p => p.y),
                mode: 'markers',
                marker: {
                size: points.map(p => p.isParent ? 8 : 6),
                color: points.map(p => getColorByCategory(p.overallCategory)),
                opacity: 0.8,
                line: {
                    // Use the composite key for marker borders and increase the width.
                    color: points.map(p => scenarioColorMapping[p.scenarioTitle + '_' + p.llmName] || '#000'),
                    width: points.map(p => p.isParent ? 6 : 4)
                }
                },
                text: points.map(p => `
                <b>${p.scenarioTitle}</b><br>
                <b>Category:</b> ${p.overallCategory}<br>
                <b>Model:</b> ${p.llmName}<br>
                ${p.isParent ? '<b>Type:</b> Parent' : '<b>Type:</b> Alternative'}
                `),
                hoverinfo: 'text',
                showlegend: false
            });

            const layout = {
                margin: { l: 0, r: 0, b: 0, t: 0 },
                scene: {
                xaxis: { title: 'Altruistic - Self Motivated', range: [-8, 12], titlefont: { size: 10 } },
                yaxis: { title: 'Habit/Instinct - Will Power', range: [0, 8], titlefont: { size: 10 } },
                zaxis: { title: 'Small Sacrifice - Large sacrifice', range: [-21.6, 0], titlefont: { size: 10 } },
                camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } },
                aspectmode: 'cube',
                aspectratio: { x: 1, y: 1, z: 1 }
                }
            };

            Plotly.newPlot('cube-plot', data, layout, {
                displayModeBar: false,
                responsive: true
            });
            }

            function updateAlternateOutcomesDropdown(parentScenario, selectedModel) {
                const alternateOutcomes = document.getElementById('alternateOutcomes');
                
                if (!parentScenario || !selectedModel) {
                    alternateOutcomes.innerHTML = '<option disabled>Select one scenario and one model</option>';
                    alternateOutcomes.disabled = true;
                    return;
                }
                
                const relationships = scenarioRelationships.get(parentScenario) || [];
                const alternatives = relationships.filter(rel => rel.model === selectedModel);
                
                if (alternatives && alternatives.length > 0) {
                    alternateOutcomes.innerHTML = alternatives.map(alt => `
                        <option value="${alt.childId}">
                            ${alt.childId} ${alt.relationshipType ? `(${alt.relationshipType})` : ''}
                        </option>
                    `).join('');
                    alternateOutcomes.disabled = false;
                    alternateOutcomes.multiple = true;
                    alternateOutcomes.size = Math.min(6, alternatives.length);
                } else {
                    alternateOutcomes.innerHTML = '<option disabled>No alternate outcomes available</option>';
                    alternateOutcomes.disabled = true;
                }
            }


        function updateFilters() {
            // Model filter
            const modelFilter = document.getElementById('modelFilter');
            const models = [...new Set(dataPoints.map(point => point.llmName))];
            modelFilter.innerHTML = models.map(model => `<option value="${model}">${model}</option>`).join('');

            // Scenario filter (parent scenarios only)
            const scenarioFilter = document.getElementById('scenarioFilter');
            const scenarios = [...new Set(dataPoints.filter(p => p.isParent).map(point => point.scenarioTitle))];
            scenarioFilter.innerHTML = scenarios.map(scenario => `<option value="${scenario}">${scenario}</option>`).join('');
            
            // Category filter
            const categories = [...new Set(dataPoints.filter(p => p.isParent).map(point => point.category))];
            const categoryFilter = document.getElementById('categoryFilter');
            categoryFilter.innerHTML = categories.map(category => `<option value="${category}">${category}</option>`).join('');
            
            // Update category badges visibility and active state
            document.querySelectorAll('.filter-badge').forEach(badge => {
                const category = badge.dataset.category;
                const normalizedCategory = normalizeCategory(category);
                const exists = dataPoints.some(point => normalizeCategory(point.overallCategory) === normalizedCategory);
                badge.style.display = exists ? 'inline-block' : 'none';
                badge.classList.toggle('active', activeCategories.has(normalizedCategory));
            });
        }

       // === updateVisualization() Function ===
       function updateVisualization() {
            let filteredPoints = dataPoints;
            
            // If more than one scenario is selected, default the model to "GPT".
            if (selectedScenarios.length > 1) {
                selectedModels = ["GPT"];
            }
            
            // --- Clear highlights ---
            document.querySelectorAll('.relevant-option').forEach(el => el.classList.remove('relevant-option'));
            document.querySelectorAll('.filter-badge').forEach(badge => {
                badge.classList.remove('relevant-badge');
                badge.style.display = 'inline-block';
            });

            // --- Apply moral category filter ---
            if (activeCategories.size !== 6) {
                filteredPoints = filteredPoints.filter(point =>
                activeCategories.has(normalizeCategory(point.overallCategory))
                );
                
                const availScenarios = new Set(filteredPoints.map(p => p.scenarioTitle));
                const scenarioFilter = document.getElementById('scenarioFilter');
                Array.from(scenarioFilter.options).forEach(option => {
                option.style.display = availScenarios.has(option.value) ? 'block' : 'none';
                if (availScenarios.has(option.value)) option.classList.add('relevant-option');
                });
                
                const availModels = new Set(filteredPoints.map(p => p.llmName));
                const modelFilter = document.getElementById('modelFilter');
                Array.from(modelFilter.options).forEach(option => {
                option.style.display = availModels.has(option.value) ? 'block' : 'none';
                if (availModels.has(option.value)) option.classList.add('relevant-option');
                });
            }

            // --- Apply Category Type Filter ---
            if (selectedCategories.length > 0) {
                filteredPoints = filteredPoints.filter(point => selectedCategories.includes(point.category));
            }

            // --- Apply Scenario Filter ---
            if (selectedScenarios.length > 0) {
                filteredPoints = filteredPoints.filter(point =>
                selectedScenarios.includes(point.scenarioTitle)
                );
                
                const relModels = new Set(filteredPoints.map(p => p.llmName));
                document.querySelectorAll('#modelFilter option').forEach(option => {
                if (relModels.has(option.value)) {
                    option.style.display = 'block';
                    option.classList.add('relevant-option');
                } else {
                    option.style.display = 'none';
                    option.selected = false;
                }
                });
            }

            // --- Apply Model Filter ---
            if (selectedModels.length > 0) {
                filteredPoints = filteredPoints.filter(point => selectedModels.includes(point.llmName));
                
                const relScenarios = new Set(filteredPoints.map(p => p.scenarioTitle));
                document.querySelectorAll('#scenarioFilter option').forEach(option => {
                if (relScenarios.has(option.value)) {
                    option.style.display = 'block';
                    option.classList.add('relevant-option');
                } else {
                    option.style.display = 'none';
                    option.selected = false;
                }
                });
            }

            // --- Update category badges ---
            const relCats = new Set(filteredPoints.map(point => normalizeCategory(point.overallCategory)));
            document.querySelectorAll('.filter-badge').forEach(badge => {
                const cat = badge.dataset.category;
                badge.style.opacity = (selectedScenarios.length > 0 || selectedModels.length > 0 || activeCategories.size !== 6) 
                ? (relCats.has(cat) ? '1' : '0.3')
                : '1';
                if (relCats.has(cat)) badge.classList.add('relevant-badge');
            });

            // --- Update alternate outcomes dropdown ---
            const altOutcomes = document.getElementById('alternateOutcomes');
            if (selectedScenarios.length === 1 && selectedModels.length === 1) {
                const parentScenario = selectedScenarios[0];
                const selModel = selectedModels[0];
                const relationships = scenarioRelationships.get(parentScenario) || [];
                const alternatives = relationships.filter(child => child.model === selModel);
                
                if (alternatives && alternatives.length > 0) {
                    // Configure dropdown for multiple selection
                    altOutcomes.setAttribute('multiple', 'true');
                    altOutcomes.size = Math.min(alternatives.length, 6);
                    
                    // Update options while preserving any valid existing selections
                    const currentSelections = Array.from(altOutcomes.selectedOptions).map(opt => opt.value);
                    
                    altOutcomes.innerHTML = alternatives
                        .map(alt => {
                            const isSelected = currentSelections.includes(alt.childId) ? 'selected' : '';
                            return `
                                <option value="${alt.childId}" ${isSelected}>
                                    ${alt.childId} ${alt.relationshipType ? `(${alt.relationshipType})` : ''}
                                </option>
                            `;
                        }).join('');
                    
                    altOutcomes.disabled = false;
                    altOutcomes.style.opacity = '1';
                } else {
                    altOutcomes.innerHTML = '<option disabled>No alternate outcomes available</option>';
                    altOutcomes.disabled = true;
                    altOutcomes.style.opacity = '0.5';
                }
            } else {
                altOutcomes.innerHTML = '<option disabled>Select one scenario and model first</option>';
                altOutcomes.disabled = true;
                altOutcomes.style.opacity = '0.5';
            }
            
            // Update the section in updateVisualization that handles alternate outcomes
            if (selectedScenarios.length === 1 && selectedModels.length === 1) {
                const parentScenarioTitle = selectedScenarios[0];
                const selModel = selectedModels[0];
                
                // Find the parent scenario
                const parentPoint = dataPoints.find(p => 
                    p.scenarioTitle === parentScenarioTitle && 
                    p.llmName === selModel &&
                    p.isParent
                );
                
                if (parentPoint) {
                    // Start with the parent point
                    let points = [parentPoint];
                    
                    // Add selected alternate scenarios if any are selected
                    if (selectedAlternateOutcomes.length > 0) {
                        const rels = scenarioRelationships.get(parentScenarioTitle) || [];
                        const alternatePoints = rels
                            .filter(child => 
                                child.model === selModel && 
                                selectedAlternateOutcomes.includes(child.childId)
                            )
                            .map(child => child.data);
                        
                        points = points.concat(alternatePoints);
                    }
                    
                    filteredPoints = points;
                }
            }


            // --- Update available categories in the category filter ---
            const filtCategories = new Set(filteredPoints.map(p => p.category));
            document.querySelectorAll('#categoryFilter option').forEach(option => {
                if (filtCategories.has(option.value)) {
                option.style.display = 'block';
                option.classList.add('relevant-option');
                } else {
                option.style.display = 'none';
                option.selected = false;
                }
            });

            if (filteredPoints.length === 0) {
                alert('No data points match the current filters.');
                return;
            }

            // --- Build the shared color mapping using composite keys (scenarioTitle + "_" + llmName) ---
            const uniqueCompositeKeys = [...new Set(filteredPoints.map(p => p.scenarioTitle + '_' + p.llmName))];
            scenarioColorMapping = {};
            uniqueCompositeKeys.forEach((key, index) => {
                scenarioColorMapping[key] = sharedBorderColors[index % sharedBorderColors.length];
            });
            console.log("Shared color mapping:", scenarioColorMapping);

            // --- Update overview cards and scenario details ---
            if (selectedScenarios.length > 0) {
                const compData = filteredPoints.filter(point => selectedScenarios.includes(point.scenarioTitle));
                populateOverview(compData);
                populateScenarioDetails(compData);
            } else if (selectedModels.length === 2) {
                const compData = selectedModels.map(model =>
                filteredPoints.find(point => point.llmName === model)
                ).filter(Boolean);
                populateOverview(compData);
                populateScenarioDetails(compData);
            } else {
                // If only one scenario is selected, show a maximum of 4 models.
                let compData = Array.isArray(filteredPoints) ? filteredPoints.slice(0, 4) : filteredPoints;
                populateOverview(compData);
                populateScenarioDetails(compData);
            }

            // --- Create the 3D plot ---
            const xValues = filteredPoints.map(point => point.x);
            const yValues = filteredPoints.map(point => point.z);
            const zValues = filteredPoints.map(point => point.y);
            const plotData = [
                {
                type: 'mesh3d',
                x: [-8, 12, 12, -8, -8, 12, 12, -8],
                y: [0, 0, 0, 0, 8, 8, 8, 8],
                z: [-21.6, -21.6, 0, 0, -21.6, -21.6, 0, 0],
                i: [0, 0, 4, 4, 0, 0, 2, 2, 0, 1],
                j: [1, 2, 5, 6, 1, 5, 3, 7, 0, 2],
                k: [2, 3, 6, 7, 5, 4, 7, 6, 3, 3],
                opacity: 0.1,
                color: 'lightblue',
                showlegend: false,
                hoverinfo: 'none'
                },
                {
                type: 'scatter3d',
                x: xValues,
                y: yValues,
                z: zValues,
                mode: 'markers',
                marker: {
                    size: filteredPoints.map(p => p.isParent ? 8 : 6),
                    color: filteredPoints.map(p => getColorByCategory(p.overallCategory)),
                    opacity: 0.8,
                    line: {
                    color: filteredPoints.map(p => scenarioColorMapping[p.scenarioTitle + '_' + p.llmName] || '#000'),
                    width: filteredPoints.map(p => p.isParent ? 8 : 6)
                    }
                },
                text: filteredPoints.map(point => `
                    <b>${point.scenarioTitle}</b><br>
                    <b>Category:</b> ${point.overallCategory}<br>
                    <b>Model:</b> ${point.llmName}<br>
                    ${point.isParent ? '<b>Type:</b> Parent' : '<b>Type:</b> Alternative'}
                `),
                hoverinfo: 'text',
                showlegend: false
                }
            ];
            const layout = {
                margin: { l: 0, r: 0, b: 0, t: 0 },
                scene: {
                xaxis: { title: 'Altruistic - Self Motivated', range: [-8, 12], titlefont: { size: 10 } },
                yaxis: { title: 'Habit/Instinct - Will Power', range: [0, 8], titlefont: { size: 10 } },
                zaxis: { title: 'Small Sacrifice - Large sacrifice', range: [-21.6, 0], titlefont: { size: 10 } },
                camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } },
                aspectmode: 'cube',
                aspectratio: { x: 1, y: 1, z: 1 }
                }
            };
            Plotly.newPlot('cube-plot', plotData, layout, {
                displayModeBar: false,
                responsive: true
            });

            // --- Update the media placeholder with the selected scenario's media URL ---
            updateSelectedMedia();
            }





    
        function checkDescriptions() {
            document.querySelectorAll('.scenario-description').forEach(function(desc) {
                const textEl = desc.querySelector('.description-text');
                const readMoreLink = desc.querySelector('.read-more');
                // Compare scrollHeight (full content height) with clientHeight (visible height)
                if (textEl.scrollHeight <= textEl.clientHeight) {
                    // Content fits, hide the read more link
                    readMoreLink.style.display = 'none';
                } else {
                    readMoreLink.style.display = 'block';
                }
            });
        }


        function populateOverview(data) {
            const overviewDiv = document.getElementById('overview');
            if (!Array.isArray(data)) {
                data = [data];
            }
            
            // Sort data to show parent scenarios first
            data.sort((a, b) => (b.isParent ? 1 : 0) - (a.isParent ? 1 : 0));
            data = data.slice(0, 4); // Limit to 4 items
            
            const cards = data.map(item => {
                const scores = getEthicsScores(item);
                return `
                    <div class="comparison-card" 
                        data-scenario-id="${item.id}" 
                        style="border: 2px solid ${scenarioColorMapping[item.scenarioTitle + '_' + item.llmName] || '#000'};">
                        <h4>
                            ${getScenarioTitle(item)}
                            <small>(${item.llmName} ${getCategoryBadge(item.overallCategory)})</small>
                        </h4>
                        <div class="scenario-description">
                            <span class="description-text">
                                ${item.scenarioDescription || 'No description available'}
                            </span>
                            <span class="read-more">Read more</span>
                        </div>
                        <div class="ethics-scores">
                            <div>Deontology: ${scores.deontologyScore}</div>
                            <div>Utilitarianism: ${scores.utilitarianismScore}</div>
                            <div>Virtue Ethics: ${scores.virtueEthicsScore}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            overviewDiv.innerHTML = cards;
            attachComparisonCardHandlers();
            checkDescriptions();
        }

            // After setting overviewDiv.innerHTML = cards;
            document.querySelectorAll('.comparison-card').forEach(card => {
            card.addEventListener('click', function() {
                const id = card.getAttribute('data-scenario-id');

                // Toggle selection: if already selected, unselect it.
                if (card.classList.contains('selected-card')) {
                card.classList.remove('selected-card');
                selectedComparison = selectedComparison.filter(selectedId => selectedId !== id);
                } else {
                // Only allow selection if fewer than 2 are already selected.
                if (selectedComparison.length < 2) {
                    card.classList.add('selected-card');
                    selectedComparison.push(id);
                } else {
                    alert("You can only compare 2 scenarios/models at a time.");
                }
                }
                
                // If exactly 2 items are selected, update scenario details.
                if (selectedComparison.length === 2) {
                // Filter dataPoints to only include those with IDs in selectedComparison.
                const compData = dataPoints.filter(point => selectedComparison.includes(point.id));
                populateScenarioDetails(compData);
                } else {
                // Optionally, clear or update the scenario details if fewer than 2 are selected.
                // For example, you could clear the details:
                // document.getElementById('scenarioAccordion').innerHTML = '';
                }
            });
            });





        // Update the updateMediaDisplay function to handle URLs more robustly
        function updateMediaDisplay(url) {
            const container = document.getElementById('media-placeholder');
            const openMediaButton = document.getElementById('open-media');
            
            // Update the current URL
            currentMediaUrl = url || "";
            
            // Enable/disable the "Open in New Window" button based on URL availability
            openMediaButton.disabled = !currentMediaUrl;
            
            if (!url) {
                container.innerHTML = "<p class='text-center text-muted mt-3'>No media available for this selection</p>";
                return;
            }

            try {
                // Handle different types of URLs
                if (url.includes("reddit.com")) {
                    container.innerHTML = `
                        <blockquote class="reddit-embed" data-embed-media="true" data-height="500">
                            <a href="${url}">View this post on Reddit</a>
                        </blockquote>
                    `;
                    // Reload Reddit embed script
                    let existingScript = document.getElementById('reddit-embed-script');
                    if (existingScript) {
                        existingScript.remove();
                    }
                    let script = document.createElement('script');
                    script.id = 'reddit-embed-script';
                    script.async = true;
                    script.src = 'https://embed.reddit.com/widgets.js';
                    script.charset = 'UTF-8';
                    document.body.appendChild(script);
                } else if (url.includes("youtube.com") || url.includes("youtu.be")) {
                    // Clear the container first
                    container.innerHTML = '';
                    
                    // Extract video ID from various YouTube URL formats
                    let videoId;
                    if (url.includes('youtube.com')) {
                        const urlParams = new URL(url).searchParams;
                        videoId = urlParams.get('v');
                    } else if (url.includes('youtu.be')) {
                        videoId = url.split('/').pop().split('?')[0];
                    }

                    if (videoId) {
                        // Create a new iframe element
                        const iframe = document.createElement('iframe');
                        iframe.width = '100%';
                        iframe.height = '100%';
                        iframe.src = `https://www.youtube.com/embed/${videoId}`;
                        iframe.frameBorder = '0';
                        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
                        iframe.allowFullscreen = true;
                        
                        // Append the new iframe
                        container.appendChild(iframe);
                    } else {
                        console.error('Could not extract YouTube video ID from URL:', url);
                        container.innerHTML = `
                            <p class='text-center text-muted mt-3'>
                                Unable to display video. <a href="${url}" target="_blank">Open externally</a>
                            </p>`;
                    }
                } else {
                    // For other URLs, try to embed them directly
                    // Create a new iframe to force a refresh
                    const iframe = document.createElement('iframe');
                    iframe.style.width = '100%';
                    iframe.style.height = '100%';
                    iframe.style.border = 'none';
                    iframe.src = url;
                    iframe.allowFullscreen = true;
                    
                    // Clear the container and append the new iframe
                    container.innerHTML = '';
                    container.appendChild(iframe);
                }
            } catch (error) {
                console.error('Error updating media display:', error);
                container.innerHTML = `
                    <p class='text-center text-muted mt-3'>
                        Unable to display media. <a href="${url}" target="_blank">Open externally</a>
                    </p>`;
            }
        }

        // Helper function to convert YouTube URL to embed URL
        function convertYouTubeUrl(url) {
            try {
                let videoId;
                if (url.includes('youtube.com')) {
                    const urlParams = new URL(url).searchParams;
                    videoId = urlParams.get('v');
                } else if (url.includes('youtu.be')) {
                    videoId = url.split('/').pop().split('?')[0];
                }
                
                if (videoId) {
                    return `https://www.youtube.com/embed/${videoId}`;
                }
                return url;
            } catch (error) {
                console.error('Error converting YouTube URL:', error);
                return url;
            }
        }

        // Update the updateSelectedMedia function to include logging
        function updateSelectedMedia() {
            console.log('updateSelectedMedia called');
            console.log('Current selected scenarios:', selectedScenarios);
            
            if (selectedScenarios.length === 0) {
                console.log('No scenarios selected, clearing media');
                updateMediaDisplay("");
                return;
            }

            if (selectedScenarios.length === 1) {
                // Find all points that match the selected scenario title
                const scenarioPoints = dataPoints.filter(p => p.scenarioTitle === selectedScenarios[0]);
                console.log('Found scenario points:', scenarioPoints);
                
                // First try to find the parent scenario
                let parentScenario = scenarioPoints.find(p => p.isParent);
                
                // If no parent found but we have points, use the first point
                if (!parentScenario && scenarioPoints.length > 0) {
                    parentScenario = scenarioPoints[0];
                }
                
                if (parentScenario && parentScenario.url) {
                    console.log('Updating media with URL:', parentScenario.url);
                    updateMediaDisplay(parentScenario.url);
                } else {
                    console.log('No URL found for scenario:', selectedScenarios[0]);
                    updateMediaDisplay("");
                }
            } else {
                console.log('Multiple scenarios selected, clearing media');
                updateMediaDisplay("");
            }
        }


        function getScenarioTitle(data) {
            // Only include the link if a nonempty URL exists
            if (data.url && data.url.trim() !== "") {
                return `${data.scenarioTitle} <a href="${data.url}" target="_blank" class="scenario-link">
                            <i class="fas fa-external-link-alt"></i></a>`;
            }
            return data.scenarioTitle;
        }


        function getCategoryBadge(category) {
            let normalizedCategory = category.toLowerCase().replace(/\s+/g, '-');
            if (normalizedCategory === 'morally_grey' || normalizedCategory === 'morally-grey') {
                normalizedCategory = 'morally-grey';
            }
            const categoryClass = `category-badge category-${normalizedCategory}`;
            return `<span class="${categoryClass}">${category}</span>`;
        }
        function getColorByCategory(category) {
            const colorMap = {
                'evil': '#dc3545',
                'virtue': '#28a745',
                'vice': '#ffc107',
                'sin': '#6c757d',
                'morally_grey': '#6610f2',
                'world_building': '#17a2b8'
            };
            return colorMap[category] || 'gray';
            }
        // Helper function: normalize a category string.
        function normalizeCategory(category) {
            return category.toLowerCase().replace(/\s+/g, '_');
            }
            function populateScenarioDetails(scenarioData) {
                // Normalize input to array and limit to 2 scenarios for comparison
                if (!Array.isArray(scenarioData)) {
                    scenarioData = [scenarioData];
                }
                if (scenarioData.length > 2) {
                    scenarioData = scenarioData.slice(0, 2);
                }

                const scenarioAccordion = document.getElementById('scenarioAccordion');
                
                // Early return if no valid data
                if (!scenarioData.length || !scenarioData[0].dimensions) {
                    scenarioAccordion.innerHTML = '<div class="alert alert-info">No scenario data available.</div>';
                    return;
                }

                // Get dimension score helper
                function getDimensionScore(scenario, dimensionId) {
                    if (!['Ends', 'Means', 'Character'].includes(dimensionId)) return null;
                    
                    const scores = {
                        'Ends': scenario.x,
                        'Means': scenario.y,
                        'Character': scenario.z
                    };
                    return scores[dimensionId]?.toFixed(2) ?? null;
                }

                // Get range value helper
                function getRange(dimensionId, questionIndex) {
                    const rangeMap = {
                        'Ends': {
                            default: questionIndex < 3 ? "0 to 4" : "0 to -4"
                        },
                        'Means': {
                            0: "0 to -4",
                            1: "0 to -6",
                            2: "0 to -4",
                            3: "0 to -4",
                            4: "0.01 to 1.2"
                        },
                        'Character': {
                            0: "0 to 1",
                            1: "0 to 2",
                            2: "0 to 4",
                            3: "0 to 1"
                        }
                    };

                    return rangeMap[dimensionId]?.[questionIndex] || 
                        rangeMap[dimensionId]?.default || 
                        "N/A";
                }

                // Build table structure helper
                function getTableStructure(isPhilosophical) {
                    if (isPhilosophical) {
                        return {
                            colgroup: `
                                <col style="width:25%;">
                                <col style="width:25%;">
                                <col style="width:50%;">
                            `,
                            header: `
                                <tr>
                                    <th>Question</th>
                                    <th>Score</th>
                                    <th>Justification</th>
                                </tr>
                            `
                        };
                    }

                    return {
                        colgroup: `
                            <col style="width:10%;">
                            <col style="width:10%;">
                            <col style="width:12.5%;">
                            <col style="width:70%;">
                        `,
                        header: `
                            <tr>
                                <th>Question</th>
                                <th>Score</th>
                                <th>Range</th>
                                <th>Justification</th>
                            </tr>
                        `
                    };
                }

                // Create question row helper
                function createQuestionRow(question, tooltip, range, isPhilosophical) {
                    const tooltipHTML = tooltip ? `
                        <div style="display: inline-flex; align-items: center; gap: 4px;">
                            <span class="tooltip-container">
                                <i class="fas fa-info-circle tooltip-icon" aria-hidden="true"></i>
                                <span class="tooltip-content" role="tooltip">${tooltip.info}</span>
                            </span>
                            <span class="tooltip-container">
                                <i class="fas fa-question-circle tooltip-icon" aria-hidden="true"></i>
                                <span class="tooltip-content" role="tooltip">${tooltip.question}</span>
                            </span>
                        </div>
                    ` : '';

                    const score = typeof question.score === 'number' ? 
                        question.score.toFixed(1) : question.score;

                    if (isPhilosophical) {
                        return `
                            <tr>
                                <td>${question.question}${tooltipHTML}</td>
                                <td>${score}</td>
                                <td>${question.justification}</td>
                            </tr>
                        `;
                    }

                    return `
                        <tr>
                            <td>${question.question}${tooltipHTML}</td>
                            <td>${score}</td>
                            <td>${range}</td>
                            <td>${question.justification}</td>
                        </tr>
                    `;
                }

                // Create scenario table helper
                function createScenarioTable(scenario, dimension, isPhilosophical, dimensionId, tableStructure) {
                    const dimensionScore = getDimensionScore(scenario, dimension.id);
                    const scoreDisplay = dimensionScore !== null && 
                        ['Ends', 'Means', 'Character'].includes(dimension.id) ?
                        ` (${dimension.id} Score: ${dimensionScore})` : '';

                    const questionRows = dimension.questions.map((question, index) => {
                        const range = !isPhilosophical ? getRange(dimension.id, index) : "N/A";
                        const tooltip = questionTooltips[question.question] || null;
                        return createQuestionRow(question, tooltip, range, isPhilosophical);
                    }).join('');

                    return `
                        <div class="col-md-${scenarioData.length === 1 ? '12' : '6'} scenario-table-container">
                            <h5 class="mb-3">${scenario.scenarioTitle} (${scenario.llmName})${scoreDisplay}</h5>
                            <table class="table table-bordered compact-table">
                                <colgroup>${tableStructure.colgroup}</colgroup>
                                <thead>${tableStructure.header}</thead>
                                <tbody>${questionRows}</tbody>
                            </table>
                        </div>
                    `;
                }

                // Main content generation
                const dimensionContent = scenarioData[0].dimensions.map((dimension, index) => {
                    const dimensionId = `dimension${index}`;
                    const collapseId = `collapse${index}`;
                    const isPhilosophical = dimension.id.trim().toLowerCase() === 'philosophical analysis';
                    const tableStructure = getTableStructure(isPhilosophical);

                    const scenarioTables = scenarioData.map(scenario => 
                        createScenarioTable(
                            scenario, 
                            scenario.dimensions[index], 
                            isPhilosophical, 
                            dimensionId, 
                            tableStructure
                        )
                    ).join('');

                    return `
                        <div class="card">
                            <div class="card-header" id="${dimensionId}-header">
                                <h2 class="mb-0">
                                    <button class="btn btn-link ${index === 0 ? '' : 'collapsed'}" 
                                            type="button" 
                                            data-toggle="collapse" 
                                            data-target="#${collapseId}">
                                        <strong>${dimension.id} (${dimension.label})</strong>
                                    </button>
                                </h2>
                            </div>
                            <div id="${collapseId}" 
                                class="collapse ${index === 0 ? 'show' : ''}" 
                                data-parent="#scenarioAccordion">
                                <div class="card-body">
                                    <div class="row">
                                        ${scenarioTables}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                scenarioAccordion.innerHTML = dimensionContent;
            }








        // Event Listeners
        // Model Filter Event Listener
        document.getElementById('modelFilter').addEventListener('change', function(e) {
            if (isUpdatingFilters || isCategoryFiltering) return;
            
            selectedModels = Array.from(e.target.selectedOptions).map(option => option.value);
            
            // Enforce maximum selection limit
            if (selectedModels.length > 4) {
                alert('Please select a maximum of 4 models for comparison');
                selectedModels = selectedModels.slice(0, 4);
                Array.from(this.options).forEach(option => {
                    option.selected = selectedModels.includes(option.value);
                });
            }
            
            // Update alternate outcomes if exactly one scenario and one model are selected
            const alternateOutcomes = document.getElementById('alternateOutcomes');
            
            if (selectedScenarios.length === 1 && selectedModels.length === 1) {
                const parentScenario = selectedScenarios[0];
                const selectedModel = selectedModels[0];
                
                const relationships = scenarioRelationships.get(parentScenario) || [];
                const alternatives = relationships.filter(child => child.model === selectedModel);
                
                if (alternatives && alternatives.length > 0) {
                    // Configure dropdown for multiple selection
                    alternateOutcomes.setAttribute('multiple', 'true');
                    alternateOutcomes.size = Math.min(alternatives.length, 6);
                    alternateOutcomes.disabled = false;
                    
                    // Clear existing options
                    alternateOutcomes.innerHTML = '';
                    
                    // Add new options
                    alternatives.forEach(alt => {
                        const option = document.createElement('option');
                        option.value = alt.childId;
                        option.text = `${alt.childId} ${alt.relationshipType ? `(${alt.relationshipType})` : ''}`;
                        alternateOutcomes.appendChild(option);
                    });
                    
                    // Enable the dropdown
                    alternateOutcomes.disabled = false;
                    alternateOutcomes.style.opacity = '1';
                } else {
                    alternateOutcomes.innerHTML = '<option disabled>No alternate outcomes available</option>';
                    alternateOutcomes.disabled = true;
                    alternateOutcomes.style.opacity = '0.5';
                }
            } else {
                alternateOutcomes.innerHTML = '<option disabled>Select one scenario and model first</option>';
                alternateOutcomes.disabled = true;
                alternateOutcomes.style.opacity = '0.5';
            }
            
            updateVisualization();
        });


        document.getElementById('scenarioFilter').addEventListener('change', function(e) {
            if (isUpdatingFilters || isCategoryFiltering) return;
            
            // Clear previous selections
            selectedModels = [];
            selectedAlternateOutcomes = []; // Add this to handle alternate outcomes
            document.getElementById('modelFilter').selectedIndex = -1;
            document.getElementById('alternateOutcomes').innerHTML = '<option disabled>Select a model first</option>';
            document.getElementById('alternateOutcomes').disabled = true;
            
            // Update selected scenarios
            selectedScenarios = Array.from(e.target.selectedOptions).map(option => option.value);
            
            // Enforce maximum selection limit
            if (selectedScenarios.length > 4) {
                alert('Please select a maximum of 4 scenarios for comparison');
                selectedScenarios = selectedScenarios.slice(0, 4);
                Array.from(this.options).forEach(option => {
                    option.selected = selectedScenarios.includes(option.value);
                });
            }
            
            // Show/hide scenarios based on selection count
            const options = Array.from(this.options);
            options.forEach(option => {
                if (selectedScenarios.length < 4) {
                    option.style.display = 'block';
                } else {
                    option.style.display = selectedScenarios.includes(option.value) ? 'block' : 'none';
                }
            });
            
            // Update model filter based on selected scenarios
            const modelFilter = document.getElementById('modelFilter');
            const availableModels = new Set();
            
            selectedScenarios.forEach(scenario => {
                const scenarioData = dataPoints.filter(point => 
                    point.scenarioTitle === scenario
                );
                scenarioData.forEach(data => {
                    availableModels.add(data.llmName);
                });
            });
            
            // Populate model filter
            if (availableModels.size > 0) {
                modelFilter.innerHTML = Array.from(availableModels)
                    .map(model => `<option value="${model}">${model}</option>`)
                    .join('');
                modelFilter.disabled = false;
            } else {
                modelFilter.innerHTML = '<option disabled>No models available</option>';
                modelFilter.disabled = true;
            }
            
            updateVisualization();
        });





        // Update the alternate outcomes event listener
        document.getElementById('alternateOutcomes').addEventListener('change', function(e) {
            if (isUpdatingFilters) return;
            
            // Update selected alternate outcomes
            selectedAlternateOutcomes = Array.from(this.selectedOptions).map(opt => opt.value);
            
            // Enforce maximum of 3 selections
            if (selectedAlternateOutcomes.length > 3) {
                alert('Please select a maximum of 3 alternate scenarios');
                selectedAlternateOutcomes = selectedAlternateOutcomes.slice(0, 3);
                Array.from(this.options).forEach(option => {
                    option.selected = selectedAlternateOutcomes.includes(option.value);
                });
            }

            // Only update visualization, without refreshing other filters
            let updatedPoints = [];
            
            if (selectedScenarios.length === 1 && selectedModels.length === 1) {
                const parentScenarioTitle = selectedScenarios[0];
                const selModel = selectedModels[0];
                
                // Get the parent scenario
                const parentPoint = dataPoints.find(p => 
                    p.scenarioTitle === parentScenarioTitle && 
                    p.llmName === selModel &&
                    p.isParent
                );
                
                // Get the selected alternate scenarios
                const rels = scenarioRelationships.get(parentScenarioTitle) || [];
                const alternatePoints = rels
                    .filter(child => 
                        child.model === selModel && 
                        selectedAlternateOutcomes.includes(child.childId)
                    )
                    .map(child => child.data);
                
                if (parentPoint) {
                    updatedPoints = [parentPoint, ...alternatePoints];
                }
            }
            
            // Update only if we have points to show
            if (updatedPoints.length > 0) {
                // Update plot and overview without changing filters
                createPlot(updatedPoints);
                populateOverview(updatedPoints);
            }
        });



        // Category Filter Listener
        document.getElementById('categoryFilter').addEventListener('change', function(e) {
            if (isUpdatingFilters || isCategoryFiltering) return;
            
            // Update selected categories
            selectedCategories = Array.from(e.target.selectedOptions).map(option => option.value);
            
            // Clear other filters
            selectedScenarios = [];
            selectedModels = [];
            document.getElementById('scenarioFilter').selectedIndex = -1;
            document.getElementById('modelFilter').selectedIndex = -1;
            document.getElementById('alternateOutcomes').innerHTML = '<option disabled>Select a scenario and model first</option>';
            
            // Filter scenarios based on selected categories
            const scenarioFilter = document.getElementById('scenarioFilter');
            const availableScenarios = dataPoints.filter(point => 
                point.isParent && selectedCategories.includes(point.category)
            );
            
            // Create a Set of unique scenario titles to prevent duplicates
            const uniqueScenarios = [...new Set(availableScenarios.map(point => point.scenarioTitle))];
            
            // Update scenario filter options with unique scenarios
            scenarioFilter.innerHTML = uniqueScenarios
                .map(title => `<option value="${title}">${title}</option>`)
                .join('');
            
            // Clear model filter
            document.getElementById('modelFilter').innerHTML = '<option disabled>Select a scenario first</option>';
            
            updateVisualization();
        });



        document.addEventListener('DOMContentLoaded', fetchScenarios);
        document.addEventListener('DOMContentLoaded', () => {
        renderSurveyQuestions();
        });


        // Remove duplicate scenarioFilter listener (we now have one combined listener above)


        // Filter Badge Listener (unchanged):
        document.querySelectorAll('.filter-badge').forEach(badge => {
            badge.addEventListener('click', function() {
                if (isUpdatingFilters) return;
                
                const category = this.dataset.category;
                
                // Reset all badges to inactive
                document.querySelectorAll('.filter-badge').forEach(b => {
                    b.classList.remove('active');
                    b.style.opacity = '0.3';
                });
                
                // If clicking an already active sole category, reset all
                if (activeCategories.size === 1 && activeCategories.has(category)) {
                    activeCategories = new Set(['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building']);
                    document.querySelectorAll('.filter-badge').forEach(b => {
                        b.classList.add('active');
                        b.style.opacity = '1';
                    });
                } else {
                    // Set only this category as active
                    activeCategories = new Set([category]);
                    this.classList.add('active');
                    this.style.opacity = '1';
                }
                
                // Reset other filters
                selectedModels = [];
                selectedScenarios = [];
                selectedCategories = [];
                document.getElementById('modelFilter').selectedIndex = -1;
                document.getElementById('scenarioFilter').selectedIndex = -1;
                document.getElementById('categoryFilter').selectedIndex = -1;
                document.getElementById('alternateOutcomes').innerHTML = '<option>Select a scenario and model first</option>';
                
                updateVisualization();
            });
        });


        // Update the clear filters function to handle alternate outcomes
        document.getElementById('clearFilters').addEventListener('click', function() {
            // Reset all filter selections
            selectedModels = [];
            selectedScenarios = [];
            selectedCategories = [];
            selectedAlternateOutcomes = [];
            
            // Reset active categories
            activeCategories = new Set(['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building']);
            
            isUpdatingFilters = true;
            
            // Clear filter selections
            document.getElementById('modelFilter').selectedIndex = -1;
            document.getElementById('scenarioFilter').selectedIndex = -1;
            document.getElementById('categoryFilter').selectedIndex = -1;
            
            // Reset alternate outcomes dropdown
            const alternateOutcomes = document.getElementById('alternateOutcomes');
            alternateOutcomes.innerHTML = '<option disabled>Select one scenario and one model</option>';
            alternateOutcomes.disabled = true;
            
            // Reset filter badges
            document.querySelectorAll('.filter-badge').forEach(badge => {
                badge.classList.add('active');
                badge.style.opacity = '1';
            });
            
            isUpdatingFilters = false;
            isCategoryFiltering = false;
            
            // Update filters and visualization
            updateFilters();
            const parentScenarios = dataPoints.filter(point => point.isParent);
            createPlot(parentScenarios);
            updateVisualization();
        });

        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('read-more')) {
                // Find the parent card (.comparison-card)
                const card = e.target.closest('.comparison-card');
                card.classList.toggle('expanded');
                // Update the link text accordingly
                if (card.classList.contains('expanded')) {
                    e.target.textContent = 'Show less';
                } else {
                    e.target.textContent = 'Read more';
                }
            }
        });
        // Call the render function when the page loads
        document.addEventListener('DOMContentLoaded', () => {
        renderSurveyQuestions();
        });
        
        document.addEventListener('DOMContentLoaded', function() {
            const navbarToggler = document.querySelector('.navbar-toggler');
            const navbarCollapse = document.querySelector('.navbar-collapse');

            navbarToggler.addEventListener('click', function() {
                navbarCollapse.classList.toggle('show');
            });

            // Close menu when clicking outside
            document.addEventListener('click', function(event) {
                const isClickInside = navbarToggler.contains(event.target) || navbarCollapse.contains(event.target);
                if (!isClickInside && navbarCollapse.classList.contains('show')) {
                    navbarCollapse.classList.remove('show');
                }
            });

            // Close menu when clicking a nav link
            document.querySelectorAll('.nav-link').forEach(link => {
                link.addEventListener('click', function() {
                    if (window.innerWidth < 992) {
                        navbarCollapse.classList.remove('show');
                    }
                });
            });
        });






    </script>
</body>
</html>