<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Moral Cube</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" />
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        body {
            padding: 20px;
            background-color: #f8f9fa;
        }
        
        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
        }

        .plot-container {
            background-color: white;
            border-radius: 6px;
            padding: 5px;
            height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cube-plot {
            width: 100%;
            height: 100%;
        }

        .category-badge {
            display: inline-block;
            padding: 0.25em 0.6em;
            font-size: 0.9rem;
            font-weight: 500;
            border-radius: 4px;
            margin-left: 0.5rem;
        }

        .category-evil {
            background-color: #dc3545;
            color: white;
        }

        .category-virtue {
            background-color: #28a745;
            color: white;
        }

        .category-vice {
            background-color: #ffc107;
            color: black;
        }

        .category-sin {
            background-color: #6c757d;
            color: white;
        }

        .category-morally-grey {
            background-color: #6610f2;
            color: white;
        }

        .category-world-building {
            background-color: #17a2b8;
            color: white;
        }
        
        .parent-marker {
            border: 2px solid #000;
            opacity: 1 !important;
        }

        .child-marker {
            border: 1px dashed #666;
        }
        /* For compact tables in scenario details */
        .compact-table {
            font-size: 0.75rem;  /* Reduced font size (2 points smaller than before) */
            margin-bottom: 10px; /* Adds gap after the table */
        }

        .compact-table th,
        .compact-table td {
            padding: 4px 6px;    /* Reduced cell padding for a more compact row height */
            vertical-align: middle;
        }

        /* Optional: if you want additional gap below the table container */
        .scenario-table-container {
            margin-bottom: 10px;
        }

        /* (Optional) Adjust header font sizes if needed */
        .compact-table th {
            font-weight: bold;
        }
        .compact-table td {
            overflow: visible;
            position: relative; /* Ensure that the tooltip is positioned relative to the cell */
        }   

        .relationship-line {
            stroke-dasharray: 5,5;
            opacity: 0.6;
        }

        .selected-scenario {
            border: 3px solid #0d6efd;
            box-shadow: 0 0 5px rgba(13, 110, 253, 0.5);
        }
        .selected-card {
            background-color: #d1e7dd; /* light green background for selected cards */
            border: 2px solid #0d6efd;
            /* Optional: add a box-shadow for extra emphasis */
            box-shadow: 0 0 5px rgba(13, 110, 253, 0.8);
        }

        .relationship-badge {
            font-size: 0.8rem;
            padding: 0.2em 0.5em;
            border-radius: 3px;
            margin-left: 0.5rem;
            background-color: #e9ecef;
            color: #495057;
        }

        .relationship-active {
            background-color: #0d6efd;
            color: white;
        }

        .filter-section {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .filter-group {
            margin-bottom: 15px;
        }

        .filter-group select {
            width: 100%;
            min-height: 150px; /* Ensures consistent height across all filter boxes */
        }

        /* Specific styling for the alternate outcomes select */
        #alternateOutcomes {
            width: 100%;
            min-height: 150px;
        }

        /* Add consistent padding and text size */
        .filter-group select option {
            padding: 8px 12px;
            font-size: 14px;
        }

        /* Add consistent label styling */
        .filter-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 14px;
        }

        .filter-group label {
            font-weight: 600;
            display: block;
            margin-bottom: 8px;
        }

        .filter-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .filter-badge {
            padding: 4px 12px;
            border-radius: 20px;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.3s;
            user-select: none;
        }

        .filter-badge.active {
            opacity: 1;
        }

        .info-icon {
            color: #0d6efd;
            font-size: 0.875rem;
            margin-left: 0.5rem;
            cursor: help;
        }

        /* Initially hide the ethics scores in each card */
        .comparison-card .ethics-scores {
        display: none;
        }

        /* When the card is expanded, show the ethics scores */
        .comparison-card.expanded .ethics-scores {
        display: block;
        }

        /* New container for the three columns */
        #overview-section {
            display: flex;
            width: 100%;
            box-sizing: border-box;
        }  

        /* Left Column (Cube) – 40% width remains */
        #cube-column {
            width: 40%;
            }
        #cards-column {
        width: 15%;
        }

        /* Middle Column (Placeholder Overview) – 45% width */
        #placeholder-overview-column {
            width: 45%;
            }

        /* Right Column (Stacked Overview Cards) – 15% width */
        

        /* The container for the stacked overview cards:
        Fixed height for 5 cards (e.g., 500px total) */
        #overview {
            height: 500px;            /* Adjust if needed */
            overflow: hidden;         /* By default, hide overflow */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }



        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip-container {
            position: relative;
            display: inline-flex;
            align-items: center;
            margin-left: 8px;
            vertical-align: middle;
        }

        .tooltip-icon {
            color: #0d6efd;
            font-size: 14px;
            cursor: help;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .tooltip-icon:hover {
            opacity: 1;
        }

        .tooltip-content {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: 150%;
            left: 20px; /* Base positioning for all tooltips */
            padding: 8px 12px;
            background-color: #2d3748;
            color: white;
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.4;
            white-space: normal;
            max-width: 300px;
            width: max-content;
            z-index: 1000;
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: left;
        }

        /* Remove all left/right specific rules and use the same positioning for both */
        .tooltip-container .tooltip-content {
            left: 5px;
            right: auto;
            transform: none;
        }

        .tooltip-container .tooltip-content::after {
            left: 5px;
            right: auto;
            transform: none;
        }

        .tooltip-container:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
            bottom: 140%;
        }

        .tooltip-content::after {
            content: "";
            position: absolute;
            top: 100%;
            border-width: 6px;
            border-style: solid;
            border-color: #2d3748 transparent transparent transparent;
        }

        /* Remove any specific first-child or last-child rules that might override */
        .tooltip-container:first-child .tooltip-content,
        .tooltip-container:last-child .tooltip-content {
            left: 5px;
            right: auto;
        }

        .tooltip-container:first-child .tooltip-content::after,
        .tooltip-container:last-child .tooltip-content::after {
            left: 5px;
            right: auto;
        }

        /* Prevent tooltip from being cut off at the top of the viewport */
        @media (max-height: 500px) {
            .tooltip-content {
                bottom: auto;
                top: 150%;
            }
            
            .tooltip-container:hover .tooltip-content {
                bottom: auto;
                top: 140%;
            }
            
            .tooltip-content::after {
                top: auto;
                bottom: 100%;
                border-color: transparent transparent #2d3748 transparent;
            }
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            opacity: 0;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 4px;
            padding: 5px 10px;
            position: absolute;
            z-index: 1000; /* increased z-index */
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            transition: opacity 0.3s;
            white-space: nowrap;
            font-size: 0.75rem;
        }


        .tooltiptext {
            visibility: hidden;
            opacity: 0;
            background-color: #333;
            color: #fff;
            text-align: center;
            padding: 5px 10px;
            border-radius: 4px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            transition: opacity 0.3s;
            white-space: nowrap;
            font-size: 0.75rem;
        }

        .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        #overview {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        /* Ensure that embedded iframes fill the media container */
        #media-placeholder iframe {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: contain;
        }



        .comparison-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;  /* Reduced gap for a more compact layout */
        }
        /* Adjust badge size specifically within overview cards */
        .comparison-card .category-badge {
        font-size: 0.65rem;       /* Smaller font size (adjust as needed) */
        padding: 0.1em 0.3em;      /* Reduced padding for a sleeker look */
        }
        .scenario-section {
            margin-top: 20px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }
        .scenario-table-container {
            margin-bottom: 10px;
        }

        /* Each overview card (stacked vertically) */
        .comparison-card {
            cursor: pointer;
            height: 125px;  /* Fixed height for each card (e.g., 125px if container is 500px) */
            box-sizing: border-box;
            padding: 5px 8px;
            margin-bottom: 5px;
            overflow: hidden;
            font-size: 0.75rem;       /* Reduced font size */
            transition: height 0.3s ease;
            }

        /* When the card is expanded (via read more), allow it to grow */
        .comparison-card.expanded {
            height: auto;
            overflow: visible;
            }

        /* Alternate background colors for cards */
        .comparison-card:nth-child(odd) {
            background-color: #e9ecef;
            }
        .comparison-card:nth-child(even) {
            background-color: #f8f9fa;
            }

        /* Make the heading smaller within the card */
        .comparison-card h4 {
            font-size: 0.8rem;
            margin: 0;
            }

        /* Read More Functionality for the card description */
        .scenario-description .description-text {
            display: -webkit-box;
            -webkit-line-clamp: 2;  /* Clamp to 2 lines for a compact look */
            -webkit-box-orient: vertical;
            overflow: hidden;
            transition: all 0.3s ease;
            }
        .comparison-card.expanded .scenario-description .description-text {
            -webkit-line-clamp: unset;
            }
        .read-more {
            display: block;
            color: #007bff;
            cursor: pointer;
            font-size: 0.7rem;
            margin-top: 3px;
            }

        .table {
            margin-bottom: 0;
            font-size: 1rem;
        }

        .table th {
            background-color: #f8f9fa;
            font-weight: 600;
            border-bottom: 2px solid #dee2e6;
            padding: 12px;
        }

        .table td {
            vertical-align: middle;
            padding: 12px;
        }

        .scenario-link {
            color: #0d6efd;
            margin-left: 5px;
            font-size: 0.9em;
        }

        @media (max-width: 992px) {
            .plot-container {
                height: 350px;
                margin-bottom: 20px;
            }
            
            .main-container {
                padding: 15px;
            }
            
            .comparison-container {
                grid-template-columns: 1fr;
            }
        }

        .relevant-option {
            background-color: #d1e7dd;
        }

        .relevant-badge {
            border: 2px solid #0d6efd;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="page-header mb-4" style="background-color: #D7E8FF; padding: 20px; border-radius: 8px;">
            <div style="position: relative;">
                <a href="/" style="position: absolute; left: 20px; top: 50%; transform: translateY(-50%);">
                    <img src="public/MoralCubeLogo.png" alt="Moral Cube Logo" style="width: 50px; height: 50px;"/>
                </a>
                <h1 class="text-center mb-0">The Moral Cube</h1>
            </div>
            <div class="intro-section text-center mb-3">
                <p class="mb-2">Navigate ethical scenarios in 3D space: Select categories to explore scenarios, choose AI models to compare responses, and discover alternate outcomes. Clear filters anytime to reset.</p>
                <p class="text-center mb-2">Any feedback or suggestions please email: themoralcube@gmail.com</p>
                <p class="text-center mb-2"><a href="https://www.youtube.com/watch?v=hauuDOrZQ1o">Click here to learn more about the Moral Cube</a></p>
            </div>
        </div>
        <div class="filter-section">
            <div class="filter-group category-filter-group">
                <label for="categoryFilter">Filter by Category Type:</label>
                <select id="categoryFilter" class="form-control category-select" multiple size="6"></select>
            </div>
            <div class="filter-group scenario-filter-group">
                <label for="scenarioFilter">
                    Compare Scenarios (max 4)
                    <span class="tooltip">
                        <i class="fas fa-info-circle info-icon"></i>
                        <span class="tooltiptext">Hold Ctrl (Cmd on Mac) to select multiple scenarios</span>
                    </span>
                </label>
                <select id="scenarioFilter" class="form-control scenario-select" multiple size="6"></select>
            </div>
            <div class="filter-group model-filter-group">
                <label for="modelFilter">
                    Compare AI Models (max 4)
                    <span class="tooltip">
                        <i class="fas fa-info-circle info-icon"></i>
                        <span class="tooltiptext">Hold Ctrl (Cmd on Mac) to select multiple models</span>
                    </span>
                </label>
                <select id="modelFilter" class="form-control model-select" multiple size="6"></select>
            </div>
            <div class="filter-group">
                <label>
                    Compare Alternate Outcomes
                    <span class="tooltip">
                        <i class="fas fa-info-circle info-icon"></i>
                        <span class="tooltiptext">Hold Ctrl (Cmd on Mac) to select multiple outcomes</span>
                    </span>
                </label>
                <select id="alternateOutcomes" class="form-control" multiple size="6">
                    <option disabled>Select a scenario and model to see alternates</option>
                </select>
            </div>
            <!-- New Clear Filters button underneath the four filters -->
            <div class="filter-group">
                <button id="clearFilters" class="btn btn-secondary">Reset Filters</button>
            </div>
        </div>
        
        
        <!-- New three-column layout -->
        <div id="overview-section" style="display: flex; width: 100%;">
            <!-- Left Column: Cube Plot (40% width) -->
            <div id="cube-column" style="width: 37%;">
            <div class="plot-container">
                <div id="cube-plot"></div>
            </div>
            <!-- Moral Category Filter with Clear Filters button underneath -->
            <div class="filter-group">
                <label>Filter by Moral Category:</label>
                <div class="filter-badges">
                    <span class="filter-badge category-evil active" data-category="evil">Evil</span>
                    <span class="filter-badge category-virtue active" data-category="virtue">Virtue</span>
                    <span class="filter-badge category-vice active" data-category="vice">Vice</span>
                    <span class="filter-badge category-sin active" data-category="sin">Sin</span>
                    <span class="filter-badge category-morally-grey active" data-category="morally_grey">Morally Grey</span>
                    <span class="filter-badge category-world-building active" data-category="world_building">World Building</span>
                </div>
            </div>
            </div>
            <div id="cards-column" style="width: 18%; padding: 0 10px;">
                <p style="font-size: 0.9rem; margin-bottom: 0.5rem;">Select 2 scenarios/models to compare:</p>
                <div id="overview"></div>
            </div>
            
            <!-- Right Column: Overview Placeholder for Video/Website -->
            <div id="placeholder-overview-column" style="width: 45%; padding: 0 10px; display: flex; flex-direction: column; height: 500px;">
                <div id="media-placeholder" style="flex-grow: 1; border: none; overflow: hidden;"></div>
                <button id="open-media" class="btn btn-secondary btn-sm mt-2" style="width: 100%;">Open in New Window</button>
            </div>
              
               
        </div>
  
  

        <div id="scenarioSection" class="scenario-section">
            <h4 class="mb-3">
                Scenario Details
                <span class="tooltip-container">
                    <i class="fas fa-info-circle tooltip-icon"></i>
                    <span class="tooltip-content">Click two Scenario Cards above to compare the answers</span>
                </span>
            </h4>
            <div class="accordion" id="scenarioAccordion">
                <!-- Will be populated dynamically -->
            </div>
        </div>
    </div>
    
    <script>
        // Initialize global variables
        let dataPoints = [];
        let activeCategories = new Set(['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building']);
        let selectedComparison = []; // Will hold the IDs of the two items selected for comparison
        let selectedCategories = [];
        let selectedScenarios = [];
        let selectedModels = [];
        let isCategoryFiltering = false;
        let isUpdatingFilters = false;
        let scenarioRelationships = new Map(); // Stores parent-child relationships
        let currentMediaUrl = "";

        // Fixed array of shared border colors.
        const sharedBorderColors = ["purple", "blue", "black", "pink", "dark green"];
        // Mapping from scenario title to a fixed border color.
        let scenarioColorMapping = {};

        const questionTooltips = {

                "Societal Needs": {
                info: "If needs are essential elements to ensure survival and growth (e.g., food, water, security, love), then societal needs are essential for the survival and growth of a society. Societal needs include maintaining justice, fairness, and trust in social institutions (e.g., don’t lie, keep promises, don’t steal, help others, uphold justice, avoid cruelty). When these societal needs are met, societies function harmoniously, promoting the well-being of individuals within them.",
                question: "To what extent was the action focused on fulfilling societal needs such as justice, fairness, equality, respect for persons, or promoting the common good?"
            },
                "Others Needs": {
                info: "Needs are often necessary for survival or fulfilling a core purpose. When essential needs (e.g., hunger, safety, belonging) are not met, there is an increase in unpleasant sensations. Meeting these needs reduces discomfort and ensures survival and well-being. This question focuses on whether the action was aimed at fulfilling others' essential needs.",
                question: "To what extent was the action focused on fulfilling others' needs related to physiology, safety, love/belonging, esteem, or self-actualization?"
            },
                "Others Wants": {
                info: "Wants are often tied to increasing pleasant sensations or achieving rewards and favourable outcomes. They are not essential for survival but often relate to desires for financial gain, recognition, or status. This question focuses on whether the action was aimed at fulfilling others' non-essential wants.",
                question: "To what extent was the action focused on fulfilling others' wants such as financial gain, social recognition, praise, power, appearance, conformity, reward, competition, or security?"
            },
            "Personal Needs": {
                info: "Needs are often essential for personal survival or fulfilling a core purpose. When these needs are unmet, unpleasant sensations arise (e.g., hunger, lack of security or belonging). Meeting personal needs reduces this discomfort. This question focuses on whether the action was primarily aimed at fulfilling personal essential needs.",
                question: "To what degree was the action motivated by fulfilling essential personal needs such as safety, physiological survival, or self-actualisation?"
            },
            "Personal Wants": {
                info: "Wants are most often tied to desires for rewards or pleasant sensations, beyond essential needs. These can include financial gain, praise, or social recognition. This question assesses whether the action was motivated by fulfilling personal non-essential wants.",
                question: "To what extent was the action focused on fulfilling personal wants such as financial gain, social recognition, praise, power, appearance, conformity, reward, competition, or security?"
            },
            "Future Self-Sacrifice": {
                info: "Our future selves don’t exist yet and morally speaking would be considered an “other”, treated as an agent yet to come. When we make decisions that negatively impact our future, it is similar to making a decision that impacts another person’s future morally speaking. With this in mind evaluate the level of sacrifice affecting the future self, including future versions of oneself, cumulative identity, long-term values, and future aspirations. This encompasses actions that impact deeply held values, long-term plans, fundamental life goals, health, or personal well-being.",
                question: "To what extent did the action require sacrifices that impact the future self? Consider aspects like future plans, core values, psychological wellbeing, life goals, elements of personal identity and legacy, health, and long-term well-being."
            },
            "Number of Individuals Affected": {
                info: "",
                question: "How many people were impacted by the sacrifice or harm?"
            },
            "Type of Sacrifice": {
                info: "",
                question: "What was the severity of the impact on each individual in terms of what they lost (time, money, resources, freedom, life)?"
            },
            "Duration of Sacrifice": {
                info: "",
                question: "How long do you think the sacrifice affected the individuals involved (short-term vs. long-term impact)?"
            },
            "Magnitude of Life Impacted": {
                info: "Evaluate the magnitude of the sacrifice based on the type of life impacted. Smaller organisms like bacteria and insects are assigned lower values, while more complex and sentient life forms, such as animals and humans, are assigned higher values. Additionally, consider the vulnerability of individuals; for example, children or disabled humans may have a slightly higher weighting due to their increased dependency and reduced capacity to defend themselves.",
                question: "To what extent did the action impact life, considering the type and vulnerability of the affected organism(s)? Use the following scale to assess the magnitude of impact per individual:"
            },
            "Unconscious vs Conscious": {
                info: "Evaluate the individual’s level of awareness regarding their actions and their consequences. Consider whether the action was performed reflexively, partially consciously, or with full mindfulness.",
                question: "To what extent was the individual conscious of their actions and consequences?"
            },
            "Present Self-Sacrifice": {
                info: "A component of Self-Control is self-sacrifice, as we don’t exercise self-control when we want to do something, only when we don’t want to. Evaluate the level of sacrifice affecting the immediate, present self. This includes sacrifices that impact short-term desires, impulses, and needs—such as loss of comfort, overcoming impulses, inconvenience, or minor financial costs.",
                question: "To what extent did the action require sacrifices from the individual's present self? Consider aspects like immediate comfort, desires, impulses, convenience, minor financial expenditures, or brief emotional distress."
            },
            "Habit vs Will Power": {
                info: "Our actions exist somewhere on the spectrum from a habit to an exertion of will power. When we’re doing something for the first time, or when we don’t want to do something, we often require more will power. Noting that when we want to do something, or are chasing a desire, we also form habits. This question aims to reflect on whether the action was habitual or required will power, not differentiating between desire driven habits, or value aligned habits. Evaluate whether the individual acted out of ingrained habits or deliberate effort. Consider the effort required to override impulses or habitual behaviours.",
                question: "To what extent was the action driven by willpower versus habitual responses?"
            },
            "Unintentional vs. Intentional": {
                info: "Our actions always have a measure of intentionality, was this what was being aimed at, was it influenced by unconscious intentions (desires), or was this a mistake (not intended at all). Assess whether the action was performed deliberately or occurred reflexively without deliberate thought.",
                question: "To what extent was the action intentional?"
            },
            "Wills at Play": {
                info: "Within each person is a composition of Wills, or unconscious drivers, with fundamental wills working together as a Will to Survive which should sit at the heart of every life form, and from that will survive do second order Wills emerging. Within the Will to survive are drives such as the Will to Consume, the Will to Homeostasis, the Will to Replicate for example, and emerging from the Will to Survive are higher order drives that might aid in our placement within a Hierarchy, or ensure genetic continuity such as a Will to Status, or a Will to Reproduction, even a Will to Create. Each of these Wills are in constant competition for airtime, there are some associated with the biological impulses (lust, envy, gluttony), and some associated with virtue (will to abstain, will to patience, empathy). Reflecting on this idea, what Wills do you think might be influencing this scenario and why?",
                question: "List the Wills and provide a one sentence justification as to why that Will might have influenced the scenario."
            },
            "Deontology": {
                info: "",
                question: "In one paragraph could you explain why this action was right or wrong through a deontological lens?"
            },
            "Utilitarianism": {
                info: "",
                question: "In two paragraphs could you explain why this action was right or wrong from a utilitarian and negative utilitarian perspective?"
            },
            "Virtue Ethics": {
                info: "",
                question: "From an Aristotelian perspective could you explain what virtues or vices were at play within this action?"
            }
        };

        // *** New function: attachComparisonCardHandlers ***
        function attachComparisonCardHandlers() {
            document.querySelectorAll('.comparison-card').forEach(card => {
                card.addEventListener('click', function() {
                    const id = card.getAttribute('data-scenario-id');
                    
                    // If card is already selected, unselect it
                    if (card.classList.contains('selected-card')) {
                        card.classList.remove('selected-card');
                        selectedComparison = selectedComparison.filter(selectedId => selectedId !== id);
                    } else {
                        // If trying to select a third card
                        if (selectedComparison.length >= 2) {
                            // Clear all selections
                            document.querySelectorAll('.comparison-card').forEach(c => {
                                c.classList.remove('selected-card');
                            });
                            selectedComparison = [];
                            
                            // Select the new card
                            card.classList.add('selected-card');
                            selectedComparison.push(id);
                        } else {
                            // Select the card normally
                            card.classList.add('selected-card');
                            selectedComparison.push(id);
                        }
                    }
                    
                    // Update scenario details based on selection
                    if (selectedComparison.length === 2) {
                        const compData = dataPoints.filter(point => 
                            selectedComparison.includes(point.id)
                        );
                        populateScenarioDetails(compData);
                    } else {
                        // Clear scenario details if fewer than 2 cards selected
                        document.getElementById('scenarioAccordion').innerHTML = `
                            <div class="text-center text-muted p-3">
                                Select two scenario cards above to compare details
                            </div>
                        `;
                    }
                });
            });
        }

        function getEthicsScores(item) {
            try {
                if (!item.dimensions) {
                    return {
                        deontologyScore: 'N/A',
                        utilitarianismScore: 'N/A',
                        virtueEthicsScore: 'N/A'
                    };
                }
                
                const philosophyDimension = item.dimensions.find(dim => 
                    dim.id.trim().toLowerCase() === 'philosophical analysis'
                );
                
                if (!philosophyDimension || !philosophyDimension.questions) {
                    return {
                        deontologyScore: 'N/A',
                        utilitarianismScore: 'N/A',
                        virtueEthicsScore: 'N/A'
                    };
                }
                
                const scores = {};
                philosophyDimension.questions.forEach(q => {
                    const questionType = q.question.trim().toLowerCase();
                    if (questionType === 'deontology') {
                        scores.deontologyScore = q.score;
                    } else if (questionType === 'utilitarianism') {
                        scores.utilitarianismScore = q.score;
                    } else if (questionType === 'virtue ethics') {
                        scores.virtueEthicsScore = q.score;
                    }
                });
                
                return scores;
            } catch (error) {
                console.error('Error extracting ethics scores:', error);
                return {
                    deontologyScore: 'N/A',
                    utilitarianismScore: 'N/A',
                    virtueEthicsScore: 'N/A'
                };
            }
        }



        // Function to render the questions into the container
        function renderSurveyQuestions() {
        const container = document.getElementById('survey-questions');
        if (!container) return; // if the container doesn't exist, exit
        
        surveyQuestions.forEach(q => {
            const questionMarkup = `
            <div class="question-container mb-3" style="font-size: 1rem;">
                <strong>${q.short}</strong>
                <!-- Info icon hover -->
                ${q.info ? `
                <span class="tooltip">
                    <i class="fas fa-info-circle info-icon"></i>
                    <span class="tooltiptext" style="max-width: 300px;">${q.info}</span>
                </span>` : ''}
                <!-- Question icon hover -->
                ${q.question ? `
                <span class="tooltip">
                    <i class="fas fa-question-circle info-icon" style="margin-left: 0.5rem;"></i>
                    <span class="tooltiptext" style="max-width: 300px;">${q.question}</span>
                </span>` : ''}
            </div>
            `;
            // Append the markup to the container
            container.innerHTML += questionMarkup;
        });
        }
        


        function normalizeCategory(category) {
            // Convert category to lowercase and replace spaces with underscores
            return category.toLowerCase().replace(/\s+/g, '_');
        }

        function fetchScenarios() {
            console.log("Starting fetchScenarios...");
            
            fetch('/.netlify/functions/fetchscenarios')
                .then(response => {
                    console.log("Fetch response status:", response.status);
                    console.log("Response headers:", Object.fromEntries(response.headers.entries()));
                    
                    if (!response.ok) {
                        throw new Error(`Network response was not ok: ${response.status} ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Detailed logging of the response
                    console.log("Raw API response data:", data);
                    console.log("Response type:", typeof data);
                    console.log("Top-level keys:", Object.keys(data));
                    
                    let scenariosToProcess;
                    
                    // Determine data structure and extract scenarios
                    if (data && Array.isArray(data.scenarios)) {
                        console.log("Found scenarios array in data.scenarios");
                        console.log("Number of scenarios:", data.scenarios.length);
                        if (data.scenarios.length > 0) {
                            console.log("First scenario structure:", {
                                keys: Object.keys(data.scenarios[0]),
                                hasMetadata: !!data.scenarios[0].metadata,
                                hasId: !!data.scenarios[0].id,
                                hasMongoId: !!data.scenarios[0]._id
                            });
                        }
                        scenariosToProcess = data.scenarios;
                    } else if (Array.isArray(data)) {
                        console.log("Data is directly an array");
                        console.log("Number of items:", data.length);
                        if (data.length > 0) {
                            console.log("First item structure:", {
                                keys: Object.keys(data[0]),
                                hasMetadata: !!data[0].metadata,
                                hasId: !!data[0].id,
                                hasMongoId: !!data[0]._id
                            });
                        }
                        scenariosToProcess = data;
                    } else {
                        console.error("Unexpected data format:", {
                            dataType: typeof data,
                            isNull: data === null,
                            isUndefined: data === undefined,
                            keys: data ? Object.keys(data) : 'no keys'
                        });
                        
                        // Attempt to salvage data if possible
                        if (data && typeof data === 'object') {
                            if (data.scenarios) {
                                console.log("Attempting to use data.scenarios despite format issues");
                                scenariosToProcess = Array.isArray(data.scenarios) ? data.scenarios : [data.scenarios];
                            } else {
                                console.log("Attempting to use entire data object as single scenario");
                                scenariosToProcess = [data];
                            }
                        } else {
                            throw new Error("Could not extract valid scenarios from response");
                        }
                    }

                    // Pre-process validation
                    if (scenariosToProcess && scenariosToProcess.length > 0) {
                        console.log("Proceeding to process scenarios");
                        console.log("Sample of first scenario:", JSON.stringify(scenariosToProcess[0], null, 2));
                        processJsonData(scenariosToProcess);
                    } else {
                        console.warn("No scenarios to process!");
                        processJsonData([]); // Process empty array to ensure UI updates
                    }
                })
                .catch(error => {
                    console.error("Error in fetchScenarios:", {
                        message: error.message,
                        stack: error.stack,
                        type: error.name
                    });
                    
                    // Log additional context
                    console.error("Error details:", {
                        timeStamp: new Date().toISOString(),
                        errorType: error.constructor.name,
                        errorMessage: error.message
                    });
                    
                    // Ensure UI is updated even in error case
                    processJsonData([]);
                });
        







                function processJsonData(data) {
                    console.log("API response data:", data);
                    console.log("Response type:", typeof data);

                    // Clear existing relationships
                    scenarioRelationships.clear();
                    dataPoints = [];
                    let displayPoints = [];  // For parent scenarios

                    // In processJsonData function, modify the flattening step:
                    let flattenedScenarios = [];
                    // Remove duplicates by using a Set of IDs
                    const processedIds = new Set();

                    data.forEach(doc => {
                        if (doc.scenarios && Array.isArray(doc.scenarios)) {
                            doc.scenarios.forEach(scenario => {
                                if (!processedIds.has(scenario.id)) {
                                    processedIds.add(scenario.id);
                                    flattenedScenarios.push(scenario);
                                }
                            });
                        }
                    });

                    console.log("Flattened scenarios (unique):", flattenedScenarios);

                    flattenedScenarios.forEach((scenario, index) => {
                        console.log(`\n--- Processing scenario at index ${index} ---`);
                        console.log("Full scenario data:", scenario);

                        // Use scenario.id as it's already in the correct format
                        const documentId = scenario.id;
                        console.log("Document ID:", documentId);

                        // These should now be defined since we're using the correct nesting level
                        console.log("Metadata:", scenario.metadata);
                        console.log("Survey data:", scenario.survey);

                        // Check if metadata exists
                        if (!scenario.metadata) {
                            console.warn(`Scenario at index ${index} is missing metadata.`);
                        }
                        // Check if metadata.title exists
                        if (!scenario.metadata || !scenario.metadata.title) {
                            console.warn(`Scenario at index ${index} is missing a title.`);
                        }

                        // Use defaults if properties are missing
                        const metadata = scenario.metadata || {};
                        const survey = scenario.survey || {};
                        const point = {
                            id: documentId,
                            scenarioTitle: metadata.title || "Untitled Scenario",
                            scenarioDescription: metadata.description || "",
                            llmName: metadata.llmSource ? metadata.llmSource.model : "Unknown Model",
                            category: metadata.category || "Uncategorized",
                            overallCategory: metadata.classification ? normalizeCategory(metadata.classification.type) : "unknown",
                            url: metadata.url || "",
                            dimensions: survey.dimensions || [],
                            x: survey.finalPosition ? survey.finalPosition.x : 0,
                            y: survey.finalPosition ? survey.finalPosition.y : 0,
                            z: survey.finalPosition ? survey.finalPosition.z : 0,
                            isParent: scenario.type === 'base',
                            parentId: scenario.parentId || null,
                            relationToBase: metadata.relationToBase || null,
                            // Add the ethics scores if available in your data structure:
                            deontologyScore: survey.deontologyScore,           // Adjust as needed
                            utilitarianismScore: survey.utilitarianismScore,       // Adjust as needed
                            virtueEthicsScore: survey.virtueEthicsScore            // Adjust as needed
                        };


                        console.log(`Created point object:`, point);
                        console.log(`Point ID: ${point.id}`);
                        console.log(`Is Parent: ${point.isParent}`);
                        console.log(`Parent ID: ${point.parentId}`);

                        dataPoints.push(point);
                        if (point.isParent) {
                            displayPoints.push(point);
                            console.log(`Added to displayPoints as parent scenario`);
                        } else if (point.parentId) {
                            // Find the matching parent (using the parent's id)
                            const parent = dataPoints.find(p => p.id === point.parentId);
                            console.log(`Searching for parent with ID: ${point.parentId}`);
                            console.log(`Found parent:`, parent);
                            
                            if (parent) {
                                if (!scenarioRelationships.has(parent.scenarioTitle)) {
                                    scenarioRelationships.set(parent.scenarioTitle, []);
                                }
                                scenarioRelationships.get(parent.scenarioTitle).push({
                                    childId: point.scenarioTitle,
                                    relationshipType: point.relationToBase,
                                    model: point.llmName,
                                    data: point
                                });
                                console.log(`Added relationship: ${parent.scenarioTitle} -> ${point.scenarioTitle}`);
                            }
                        }
                    });

                    // Log the final collections
                    console.log("\n--- Final Data Collections ---");
                    console.log("Total dataPoints:", dataPoints.length);
                    console.log("Total displayPoints:", displayPoints.length);
                    console.log("Scenario relationships:", Array.from(scenarioRelationships.entries()));

                    // Update filters using parent scenarios only
                    const uniqueScenarios = [...new Set(displayPoints.map(p => p.scenarioTitle))];
                    const uniqueModels = [...new Set(displayPoints.map(p => p.llmName))];
                    const uniqueCategories = [...new Set(displayPoints.map(p => p.category))];

                    console.log("\n--- Filter Updates ---");
                    console.log("Unique scenarios:", uniqueScenarios);
                    console.log("Unique models:", uniqueModels);
                    console.log("Unique categories:", uniqueCategories);

                    document.getElementById('modelFilter').innerHTML = uniqueModels.map(model =>
                        `<option value="${model}">${model}</option>`
                    ).join('');

                    document.getElementById('scenarioFilter').innerHTML = uniqueScenarios.map(scenario =>
                        `<option value="${scenario}">${scenario}</option>`
                    ).join('');

                    document.getElementById('categoryFilter').innerHTML = uniqueCategories.map(category =>
                        `<option value="${category}">${category}</option>`
                    ).join('');

                    document.getElementById('alternateOutcomes').innerHTML =
                        '<option disabled>Select a scenario and model to see alternates</option>';

                    activeCategories = new Set([...new Set(displayPoints.map(point => 
                        normalizeCategory(point.overallCategory)))]);

                    console.log("Active categories:", Array.from(activeCategories));

                    document.querySelectorAll('.filter-badge').forEach(badge => {
                        const category = badge.dataset.category.toLowerCase();
                        const exists = displayPoints.some(point => 
                            normalizeCategory(point.overallCategory) === category);
                        badge.style.display = exists ? 'inline-block' : 'none';
                        badge.classList.toggle('active', activeCategories.has(category));
                    });

                    // Initial visualization: show parent scenarios only
                    console.log("\n--- Creating Initial Plot ---");
                    console.log("Display points for plot:", displayPoints);
                    createPlot(displayPoints);
                }
            }


        // Visualization functions
        function createPlot(points) {
            const meshData = {
                type: 'mesh3d',
                x: [-8, 12, 12, -8, -8, 12, 12, -8],
                y: [0, 0, 0, 0, 8, 8, 8, 8],
                z: [-21.6, -21.6, 0, 0, -21.6, -21.6, 0, 0],
                i: [0, 0, 4, 4, 0, 0, 2, 2, 0, 1],
                j: [1, 2, 5, 6, 1, 5, 3, 7, 0, 2],
                k: [2, 3, 6, 7, 5, 4, 7, 6, 3, 3],
                opacity: 0.1,
                color: 'lightblue',
                showlegend: false,
                hoverinfo: 'none'
            };

            let data = [meshData];

            // Draw relationship lines (if applicable)
            const parentPoint = points.find(p => p.isParent);
            if (parentPoint && scenarioRelationships.has(parentPoint.scenarioTitle)) {
                const childPoints = points.filter(p => !p.isParent);
                childPoints.forEach(childPoint => {
                data.push({
                    type: 'scatter3d',
                    x: [parentPoint.x, childPoint.x],
                    y: [parentPoint.z, childPoint.z],
                    z: [parentPoint.y, childPoint.y],
                    mode: 'lines',
                    line: { color: '#666', width: 2, dash: 'dash' },
                    hoverinfo: 'text',
                    hovertext: `${parentPoint.scenarioTitle} → ${childPoint.scenarioTitle}`,
                    showlegend: false
                });
                });
            }

            // Plot the data points (markers)
            data.push({
                type: 'scatter3d',
                x: points.map(p => p.x),
                y: points.map(p => p.z),
                z: points.map(p => p.y),
                mode: 'markers',
                marker: {
                size: points.map(p => p.isParent ? 8 : 6),
                color: points.map(p => getColorByCategory(p.overallCategory)),
                opacity: 0.8,
                line: {
                    // Use the composite key for marker borders and increase the width.
                    color: points.map(p => scenarioColorMapping[p.scenarioTitle + '_' + p.llmName] || '#000'),
                    width: points.map(p => p.isParent ? 6 : 4)
                }
                },
                text: points.map(p => `
                <b>${p.scenarioTitle}</b><br>
                <b>Category:</b> ${p.overallCategory}<br>
                <b>Model:</b> ${p.llmName}<br>
                ${p.isParent ? '<b>Type:</b> Parent' : '<b>Type:</b> Alternative'}
                `),
                hoverinfo: 'text',
                showlegend: false
            });

            const layout = {
                margin: { l: 0, r: 0, b: 0, t: 0 },
                scene: {
                xaxis: { title: 'Altruistic - Self Motivated', range: [-8, 12], titlefont: { size: 10 } },
                yaxis: { title: 'Habit/Instinct - Will Power', range: [0, 8], titlefont: { size: 10 } },
                zaxis: { title: 'Small Sacrifice - Large sacrifice', range: [-21.6, 0], titlefont: { size: 10 } },
                camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } },
                aspectmode: 'cube',
                aspectratio: { x: 1, y: 1, z: 1 }
                }
            };

            Plotly.newPlot('cube-plot', data, layout, {
                displayModeBar: false,
                responsive: true
            });
            }

        function updateAlternateOutcomesDropdown(parentScenario, selectedModel) {
            const alternateOutcomes = document.getElementById('alternateOutcomes');
            
            if (parentScenario && selectedModel) {
                const relationships = scenarioRelationships.get(parentScenario) || [];
                const alternatives = relationships.filter(rel => rel.model === selectedModel);
                
                if (alternatives && alternatives.length > 0) {
                    alternateOutcomes.innerHTML = alternatives.map(alt => `
                        <option value="${alt.childId}">
                            ${alt.childId} ${alt.relationshipType ? `(${alt.relationshipType})` : ''}
                        </option>
                    `).join('');
                    alternateOutcomes.disabled = false;
                    alternateOutcomes.multiple = true;
                    alternateOutcomes.size = Math.min(6, alternatives.length);
                } else {
                    alternateOutcomes.innerHTML = '<option disabled>No alternate outcomes available</option>';
                    alternateOutcomes.disabled = true;
                }
            } else {
                alternateOutcomes.innerHTML = '<option disabled>Select a scenario and model first</option>';
                alternateOutcomes.disabled = true;
            }
        }


        function updateFilters() {
            // Model filter
            const modelFilter = document.getElementById('modelFilter');
            const models = [...new Set(dataPoints.map(point => point.llmName))];
            modelFilter.innerHTML = models.map(model => `<option value="${model}">${model}</option>`).join('');

            // Scenario filter (parent scenarios only)
            const scenarioFilter = document.getElementById('scenarioFilter');
            const scenarios = [...new Set(dataPoints.filter(p => p.isParent).map(point => point.scenarioTitle))];
            scenarioFilter.innerHTML = scenarios.map(scenario => `<option value="${scenario}">${scenario}</option>`).join('');
            
            // Category filter
            const categories = [...new Set(dataPoints.filter(p => p.isParent).map(point => point.category))];
            const categoryFilter = document.getElementById('categoryFilter');
            categoryFilter.innerHTML = categories.map(category => `<option value="${category}">${category}</option>`).join('');
            
            // Update category badges visibility and active state
            document.querySelectorAll('.filter-badge').forEach(badge => {
                const category = badge.dataset.category;
                const normalizedCategory = normalizeCategory(category);
                const exists = dataPoints.some(point => normalizeCategory(point.overallCategory) === normalizedCategory);
                badge.style.display = exists ? 'inline-block' : 'none';
                badge.classList.toggle('active', activeCategories.has(normalizedCategory));
            });
        }

       // === updateVisualization() Function ===
       function updateVisualization() {
            let filteredPoints = dataPoints;
            
            // If more than one scenario is selected, default the model to "GPT".
            if (selectedScenarios.length > 1) {
                selectedModels = ["GPT"];
            }
            
            // --- Clear highlights ---
            document.querySelectorAll('.relevant-option').forEach(el => el.classList.remove('relevant-option'));
            document.querySelectorAll('.filter-badge').forEach(badge => {
                badge.classList.remove('relevant-badge');
                badge.style.display = 'inline-block';
            });

            // --- Apply moral category filter ---
            if (activeCategories.size !== 6) {
                filteredPoints = filteredPoints.filter(point =>
                activeCategories.has(normalizeCategory(point.overallCategory))
                );
                
                const availScenarios = new Set(filteredPoints.map(p => p.scenarioTitle));
                const scenarioFilter = document.getElementById('scenarioFilter');
                Array.from(scenarioFilter.options).forEach(option => {
                option.style.display = availScenarios.has(option.value) ? 'block' : 'none';
                if (availScenarios.has(option.value)) option.classList.add('relevant-option');
                });
                
                const availModels = new Set(filteredPoints.map(p => p.llmName));
                const modelFilter = document.getElementById('modelFilter');
                Array.from(modelFilter.options).forEach(option => {
                option.style.display = availModels.has(option.value) ? 'block' : 'none';
                if (availModels.has(option.value)) option.classList.add('relevant-option');
                });
            }

            // --- Apply Category Type Filter ---
            if (selectedCategories.length > 0) {
                filteredPoints = filteredPoints.filter(point => selectedCategories.includes(point.category));
            }

            // --- Apply Scenario Filter ---
            if (selectedScenarios.length > 0) {
                filteredPoints = filteredPoints.filter(point =>
                selectedScenarios.includes(point.scenarioTitle)
                );
                
                const relModels = new Set(filteredPoints.map(p => p.llmName));
                document.querySelectorAll('#modelFilter option').forEach(option => {
                if (relModels.has(option.value)) {
                    option.style.display = 'block';
                    option.classList.add('relevant-option');
                } else {
                    option.style.display = 'none';
                    option.selected = false;
                }
                });
            }

            // --- Apply Model Filter ---
            if (selectedModels.length > 0) {
                filteredPoints = filteredPoints.filter(point => selectedModels.includes(point.llmName));
                
                const relScenarios = new Set(filteredPoints.map(p => p.scenarioTitle));
                document.querySelectorAll('#scenarioFilter option').forEach(option => {
                if (relScenarios.has(option.value)) {
                    option.style.display = 'block';
                    option.classList.add('relevant-option');
                } else {
                    option.style.display = 'none';
                    option.selected = false;
                }
                });
            }

            // --- Update category badges ---
            const relCats = new Set(filteredPoints.map(point => normalizeCategory(point.overallCategory)));
            document.querySelectorAll('.filter-badge').forEach(badge => {
                const cat = badge.dataset.category;
                badge.style.opacity = (selectedScenarios.length > 0 || selectedModels.length > 0 || activeCategories.size !== 6) 
                ? (relCats.has(cat) ? '1' : '0.3')
                : '1';
                if (relCats.has(cat)) badge.classList.add('relevant-badge');
            });

            // --- Update alternate outcomes dropdown ---
            const altOutcomes = document.getElementById('alternateOutcomes');
            if (selectedScenarios.length === 1 && selectedModels.length === 1) {
                const parentScenario = selectedScenarios[0];
                const selModel = selectedModels[0];
                const relationships = scenarioRelationships.get(parentScenario) || [];
                const alternatives = relationships.filter(child => child.model === selModel);
                if (alternatives && alternatives.length > 0) {
                altOutcomes.innerHTML = alternatives
                    .map(alt => `
                    <option value="${alt.childId}">
                        ${alt.childId} ${alt.relationshipType ? `(${alt.relationshipType})` : ''}
                    </option>
                    `).join('');
                altOutcomes.disabled = false;
                altOutcomes.style.opacity = '1';
                altOutcomes.multiple = true;
                } else {
                altOutcomes.innerHTML = '<option>No alternate outcomes available</option>';
                altOutcomes.disabled = true;
                altOutcomes.style.opacity = '0.5';
                }
            } else {
                altOutcomes.innerHTML = '<option>Select a scenario and model first</option>';
                altOutcomes.disabled = true;
                altOutcomes.style.opacity = '0.5';
            }
            
            // --- If exactly one scenario and one model are selected, include alternate outcomes ---
            if (selectedScenarios.length === 1 && selectedModels.length === 1) {
                const parentScenarioTitle = selectedScenarios[0];
                const selModel = selectedModels[0];
                const parentPoint = dataPoints.find(p => p.scenarioTitle === parentScenarioTitle && p.isParent);
                const rels = scenarioRelationships.get(parentScenarioTitle) || [];
                const alts = rels.filter(child => child.model === selModel).map(child => child.data);
                if (parentPoint) {
                filteredPoints = [parentPoint, ...alts];
                }
            }

            // --- Update available categories in the category filter ---
            const filtCategories = new Set(filteredPoints.map(p => p.category));
            document.querySelectorAll('#categoryFilter option').forEach(option => {
                if (filtCategories.has(option.value)) {
                option.style.display = 'block';
                option.classList.add('relevant-option');
                } else {
                option.style.display = 'none';
                option.selected = false;
                }
            });

            if (filteredPoints.length === 0) {
                alert('No data points match the current filters.');
                return;
            }

            // --- Build the shared color mapping using composite keys (scenarioTitle + "_" + llmName) ---
            const uniqueCompositeKeys = [...new Set(filteredPoints.map(p => p.scenarioTitle + '_' + p.llmName))];
            scenarioColorMapping = {};
            uniqueCompositeKeys.forEach((key, index) => {
                scenarioColorMapping[key] = sharedBorderColors[index % sharedBorderColors.length];
            });
            console.log("Shared color mapping:", scenarioColorMapping);

            // --- Update overview cards and scenario details ---
            if (selectedScenarios.length > 0) {
                const compData = filteredPoints.filter(point => selectedScenarios.includes(point.scenarioTitle));
                populateOverview(compData);
                populateScenarioDetails(compData);
            } else if (selectedModels.length === 2) {
                const compData = selectedModels.map(model =>
                filteredPoints.find(point => point.llmName === model)
                ).filter(Boolean);
                populateOverview(compData);
                populateScenarioDetails(compData);
            } else {
                // If only one scenario is selected, show a maximum of 4 models.
                let compData = Array.isArray(filteredPoints) ? filteredPoints.slice(0, 4) : filteredPoints;
                populateOverview(compData);
                populateScenarioDetails(compData);
            }

            // --- Create the 3D plot ---
            const xValues = filteredPoints.map(point => point.x);
            const yValues = filteredPoints.map(point => point.z);
            const zValues = filteredPoints.map(point => point.y);
            const plotData = [
                {
                type: 'mesh3d',
                x: [-8, 12, 12, -8, -8, 12, 12, -8],
                y: [0, 0, 0, 0, 8, 8, 8, 8],
                z: [-21.6, -21.6, 0, 0, -21.6, -21.6, 0, 0],
                i: [0, 0, 4, 4, 0, 0, 2, 2, 0, 1],
                j: [1, 2, 5, 6, 1, 5, 3, 7, 0, 2],
                k: [2, 3, 6, 7, 5, 4, 7, 6, 3, 3],
                opacity: 0.1,
                color: 'lightblue',
                showlegend: false,
                hoverinfo: 'none'
                },
                {
                type: 'scatter3d',
                x: xValues,
                y: yValues,
                z: zValues,
                mode: 'markers',
                marker: {
                    size: filteredPoints.map(p => p.isParent ? 8 : 6),
                    color: filteredPoints.map(p => getColorByCategory(p.overallCategory)),
                    opacity: 0.8,
                    line: {
                    color: filteredPoints.map(p => scenarioColorMapping[p.scenarioTitle + '_' + p.llmName] || '#000'),
                    width: filteredPoints.map(p => p.isParent ? 8 : 6)
                    }
                },
                text: filteredPoints.map(point => `
                    <b>${point.scenarioTitle}</b><br>
                    <b>Category:</b> ${point.overallCategory}<br>
                    <b>Model:</b> ${point.llmName}<br>
                    ${point.isParent ? '<b>Type:</b> Parent' : '<b>Type:</b> Alternative'}
                `),
                hoverinfo: 'text',
                showlegend: false
                }
            ];
            const layout = {
                margin: { l: 0, r: 0, b: 0, t: 0 },
                scene: {
                xaxis: { title: 'Altruistic - Self Motivated', range: [-8, 12], titlefont: { size: 10 } },
                yaxis: { title: 'Habit/Instinct - Will Power', range: [0, 8], titlefont: { size: 10 } },
                zaxis: { title: 'Small Sacrifice - Large sacrifice', range: [-21.6, 0], titlefont: { size: 10 } },
                camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } },
                aspectmode: 'cube',
                aspectratio: { x: 1, y: 1, z: 1 }
                }
            };
            Plotly.newPlot('cube-plot', plotData, layout, {
                displayModeBar: false,
                responsive: true
            });

            // --- Update the media placeholder with the selected scenario's media URL ---
            updateSelectedMedia();
            }





    
        function checkDescriptions() {
            document.querySelectorAll('.scenario-description').forEach(function(desc) {
                const textEl = desc.querySelector('.description-text');
                const readMoreLink = desc.querySelector('.read-more');
                // Compare scrollHeight (full content height) with clientHeight (visible height)
                if (textEl.scrollHeight <= textEl.clientHeight) {
                    // Content fits, hide the read more link
                    readMoreLink.style.display = 'none';
                } else {
                    readMoreLink.style.display = 'block';
                }
            });
        }


        function populateOverview(data) {
            const overviewDiv = document.getElementById('overview');
            if (!Array.isArray(data)) {
                data = [data];
            }
            
            // Sort data to show parent scenarios first
            data.sort((a, b) => (b.isParent ? 1 : 0) - (a.isParent ? 1 : 0));
            data = data.slice(0, 4); // Limit to 4 items
            
            const cards = data.map(item => {
                const scores = getEthicsScores(item);
                return `
                    <div class="comparison-card" 
                        data-scenario-id="${item.id}" 
                        style="border: 2px solid ${scenarioColorMapping[item.scenarioTitle + '_' + item.llmName] || '#000'};">
                        <h4>
                            ${getScenarioTitle(item)}
                            <small>(${item.llmName} ${getCategoryBadge(item.overallCategory)})</small>
                        </h4>
                        <div class="scenario-description">
                            <span class="description-text">
                                ${item.scenarioDescription || 'No description available'}
                            </span>
                            <span class="read-more">Read more</span>
                        </div>
                        <div class="ethics-scores">
                            <div>Deontology: ${scores.deontologyScore}</div>
                            <div>Utilitarianism: ${scores.utilitarianismScore}</div>
                            <div>Virtue Ethics: ${scores.virtueEthicsScore}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            overviewDiv.innerHTML = cards;
            attachComparisonCardHandlers();
            checkDescriptions();
        }

            // After setting overviewDiv.innerHTML = cards;
            document.querySelectorAll('.comparison-card').forEach(card => {
            card.addEventListener('click', function() {
                const id = card.getAttribute('data-scenario-id');

                // Toggle selection: if already selected, unselect it.
                if (card.classList.contains('selected-card')) {
                card.classList.remove('selected-card');
                selectedComparison = selectedComparison.filter(selectedId => selectedId !== id);
                } else {
                // Only allow selection if fewer than 2 are already selected.
                if (selectedComparison.length < 2) {
                    card.classList.add('selected-card');
                    selectedComparison.push(id);
                } else {
                    alert("You can only compare 2 scenarios/models at a time.");
                }
                }
                
                // If exactly 2 items are selected, update scenario details.
                if (selectedComparison.length === 2) {
                // Filter dataPoints to only include those with IDs in selectedComparison.
                const compData = dataPoints.filter(point => selectedComparison.includes(point.id));
                populateScenarioDetails(compData);
                } else {
                // Optionally, clear or update the scenario details if fewer than 2 are selected.
                // For example, you could clear the details:
                // document.getElementById('scenarioAccordion').innerHTML = '';
                }
            });
            });





        // Update the updateMediaDisplay function to handle URLs more robustly
        function updateMediaDisplay(url) {
            const container = document.getElementById('media-placeholder');
            const openMediaButton = document.getElementById('open-media');
            
            // Update the current URL
            currentMediaUrl = url || "";
            
            // Enable/disable the "Open in New Window" button based on URL availability
            openMediaButton.disabled = !currentMediaUrl;
            
            if (!url) {
                container.innerHTML = "<p class='text-center text-muted mt-3'>No media available for this selection</p>";
                return;
            }

            try {
                // Handle different types of URLs
                if (url.includes("reddit.com")) {
                    container.innerHTML = `
                        <blockquote class="reddit-embed" data-embed-media="true" data-height="500">
                            <a href="${url}">View this post on Reddit</a>
                        </blockquote>
                    `;
                    // Reload Reddit embed script
                    let existingScript = document.getElementById('reddit-embed-script');
                    if (existingScript) {
                        existingScript.remove();
                    }
                    let script = document.createElement('script');
                    script.id = 'reddit-embed-script';
                    script.async = true;
                    script.src = 'https://embed.reddit.com/widgets.js';
                    script.charset = 'UTF-8';
                    document.body.appendChild(script);
                } else if (url.includes("youtube.com") || url.includes("youtu.be")) {
                    // Clear the container first
                    container.innerHTML = '';
                    
                    // Extract video ID from various YouTube URL formats
                    let videoId;
                    if (url.includes('youtube.com')) {
                        const urlParams = new URL(url).searchParams;
                        videoId = urlParams.get('v');
                    } else if (url.includes('youtu.be')) {
                        videoId = url.split('/').pop().split('?')[0];
                    }

                    if (videoId) {
                        // Create a new iframe element
                        const iframe = document.createElement('iframe');
                        iframe.width = '100%';
                        iframe.height = '100%';
                        iframe.src = `https://www.youtube.com/embed/${videoId}`;
                        iframe.frameBorder = '0';
                        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
                        iframe.allowFullscreen = true;
                        
                        // Append the new iframe
                        container.appendChild(iframe);
                    } else {
                        console.error('Could not extract YouTube video ID from URL:', url);
                        container.innerHTML = `
                            <p class='text-center text-muted mt-3'>
                                Unable to display video. <a href="${url}" target="_blank">Open externally</a>
                            </p>`;
                    }
                } else {
                    // For other URLs, try to embed them directly
                    // Create a new iframe to force a refresh
                    const iframe = document.createElement('iframe');
                    iframe.style.width = '100%';
                    iframe.style.height = '100%';
                    iframe.style.border = 'none';
                    iframe.src = url;
                    iframe.allowFullscreen = true;
                    
                    // Clear the container and append the new iframe
                    container.innerHTML = '';
                    container.appendChild(iframe);
                }
            } catch (error) {
                console.error('Error updating media display:', error);
                container.innerHTML = `
                    <p class='text-center text-muted mt-3'>
                        Unable to display media. <a href="${url}" target="_blank">Open externally</a>
                    </p>`;
            }
        }

        // Helper function to convert YouTube URL to embed URL
        function convertYouTubeUrl(url) {
            try {
                let videoId;
                if (url.includes('youtube.com')) {
                    const urlParams = new URL(url).searchParams;
                    videoId = urlParams.get('v');
                } else if (url.includes('youtu.be')) {
                    videoId = url.split('/').pop().split('?')[0];
                }
                
                if (videoId) {
                    return `https://www.youtube.com/embed/${videoId}`;
                }
                return url;
            } catch (error) {
                console.error('Error converting YouTube URL:', error);
                return url;
            }
        }

        // Update the updateSelectedMedia function to include logging
        function updateSelectedMedia() {
            console.log('updateSelectedMedia called');
            console.log('Current selected scenarios:', selectedScenarios);
            
            if (selectedScenarios.length === 0) {
                console.log('No scenarios selected, clearing media');
                updateMediaDisplay("");
                return;
            }

            if (selectedScenarios.length === 1) {
                // Find all points that match the selected scenario title
                const scenarioPoints = dataPoints.filter(p => p.scenarioTitle === selectedScenarios[0]);
                console.log('Found scenario points:', scenarioPoints);
                
                // First try to find the parent scenario
                let parentScenario = scenarioPoints.find(p => p.isParent);
                
                // If no parent found but we have points, use the first point
                if (!parentScenario && scenarioPoints.length > 0) {
                    parentScenario = scenarioPoints[0];
                }
                
                if (parentScenario && parentScenario.url) {
                    console.log('Updating media with URL:', parentScenario.url);
                    updateMediaDisplay(parentScenario.url);
                } else {
                    console.log('No URL found for scenario:', selectedScenarios[0]);
                    updateMediaDisplay("");
                }
            } else {
                console.log('Multiple scenarios selected, clearing media');
                updateMediaDisplay("");
            }
        }


        function getScenarioTitle(data) {
            // Only include the link if a nonempty URL exists
            if (data.url && data.url.trim() !== "") {
                return `${data.scenarioTitle} <a href="${data.url}" target="_blank" class="scenario-link">
                            <i class="fas fa-external-link-alt"></i></a>`;
            }
            return data.scenarioTitle;
        }


        function getCategoryBadge(category) {
            let normalizedCategory = category.toLowerCase().replace(/\s+/g, '-');
            if (normalizedCategory === 'morally_grey' || normalizedCategory === 'morally-grey') {
                normalizedCategory = 'morally-grey';
            }
            const categoryClass = `category-badge category-${normalizedCategory}`;
            return `<span class="${categoryClass}">${category}</span>`;
        }
        function getColorByCategory(category) {
            const colorMap = {
                'evil': '#dc3545',
                'virtue': '#28a745',
                'vice': '#ffc107',
                'sin': '#6c757d',
                'morally_grey': '#6610f2',
                'world_building': '#17a2b8'
            };
            return colorMap[category] || 'gray';
            }
        // Helper function: normalize a category string.
        function normalizeCategory(category) {
            return category.toLowerCase().replace(/\s+/g, '_');
            }
            function populateScenarioDetails(scenarioData) {
                // Normalize input to array and limit to 2 scenarios for comparison
                if (!Array.isArray(scenarioData)) {
                    scenarioData = [scenarioData];
                }
                if (scenarioData.length > 2) {
                    scenarioData = scenarioData.slice(0, 2);
                }

                const scenarioAccordion = document.getElementById('scenarioAccordion');
                
                // Early return if no valid data
                if (!scenarioData.length || !scenarioData[0].dimensions) {
                    scenarioAccordion.innerHTML = '<div class="alert alert-info">No scenario data available.</div>';
                    return;
                }

                // Get dimension score helper
                function getDimensionScore(scenario, dimensionId) {
                    if (!['Ends', 'Means', 'Character'].includes(dimensionId)) return null;
                    
                    const scores = {
                        'Ends': scenario.x,
                        'Means': scenario.y,
                        'Character': scenario.z
                    };
                    return scores[dimensionId]?.toFixed(2) ?? null;
                }

                // Get range value helper
                function getRange(dimensionId, questionIndex) {
                    const rangeMap = {
                        'Ends': {
                            default: questionIndex < 3 ? "0 to 4" : "0 to -4"
                        },
                        'Means': {
                            0: "0 to -4",
                            1: "0 to -6",
                            2: "0 to -4",
                            3: "0 to -4",
                            4: "0.01 to 1.2"
                        },
                        'Character': {
                            0: "0 to 1",
                            1: "0 to 2",
                            2: "0 to 4",
                            3: "0 to 1"
                        }
                    };

                    return rangeMap[dimensionId]?.[questionIndex] || 
                        rangeMap[dimensionId]?.default || 
                        "N/A";
                }

                // Build table structure helper
                function getTableStructure(isPhilosophical) {
                    if (isPhilosophical) {
                        return {
                            colgroup: `
                                <col style="width:25%;">
                                <col style="width:25%;">
                                <col style="width:50%;">
                            `,
                            header: `
                                <tr>
                                    <th>Question</th>
                                    <th>Score</th>
                                    <th>Justification</th>
                                </tr>
                            `
                        };
                    }

                    return {
                        colgroup: `
                            <col style="width:10%;">
                            <col style="width:10%;">
                            <col style="width:12.5%;">
                            <col style="width:70%;">
                        `,
                        header: `
                            <tr>
                                <th>Question</th>
                                <th>Score</th>
                                <th>Range</th>
                                <th>Justification</th>
                            </tr>
                        `
                    };
                }

                // Create question row helper
                function createQuestionRow(question, tooltip, range, isPhilosophical) {
                    const tooltipHTML = tooltip ? `
                        <div style="display: inline-flex; align-items: center; gap: 4px;">
                            <span class="tooltip-container">
                                <i class="fas fa-info-circle tooltip-icon" aria-hidden="true"></i>
                                <span class="tooltip-content" role="tooltip">${tooltip.info}</span>
                            </span>
                            <span class="tooltip-container">
                                <i class="fas fa-question-circle tooltip-icon" aria-hidden="true"></i>
                                <span class="tooltip-content" role="tooltip">${tooltip.question}</span>
                            </span>
                        </div>
                    ` : '';

                    const score = typeof question.score === 'number' ? 
                        question.score.toFixed(1) : question.score;

                    if (isPhilosophical) {
                        return `
                            <tr>
                                <td>${question.question}${tooltipHTML}</td>
                                <td>${score}</td>
                                <td>${question.justification}</td>
                            </tr>
                        `;
                    }

                    return `
                        <tr>
                            <td>${question.question}${tooltipHTML}</td>
                            <td>${score}</td>
                            <td>${range}</td>
                            <td>${question.justification}</td>
                        </tr>
                    `;
                }

                // Create scenario table helper
                function createScenarioTable(scenario, dimension, isPhilosophical, dimensionId, tableStructure) {
                    const dimensionScore = getDimensionScore(scenario, dimension.id);
                    const scoreDisplay = dimensionScore !== null && 
                        ['Ends', 'Means', 'Character'].includes(dimension.id) ?
                        ` (${dimension.id} Score: ${dimensionScore})` : '';

                    const questionRows = dimension.questions.map((question, index) => {
                        const range = !isPhilosophical ? getRange(dimension.id, index) : "N/A";
                        const tooltip = questionTooltips[question.question] || null;
                        return createQuestionRow(question, tooltip, range, isPhilosophical);
                    }).join('');

                    return `
                        <div class="col-md-${scenarioData.length === 1 ? '12' : '6'} scenario-table-container">
                            <h5 class="mb-3">${scenario.scenarioTitle} (${scenario.llmName})${scoreDisplay}</h5>
                            <table class="table table-bordered compact-table">
                                <colgroup>${tableStructure.colgroup}</colgroup>
                                <thead>${tableStructure.header}</thead>
                                <tbody>${questionRows}</tbody>
                            </table>
                        </div>
                    `;
                }

                // Main content generation
                const dimensionContent = scenarioData[0].dimensions.map((dimension, index) => {
                    const dimensionId = `dimension${index}`;
                    const collapseId = `collapse${index}`;
                    const isPhilosophical = dimension.id.trim().toLowerCase() === 'philosophical analysis';
                    const tableStructure = getTableStructure(isPhilosophical);

                    const scenarioTables = scenarioData.map(scenario => 
                        createScenarioTable(
                            scenario, 
                            scenario.dimensions[index], 
                            isPhilosophical, 
                            dimensionId, 
                            tableStructure
                        )
                    ).join('');

                    return `
                        <div class="card">
                            <div class="card-header" id="${dimensionId}-header">
                                <h2 class="mb-0">
                                    <button class="btn btn-link ${index === 0 ? '' : 'collapsed'}" 
                                            type="button" 
                                            data-toggle="collapse" 
                                            data-target="#${collapseId}">
                                        <strong>${dimension.id} (${dimension.label})</strong>
                                    </button>
                                </h2>
                            </div>
                            <div id="${collapseId}" 
                                class="collapse ${index === 0 ? 'show' : ''}" 
                                data-parent="#scenarioAccordion">
                                <div class="card-body">
                                    <div class="row">
                                        ${scenarioTables}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                scenarioAccordion.innerHTML = dimensionContent;
            }








        // Event Listeners
        // Model Filter Listener
        document.getElementById('modelFilter').addEventListener('change', function(e) {
            if (isUpdatingFilters || isCategoryFiltering) return;
            
            selectedModels = Array.from(e.target.selectedOptions).map(option => option.value);
            
            // Enforce maximum selection limit
            if (selectedModels.length > 4) {
                alert('Please select a maximum of 4 models for comparison');
                selectedModels = selectedModels.slice(0, 4);
                Array.from(this.options).forEach(option => {
                    option.selected = selectedModels.includes(option.value);
                });
            }
            
            // Update alternate outcomes if exactly one scenario and one model are selected
            const alternateOutcomes = document.getElementById('alternateOutcomes');
            
            if (selectedScenarios.length === 1 && selectedModels.length === 1) {
                const parentScenario = selectedScenarios[0];
                const selectedModel = selectedModels[0];
                
                const relationships = scenarioRelationships.get(parentScenario) || [];
                const alternatives = relationships.filter(child => child.model === selectedModel);
                
                if (alternatives && alternatives.length > 0) {
                    // Configure dropdown for multiple selection
                    alternateOutcomes.setAttribute('multiple', 'true');
                    alternateOutcomes.size = Math.min(alternatives.length, 6);
                    alternateOutcomes.disabled = false;
                    
                    // Clear existing options
                    alternateOutcomes.innerHTML = '';
                    
                    // Add new options
                    alternatives.forEach(alt => {
                        const option = document.createElement('option');
                        option.value = alt.childId;
                        option.text = `${alt.childId} ${alt.relationshipType ? `(${alt.relationshipType})` : ''}`;
                        alternateOutcomes.appendChild(option);
                    });
                } else {
                    alternateOutcomes.removeAttribute('multiple');
                    alternateOutcomes.innerHTML = '<option disabled>No alternate outcomes available</option>';
                    alternateOutcomes.disabled = true;
                }
            } else {
                alternateOutcomes.removeAttribute('multiple');
                alternateOutcomes.innerHTML = '<option disabled>Select one scenario and one model to see alternates</option>';
                alternateOutcomes.disabled = true;
            }
            
            updateVisualization();
        });


        // Scenario Filter Listener
        document.getElementById('scenarioFilter').addEventListener('change', function(e) {
            if (isUpdatingFilters || isCategoryFiltering) return;
            
            // Clear previous selections
            selectedModels = [];
            document.getElementById('modelFilter').selectedIndex = -1;
            document.getElementById('alternateOutcomes').innerHTML = '<option disabled>Select a model first</option>';
            
            // Update selected scenarios
            selectedScenarios = Array.from(e.target.selectedOptions).map(option => option.value);
            
            // Enforce maximum selection limit
            if (selectedScenarios.length > 4) {
                alert('Please select a maximum of 4 scenarios for comparison');
                selectedScenarios = selectedScenarios.slice(0, 4);
                Array.from(this.options).forEach(option => {
                    option.selected = selectedScenarios.includes(option.value);
                });
            }
            
            // Update model filter based on selected scenarios
            const modelFilter = document.getElementById('modelFilter');
            const availableModels = new Set();
            
            selectedScenarios.forEach(scenario => {
                const scenarioData = dataPoints.filter(point => 
                    point.scenarioTitle === scenario
                );
                scenarioData.forEach(data => {
                    availableModels.add(data.llmName);
                });
            });
            
            // Populate model filter
            if (availableModels.size > 0) {
                modelFilter.innerHTML = Array.from(availableModels)
                    .map(model => `<option value="${model}">${model}</option>`)
                    .join('');
                modelFilter.disabled = false;
            } else {
                modelFilter.innerHTML = '<option disabled>No models available</option>';
                modelFilter.disabled = true;
            }
            
            updateVisualization();
        });





        // Update the alternate outcomes listener
        document.getElementById('alternateOutcomes').addEventListener('change', function(e) {
            if (isUpdatingFilters) return;
            
            const selectedAlternates = Array.from(this.selectedOptions).map(opt => opt.value);
            
            if (selectedAlternates.length > 0 && selectedScenarios.length === 1) {
                const parentScenario = selectedScenarios[0];
                const relationships = scenarioRelationships.get(parentScenario) || [];
                
                selectedAlternates.forEach(alternateId => {
                    const relationship = relationships.find(rel => rel.childId === alternateId);
                    if (relationship) {
                        const model = relationship.model;
                        if (!selectedModels.includes(model)) {
                            selectedModels.push(model);
                        }
                    }
                });
                
                // Update model filter selection
                const modelFilter = document.getElementById('modelFilter');
                Array.from(modelFilter.options).forEach(option => {
                    option.selected = selectedModels.includes(option.value);
                });
            }
            
            updateVisualization();
        });


        // Category Filter Listener
        document.getElementById('categoryFilter').addEventListener('change', function(e) {
            if (isUpdatingFilters || isCategoryFiltering) return;
            
            // Update selected categories
            selectedCategories = Array.from(e.target.selectedOptions).map(option => option.value);
            
            // Clear other filters
            selectedScenarios = [];
            selectedModels = [];
            document.getElementById('scenarioFilter').selectedIndex = -1;
            document.getElementById('modelFilter').selectedIndex = -1;
            document.getElementById('alternateOutcomes').innerHTML = '<option disabled>Select a scenario and model first</option>';
            
            // Filter scenarios based on selected categories
            const scenarioFilter = document.getElementById('scenarioFilter');
            const availableScenarios = dataPoints.filter(point => 
                point.isParent && selectedCategories.includes(point.category)
            );
            
            // Create a Set of unique scenario titles to prevent duplicates
            const uniqueScenarios = [...new Set(availableScenarios.map(point => point.scenarioTitle))];
            
            // Update scenario filter options with unique scenarios
            scenarioFilter.innerHTML = uniqueScenarios
                .map(title => `<option value="${title}">${title}</option>`)
                .join('');
            
            // Clear model filter
            document.getElementById('modelFilter').innerHTML = '<option disabled>Select a scenario first</option>';
            
            updateVisualization();
        });



        document.addEventListener('DOMContentLoaded', fetchScenarios);
        document.addEventListener('DOMContentLoaded', () => {
        renderSurveyQuestions();
        });


        // Remove duplicate scenarioFilter listener (we now have one combined listener above)


        // Filter Badge Listener (unchanged):
        document.querySelectorAll('.filter-badge').forEach(badge => {
            badge.addEventListener('click', function() {
                if (isUpdatingFilters) return;
                
                const category = this.dataset.category;
                
                // Reset all badges to inactive
                document.querySelectorAll('.filter-badge').forEach(b => {
                    b.classList.remove('active');
                    b.style.opacity = '0.3';
                });
                
                // If clicking an already active sole category, reset all
                if (activeCategories.size === 1 && activeCategories.has(category)) {
                    activeCategories = new Set(['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building']);
                    document.querySelectorAll('.filter-badge').forEach(b => {
                        b.classList.add('active');
                        b.style.opacity = '1';
                    });
                } else {
                    // Set only this category as active
                    activeCategories = new Set([category]);
                    this.classList.add('active');
                    this.style.opacity = '1';
                }
                
                // Reset other filters
                selectedModels = [];
                selectedScenarios = [];
                selectedCategories = [];
                document.getElementById('modelFilter').selectedIndex = -1;
                document.getElementById('scenarioFilter').selectedIndex = -1;
                document.getElementById('categoryFilter').selectedIndex = -1;
                document.getElementById('alternateOutcomes').innerHTML = '<option>Select a scenario and model first</option>';
                
                updateVisualization();
            });
        });


        // UPDATED Clear Filters Listener:
        document.getElementById('clearFilters').addEventListener('click', function() {
            // Reset all filter selection arrays
            selectedModels = [];
            selectedScenarios = [];
            selectedCategories = [];
            
            // Reset active categories to include all options
            activeCategories = new Set(['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building']);
            
            // Set a flag to prevent mid-update side effects
            isUpdatingFilters = true;
            
            // Clear selected indexes for each filter dropdown
            document.getElementById('modelFilter').selectedIndex = -1;
            document.getElementById('scenarioFilter').selectedIndex = -1;
            document.getElementById('categoryFilter').selectedIndex = -1;
            
            // Reset the alternate outcomes dropdown to its default message
            document.getElementById('alternateOutcomes').innerHTML = '<option disabled>Select a scenario and model first</option>';
            
            // Reset filter badges to active state (full opacity)
            document.querySelectorAll('.filter-badge').forEach(badge => {
                badge.classList.add('active');
                badge.style.opacity = '1';
            });
            
            // Reset flags
            isUpdatingFilters = false;
            isCategoryFiltering = false;
            
            // Reset the dropdown options (this repopulates scenario, model, and category options)
            updateFilters();
            
            // Show all parent scenarios in the plot by updating the visualization
            const parentScenarios = dataPoints.filter(point => point.isParent);
            createPlot(parentScenarios);
            updateVisualization();
        });

        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('read-more')) {
                // Find the parent card (.comparison-card)
                const card = e.target.closest('.comparison-card');
                card.classList.toggle('expanded');
                // Update the link text accordingly
                if (card.classList.contains('expanded')) {
                    e.target.textContent = 'Show less';
                } else {
                    e.target.textContent = 'Read more';
                }
            }
        });
        // Call the render function when the page loads
        document.addEventListener('DOMContentLoaded', () => {
        renderSurveyQuestions();
        });






    </script>
</body>
</html>