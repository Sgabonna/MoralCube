<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Moral Cube</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" />
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600&family=Inter:wght@400;500&display=swap" rel="stylesheet">
    <style>
        /* --- Existing Styles --- */
        body {
        padding: 20px;
        background-color: #f8f9fa;
        font-family: 'Inter', sans-serif;
        }

        /* Main Container */
        .main-container {
        max-width: 1600px;
        margin: 0 auto;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        padding: 20px;
        }

        /* Plot Container & Cube Plot */
        .plot-container {
        background-color: white;
        border-radius: 6px;
        padding: 5px;
        height: 400px;
        display: flex;
        align-items: center;
        justify-content: center;
        }
        #cube-plot {
        width: 100%;
        height: 100%;
        }

        /* Page Header */
        .page-header {
        background-color: #D7E8FF;
        padding: 20px;
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        /* Navigation */
        .navbar {
        padding: 0;
        margin-top: auto;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
        box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.05);
        width: 100%;
        }
        .navbar-nav {
        display: flex;
        flex-direction: row;
        justify-content: center;
        width: 100%;
        padding: 0.5rem 0;
        }
        .navbar-nav .nav-link {
        padding: 0.7rem 1.2rem;
        transition: all 0.2s ease;
        border-radius: 4px;
        font-family: 'Inter', sans-serif;
        font-weight: 500;
        font-size: 1.2rem;
        white-space: nowrap;
        }
        .navbar-nav .nav-link:hover {
        background-color: rgba(255, 255, 255, 0.4);
        color: #2c5282;
        }
        .navbar-nav .nav-item {
        position: relative;
        margin: 0 1rem;
        }
        .navbar-nav .nav-item:not(:last-child)::after {
        content: "";
        position: absolute;
        right: -3px;
        top: 50%;
        transform: translateY(-50%);
        height: 4px;
        width: 4px;
        border-radius: 50%;
        background-color: #718096;
        opacity: 0.5;
        }

        /* Media Queries for Navigation */
        @media (max-width: 991.98px) {
        .navbar-nav .nav-item:not(:last-child)::after {
            display: none;
        }
        .navbar-nav .nav-item {
            text-align: center;
        }
        .navbar-collapse {
            display: flex !important;
            justify-content: center !important;
            width: 100% !important;
        }
        .navbar-nav {
            flex-direction: row;
            justify-content: center;
            width: max-content !important;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding: 0.5rem 1rem !important;
        }
        .navbar-nav::-webkit-scrollbar {
            display: none;
        }
        .navbar-toggler {
            display: none !important;
        }
        .nav-item.mx-3 {
            margin: 0 0.5rem !important;
        }
        .nav-link {
            padding: 0.8rem !important;
        }
        }
        @media (max-width: 768px) {
        .nav-link {
            font-size: 1rem;
            padding: 0.5rem 0.8rem;
        }
        }
        @media (max-width: 576px) {
        .page-header h1 {
            font-size: 2.5rem !important;
            margin-right: 0 !important;
        }
        .nav-item.mx-3 {
            margin: 0 0.3rem !important;
        }
        .nav-link {
            padding: 0.6rem !important;
        }
        }

        /* Filter Section */
        .filter-section {
        background-color: #f8f9fa;
        padding: 20px;
        border-radius: 6px;
        margin-bottom: 20px;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        }
        .filter-group {
        margin-bottom: 15px;
        }
        .filter-group select {
        width: 100%;
        min-height: 150px;
        }
        .filter-group select option {
        padding: 8px 12px;
        font-size: 14px;
        }
        .filter-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        font-size: 14px;
        }

        /* Filter action buttons row */
        .filter-actions {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        /* Category Badges */
        .category-badge {
        display: inline-block;
        padding: 0.25em 0.6em;
        font-size: 0.9rem;
        font-weight: 500;
        border-radius: 4px;
        margin-left: 0.5rem;
        }
        .category-evil {
        background-color: #dc3545;
        color: white;
        }
        .category-virtue {
        background-color: #28a745;
        color: white;
        }
        .category-vice {
        background-color: #ffc107;
        color: black;
        }
        .category-sin {
        background-color: #6c757d;
        color: white;
        }
        .category-morally-grey,
        .category-morally_grey {
        background-color: #6610f2;
        color: white;
        }
        .category-world-building,
        .category-world_building {
        background-color: #17a2b8;
        color: white;
        }

        /* Tooltip Styles */
        .tooltip {
        position: relative;
        display: inline-block;
        }
        .tooltip .tooltiptext {
        visibility: hidden;
        opacity: 0;
        background-color: #333;
        color: #fff;
        text-align: center;
        padding: 5px 10px;
        border-radius: 4px;
        position: absolute;
        z-index: 1000;
        bottom: 125%;
        left: 50%;
        transform: translateX(-50%);
        transition: opacity 0.3s;
        white-space: nowrap;
        font-size: 0.75rem;
        }
        .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
        }
        .tooltip .tooltiptext::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border-width: 5px;
        border-style: solid;
        border-color: #333 transparent transparent transparent;
        }

        /* Additional Tooltip Container */
        .tooltip-container {
        position: relative;
        display: inline-flex;
        align-items: center;
        margin-left: 8px;
        vertical-align: middle;
        }
        .tooltip-container .tooltip-content {
        visibility: hidden;
        opacity: 0;
        position: absolute;
        bottom: 150%;
        left: 5px;
        padding: 8px 12px;
        background-color: #2d3748;
        color: white;
        border-radius: 6px;
        font-size: 13px;
        line-height: 1.4;
        white-space: normal;
        max-width: 300px;
        width: max-content;
        z-index: 1000;
        transition: all 0.2s ease;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        text-align: left;
        }
        .tooltip-container:hover .tooltip-content {
        visibility: visible;
        opacity: 1;
        bottom: 140%;
        }

        /* Media Placeholder */
        #media-placeholder iframe {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: contain;
        }

        /* Overview & Comparison Cards */
        #overview {
        height: 500px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        padding: 15px;
        border-radius: 6px;
        margin-bottom: 20px;
        }
        .comparison-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 10px;
        }
        .comparison-card {
        cursor: pointer;
        height: 125px;
        box-sizing: border-box;
        padding: 5px 8px;
        margin-bottom: 5px;
        overflow: hidden;
        font-size: 0.75rem;
        transition: height 0.3s ease;
        }
        .comparison-card.expanded {
        height: auto;
        overflow: visible;
        }
        .comparison-card:nth-child(odd) {
        background-color: #e9ecef;
        }
        .comparison-card:nth-child(even) {
        background-color: #f8f9fa;
        }
        .comparison-card h4 {
        font-size: 0.8rem;
        margin: 0;
        }
        .scenario-description .description-text {
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        transition: all 0.3s ease;
        }
        .comparison-card.expanded .scenario-description .description-text {
        -webkit-line-clamp: unset;
        }
        .read-more {
        display: block;
        color: #007bff;
        cursor: pointer;
        font-size: 0.7rem;
        margin-top: 3px;
        }

        /* Tables */
        .table {
        margin-bottom: 0;
        font-size: 1rem;
        }
        .table th {
        background-color: #f8f9fa;
        font-weight: 600;
        border-bottom: 2px solid #dee2e6;
        padding: 12px;
        }
        .table td {
        vertical-align: middle;
        padding: 12px;
        }
        .compact-table {
        font-size: 0.75rem;
        margin-bottom: 10px;
        }
        .compact-table th,
        .compact-table td {
        padding: 4px 6px;
        vertical-align: middle;
        }

        /* Scenario Section */
        .scenario-section {
        margin-top: 20px;
        padding: 20px;
        background-color: #f8f9fa;
        border-radius: 6px;
        }

        /* Modal Styles */
        .modal-body h4 {
        color: #2c5282;
        font-weight: 600;
        }
        .modal-body h5 {
        color: #4a5568;
        font-weight: 600;
        }
        .modal-body p {
        line-height: 1.6;
        color: #2d3748;
        }
        .modal-body .ml-4 {
        border-left: 3px solid #e2e8f0;
        padding-left: 1rem;
        }
        .modal-body strong {
        color: #2d3748;
        }

        /* Banner & Auth Buttons */
        .banner {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 2rem;
        background-color: white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .auth-buttons {
        display: flex;
        align-items: center;
        gap: 1rem;
        }
        .auth-btn {
        padding: 0.5rem 1rem;
        border-radius: 4px;
        border: none;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s;
        }
        #login {
        background-color: #007bff;
        color: white;
        }
        #logout {
        background-color: #f8f9fa;
        color: #333;
        }
        .avatar {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        object-fit: cover;
        }
        /* Add this to your existing styles */
        #login:hover {
            background-color: #EBF4FF;
            border-color: #B2D5FF;
            color: #1A365D;
        }

        #logout:hover {
            background-color: #EDF2F7;
            border-color: #CBD5E0;
            color: #2D3748;
        }
        .navbar-nav .nav-link {
            font-family: 'Inter', sans-serif !important;
            font-weight: 500 !important;
            font-size: 1.2rem !important;
            padding: 0.7rem 1.2rem;
            transition: all 0.2s ease;
            border-radius: 4px;
            white-space: nowrap;
        }

        /* User Surveys Section */
        .user-surveys-section {
            background-color: #f0f4f8;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            overflow-y: auto;
            max-height: 150px; /* Keep preview height limited */
        }

        .user-surveys-section h5 {
            font-size: 0.9rem;
            margin-bottom: 10px;
            color: #2c5282;
        }

        .user-surveys-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .user-surveys-list li {
            padding: 6px 10px;
            font-size: 0.8rem;
            border-radius: 4px;
            margin-bottom: 5px;
            background-color: white;
            border-left: 3px solid #4299e1;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex; /* Use flexbox for layout */
            justify-content: space-between; /* Space out content */
            align-items: center;
        }

        .user-surveys-list li:hover {
            background-color: #ebf4ff;
        }

        .survey-status-draft {
            font-style: italic;
            color: #718096;
            font-size: 0.75rem;
            margin-left: 10px; /* Add some space */
            border: 1px solid #adb5bd;
            padding: 1px 4px;
            border-radius: 3px;
        }

        .no-surveys-message {
            font-size: 0.8rem;
            color: #718096;
            font-style: italic;
            text-align: center;
            padding: 10px;
        }

        .login-prompt {
            font-size: 0.8rem;
            color: #4a5568;
            text-align: center;
            padding: 10px;
        }

        .login-link {
            color: #4299e1;
            cursor: pointer;
            text-decoration: underline;
        }

        /* Modal scroll fix */
        .modal-dialog-scrollable {
            max-height: 90vh; /* Limit modal height */
        }
        .modal-dialog-scrollable .modal-body {
            overflow-y: auto; /* Ensure body scrolls */
             max-height: calc(90vh - 120px); /* Adjust based on header/footer height */
        }
        #surveyTabContent {
            overflow: visible !important; /* Prevent double scrollbars */
        }

        /* Tab Completion Indicator */
        .nav-link .tab-completion-indicator {
            margin-left: 5px;
            font-size: 0.8em;
            vertical-align: middle;
        }
        .tab-complete .tab-completion-indicator {
            color: #28a745; /* Green checkmark */
        }
        .tab-incomplete .tab-completion-indicator {
             color: #ffc107; /* Orange circle for incomplete */
        }

        /* --- End of Existing Styles --- */
    </style>
</head>
<body>
    <div class="main-container">
        <!-- ... (rest of your header, nav, filters) ... -->
         <div class="page-header" style="background-color: #D7E8FF; padding: 20px 20px 0 20px; position: relative;">
            <div class="container-fluid">
                <!-- Logo and Title Section -->
                <div class="d-flex justify-content-between align-items-center" style="margin-bottom: 1.5rem;">
                    <a href="/" style="flex: 0 0 auto;">
                        <img src="./MoralCubeLogo.png" alt="Moral Cube Logo" style="height: 140px; width: auto; object-fit: contain;"/>
                    </a>
                    <h1 class="text-center mx-auto" style="font-family: 'Playfair Display', serif; font-size: 5.5rem; font-weight: 600; margin-right: 140px;">The Moral Cube</h1>
                    <div style="flex: 0 0 140px;"></div>
                </div>

                <!-- Navigation Menu -->
                <nav class="navbar navbar-expand-lg navbar-light p-0" style="margin-top: auto; border-top: 1px solid rgba(0, 0, 0, 0.1); box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.05);">
                    <div class="collapse navbar-collapse d-flex justify-content-between" id="navbarNav">
                        <!-- Center Menu Items -->
                        <ul class="navbar-nav mx-auto" style="padding: 0.5rem 0;">
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="/">Home</a>
                            </li>
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="#" data-toggle="modal" data-target="#whatIsModal">What is the Moral Cube?</a>
                            </li>
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="#" data-toggle="modal" data-target="#howToUseModal">How to use the Cube</a>
                            </li>
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="/feedback.html">Feedback</a>
                            </li>
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="https://www.youtube.com/watch?v=hauuDOrZQ1o" target="_blank">Learn More</a>
                            </li>
                            <li class="nav-item mx-3">
                                <a class="nav-link" href="#" id="my-surveys-btn">My Surveys</a>
                            </li>
                        </ul>

                        <!-- Auth buttons container -->
                        <div class="d-flex align-items-center" style="min-width: 200px; justify-content: flex-end;">
                            <button id="login" class="btn" style="
                                font-family: 'Inter', sans-serif;
                                font-weight: 500;
                                background-color: #D7E8FF;
                                color: #2C5282;
                                border: 1px solid #D7E8FF;
                                transition: all 0.2s ease;
                                margin-right: 8px;
                                white-space: nowrap;">
                                Log In / Sign Up
                            </button>
                            <div id="user-container" class="d-none d-flex align-items-center">
                                <img id="user-avatar" class="rounded-circle me-2" style="width: 32px; height: 32px; display: none;" alt="Profile">
                                <button id="logout" class="btn" style="
                                    font-family: 'Inter', sans-serif;
                                    font-weight: 500;
                                    background-color: #F7FAFC;
                                    color: #4A5568;
                                    border: 1px solid #E2E8F0;
                                    transition: all 0.2s ease;
                                    white-space: nowrap;">
                                    Log Out
                                </button>
                            </div>
                        </div>
                    </div>
                </nav>
            </div>
        </div>

        <div class="filter-section">
            <div class="filter-group category-filter-group">
                <label for="categoryFilter">Categories:</label>
                <select id="categoryFilter" class="form-control category-select" multiple size="6"></select>
            </div>
            <div class="filter-group scenario-filter-group">
                <label for="scenarioFilter">
                    Scenarios
                    <span class="tooltip">
                        <i class="fas fa-info-circle info-icon"></i>
                        <span class="tooltiptext">Hold Ctrl (Cmd on Mac) to select multiple scenarios</span>
                    </span>
                </label>
                <select id="scenarioFilter" class="form-control scenario-select" multiple size="6"></select>
            </div>
            <div class="filter-group model-filter-group">
                <label for="modelFilter">
                    AI Models
                    <span class="tooltip">
                        <i class="fas fa-info-circle info-icon"></i>
                        <span class="tooltiptext">Hold Ctrl (Cmd on Mac) to select multiple models</span>
                    </span>
                </label>
                <select id="modelFilter" class="form-control model-select" multiple size="6"></select>
            </div>
            <div class="filter-group">
                <label>
                    What If Scenarios
                    <span class="tooltip">
                        <i class="fas fa-info-circle info-icon"></i>
                        <span class="tooltiptext">Hold Ctrl (Cmd on Mac) to select multiple outcomes</span>
                    </span>
                </label>
                <select id="alternateOutcomes" class="form-control" multiple size="6">
                    <option disabled>Select a scenario and model to see alternates</option>
                </select>
            </div>

            <!-- User Surveys Section -->
            <div class="filter-group">
                <label>Your Recent Analyses</label>
                <div class="user-surveys-section" id="user-surveys-preview">
                    <div class="login-prompt">
                        <span>Log in to view your analyses or <span class="login-link" id="login-to-analyze">create a new one</span></span>
                    </div>
                </div>
            </div>

            <!-- New action buttons row at the bottom of filters -->
            <div class="filter-actions">
                <button id="clearFilters" class="btn btn-secondary">Reset Filters</button>
                <button id="analyze-scenario-btn" class="btn btn-primary">Analyze Scenario</button>
            </div>
        </div>


        <!-- New three-column layout -->
        <div id="overview-section" style="display: flex; width: 100%;">
            <!-- Left Column: Cube Plot (40% width) -->
            <div id="cube-column" style="width: 37%;">
                <div class="plot-container">
                    <div id="cube-plot"></div>
                </div>
                <!-- Moral Category Filter with Clear Filters button underneath -->
                <div class="filter-group">
                    <label>Filter by Moral Category:</label>
                    <div class="filter-badges">
                        <span class="filter-badge category-evil active" data-category="evil">Evil</span>
                        <span class="filter-badge category-virtue active" data-category="virtue">Virtue</span>
                        <span class="filter-badge category-vice active" data-category="vice">Vice</span>
                        <span class="filter-badge category-sin active" data-category="sin">Sin</span>
                        <span class="filter-badge category-morally-grey active" data-category="morally_grey">Morally Grey</span>
                        <span class="filter-badge category-world-building active" data-category="world_building">World Building</span>
                    </div>
                </div>
            </div>
            <div id="cards-column" style="width: 18%; padding: 0 10px;">
                <p style="font-size: 0.9rem; margin-bottom: 0.5rem;">Select 2 scenarios/models to compare:</p>
                <div id="overview"></div>
            </div>

            <!-- Right Column: Overview Placeholder for Video/Website -->
            <div id="placeholder-overview-column" style="width: 45%; padding: 0 10px; display: flex; flex-direction: column; height: 500px;">
                <div id="media-placeholder" style="flex-grow: 1; border: none; overflow: hidden;"></div>
                <button id="open-media" class="btn btn-secondary btn-sm mt-2" style="width: 100%;">Open in New Window</button>
            </div>
        </div>

        <div id="scenarioSection" class="scenario-section">
            <h4 class="mb-3">
                Scenario Details
                <span class="tooltip-container">
                    <i class="fas fa-info-circle tooltip-icon"></i>
                    <span class="tooltip-content">Click two Scenario Cards above to compare the answers</span>
                </span>
            </h4>
            <div class="accordion" id="scenarioAccordion">
                 <div class="text-center text-muted p-3">
                    Select two scenario cards above to compare details
                 </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <!-- ... (What is Modal, How To Use Modal - unchanged) ... -->
    <div class="modal fade" id="whatIsModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">What is the Moral Cube?</h5>
                    <button type="button" class="close" data-dismiss="modal">
                        <span>&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="introduction mb-4">
                        <h4 class="mb-3">Understanding the Moral Cube</h4>
                        <p>The Moral Cube is a tool designed to help people think more clearly about moral decisions. It provides a structured way to assess actions by considering three key dimensions: <strong>Ends (Goals & Intentions), Means (Sacrifice), and Character (Awareness & Self-Control).</strong></p>
                    </div>

                    <div class="concept mb-4">
                        <h5 class="mb-3">The Concept</h5>
                        <p>Rather than prescribing what is right or wrong, the Cube offers a space for reflection. By answering questions about motivation, sacrifice, and character, each scenario is mapped onto three orthogonal (right-angle) axes—<strong>x, y, and z.</strong> This creates a unique position within the Cube that represents the moral complexity of each action.</p>
                    </div>

                    <div class="purpose mb-4">
                        <h5 class="mb-3">Why Use the Moral Cube?</h5>
                        <p>The Moral Cube isn't just about exploring different perspectives—it's about understanding <em>why</em> we judge actions as right or wrong. When good intentions clash with difficult trade-offs, the Cube helps break down these decisions into clear components.</p>

                        <p>By using the Cube, you can compare moral reasoning across time, between people, and even with AI systems. This comparison reveals where human and machine perspectives align or differ, offering valuable insights as AI becomes increasingly prevalent in our world.</p>
                    </div>

                    <div class="approach mb-4">
                        <h5 class="mb-3">Our Approach</h5>
                        <p>We often rely on intuition or cultural norms for moral judgments. The Moral Cube offers a more structured path. It helps align your values with your actions while fostering meaningful discussions about complex ethical choices.</p>
                    </div>

                    <div class="conclusion text-center mt-4">
                        <p><strong>Explore, reflect, and discover your moral perspective within the Cube.</strong></p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- How to Use Modal -->
    <div class="modal fade" id="howToUseModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">How to Use the Moral Cube</h5>
                    <button type="button" class="close" data-dismiss="modal">
                        <span>&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="introduction mb-4">
                        <h4 class="mb-3">Welcome to the Moral Cube</h4>
                        <p>The Moral Cube is an interactive tool for exploring ethical scenarios and their analyses by various AI models. This guide will help you navigate and maximize the platform's capabilities.</p>
                    </div>

                    <div class="getting-started mb-4">
                        <h5 class="mb-3">Getting Started</h5>
                        <p>Begin your exploration through either of these approaches:</p>
                        <div class="ml-4">
                            <p><strong>Category-Based Exploration:</strong> Select a Category Type to view related scenarios, providing a thematic approach to ethical exploration.</p>
                            <p><strong>Direct Scenario Selection:</strong> Choose specific scenarios from the complete list if you have particular cases in mind.</p>
                        </div>
                    </div>

                    <div class="comparison-features mb-4">
                        <h5 class="mb-3">Comparing Scenarios and Models</h5>
                        <p>The platform offers multiple comparison capabilities:</p>
                        <div class="ml-4">
                            <p><strong>Scenario Selection:</strong> Use Ctrl+Click (PC) or tap multiple options (mobile/tablet) to select scenarios for comparison. The system supports up to four scenarios simultaneously.</p>
                            <p><strong>AI Model Analysis:</strong> Once you select a scenario, the platform displays available AI models that have analyzed that particular case.</p>
                            <p><strong>Alternative Scenarios:</strong> Many cases include hypothetical variations, demonstrating how subtle changes in actions can significantly affect ethical positioning within the cube.</p>
                        </div>
                    </div>

                    <div class="detailed-analysis mb-4">
                        <h5 class="mb-3">Exploring Detailed Analysis</h5>
                        <p>For optimal analysis review:</p>
                        <div class="ml-4">
                            <p><strong>Side-by-Side Comparison:</strong> Select two scenarios to view a detailed comparison in the Scenario Details section. This limitation ensures clear and meaningful analysis presentation.</p>
                            <p><strong>Enhanced Understanding:</strong> Each question and justification includes informative tooltips. Hover over the information (i) and question (?) icons to access additional context about the models' evaluation criteria.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Survey Modal -->
    <div class="modal fade" id="surveyModal" tabindex="-1" role="dialog" aria-labelledby="surveyModalLabel" aria-hidden="true"
         data-backdrop="static" data-keyboard="false"> {/* Requirement 7: Prevent closing on backdrop click */}
      <div class="modal-dialog modal-xl modal-dialog-scrollable" role="document"> {/* Added modal-dialog-scrollable */}
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="surveyModalLabel">Submit Your Moral Analysis</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body">
            {/* Survey Metadata */}
            <div class="form-section mb-4">
              <h5 class="mb-3">Scenario Information</h5>

              {/* Hidden fields for protected data */}
              <input type="hidden" id="scenario-id">
              <input type="hidden" id="scenario-type" value="base">
              <input type="hidden" id="scenario-parent-id">
              <input type="hidden" id="llm-model" value="User Submission">
              <input type="hidden" id="llm-version" value="1.0">
              <input type="hidden" id="llm-provider" value="Human">
              <input type="hidden" id="survey-status" value="draft"> {/* Added status field */}

              <div class="row">
                <div class="col-md-6">
                  <div class="form-group">
                    <label for="scenario-title-display">Scenario Title</label>
                    <input type="text" class="form-control" id="scenario-title-display" readonly>
                  </div>
                </div>
                <div class="col-md-6">
                  <div class="form-group">
                    <label for="scenario-category-display">Category</label>
                    <input type="text" class="form-control" id="scenario-category-display" readonly>
                  </div>
                </div>
              </div>

              <div class="form-group">
                <label for="scenario-description-display">Scenario Description</label>
                <textarea class="form-control" id="scenario-description-display" rows="3" readonly></textarea>
              </div>

              <div class="form-group">
                <label for="scenario-url">Reference URL</label>
                <input type="url" class="form-control" id="scenario-url" readonly>
              </div>

              <div class="form-group">
                <label for="moral-classification">Moral Classification <span class="text-danger">*</span></label>
                <select class="form-control" id="moral-classification">
                  <option value="" selected disabled>Select classification</option>
                  <option value="evil">Evil</option>
                  <option value="virtue">Virtue</option>
                  <option value="vice">Vice</option>
                  <option value="sin">Sin</option>
                  <option value="morally_grey">Morally Grey</option>
                  <option value="world_building">World Building</option>
                </select>
              </div>

              <div class="form-group">
                <label for="classification-justification">Classification Justification</label> {/* Removed asterisk, now optional */}
                <textarea class="form-control" id="classification-justification" rows="2" placeholder="Explain why you chose this classification (Optional)"></textarea>
              </div>
            </div>

            {/* Survey Tabs */}
            <ul class="nav nav-tabs" id="surveyTabs" role="tablist">
              <li class="nav-item">
                <a class="nav-link active" id="ends-tab" data-toggle="tab" href="#ends" role="tab">Ends (Motivation) <span class="tab-completion-indicator"></span></a>
              </li>
              <li class="nav-item">
                <a class="nav-link" id="means-tab" data-toggle="tab" href="#means" role="tab">Means (Sacrifice) <span class="tab-completion-indicator"></span></a>
              </li>
              <li class="nav-item">
                <a class="nav-link" id="character-tab" data-toggle="tab" href="#character" role="tab">Character <span class="tab-completion-indicator"></span></a>
              </li>
              <li class="nav-item">
                <a class="nav-link" id="philosophy-tab" data-toggle="tab" href="#philosophy" role="tab">Philosophy <span class="tab-completion-indicator"></span></a>
              </li>
            </ul>

            <div class="tab-content p-3 border border-top-0 rounded-bottom" id="surveyTabContent">
              {/* --- Ends (Motivation) Tab --- */}
              <div class="tab-pane fade show active" id="ends" role="tabpanel">
                <div class="question-section mb-4">
                  {/* Societal Needs */}
                  <div class="question-item p-3 mb-3 border rounded">
                    <h5>Societal Needs <span class="badge badge-primary">X Axis</span></h5>
                    <p class="text-muted small">To what extent was the action focused on fulfilling societal needs such as justice, fairness, equality, respect for persons, or promoting the common good?</p>
                    <div class="form-group">
                      <label for="societal-needs-score">Score (0.0-10.0) <span class="text-danger">*</span></label>
                      <input type="number" class="form-control survey-field" id="societal-needs-score" min="0" max="10" step="0.5">
                      <small class="form-text text-muted">Rate on a scale of 0 (Not at all) to 10 (Extremely).</small> {/* Updated Scale Text */}
                    </div>
                    <div class="form-group">
                      <label for="societal-needs-justification">Justification</label> {/* Optional */}
                      <textarea class="form-control survey-field" id="societal-needs-justification" rows="2"></textarea>
                    </div>
                  </div>
                  {/* Others' Needs */}
                  <div class="question-item p-3 mb-3 border rounded">
                    <h5>Others' Needs <span class="badge badge-primary">X Axis</span></h5>
                    <p class="text-muted small">To what extent was the action focused on fulfilling others' needs related to physiology, safety, love/belonging, esteem, or self-actualization?</p>
                    <div class="form-group">
                      <label for="others-needs-score">Score (0.0-10.0) <span class="text-danger">*</span></label>
                      <input type="number" class="form-control survey-field" id="others-needs-score" min="0" max="10" step="0.5">
                       <small class="form-text text-muted">Rate on a scale of 0 (Not at all) to 10 (Extremely).</small>
                    </div>
                    <div class="form-group">
                      <label for="others-needs-justification">Justification</label>
                      <textarea class="form-control survey-field" id="others-needs-justification" rows="2"></textarea>
                    </div>
                  </div>
                  {/* Others' Wants */}
                  <div class="question-item p-3 mb-3 border rounded">
                    <h5>Others' Wants <span class="badge badge-primary">X Axis</span></h5>
                    <p class="text-muted small">To what extent was the action focused on fulfilling others' wants such as financial gain, social recognition, praise, power, appearance, conformity, reward, competition, or security?</p>
                    <div class="form-group">
                      <label for="others-wants-score">Score (0.0-10.0) <span class="text-danger">*</span></label>
                      <input type="number" class="form-control survey-field" id="others-wants-score" min="0" max="10" step="0.5">
                       <small class="form-text text-muted">Rate on a scale of 0 (Not at all) to 10 (Extremely).</small>
                    </div>
                    <div class="form-group">
                      <label for="others-wants-justification">Justification</label>
                      <textarea class="form-control survey-field" id="others-wants-justification" rows="2"></textarea>
                    </div>
                  </div>
                  {/* Personal Needs */}
                   <div class="question-item p-3 mb-3 border rounded">
                      <h5>Personal Needs <span class="badge badge-primary">X Axis</span></h5>
                      <p class="text-muted small">To what degree was the action motivated by fulfilling essential personal needs such as safety, physiological survival, or self-actualisation?</p>
                      <div class="form-group">
                        <label for="personal-needs-score">Score (0.0-10.0) <span class="text-danger">*</span></label> {/* Scale Changed */}
                        <input type="number" class="form-control survey-field" id="personal-needs-score" min="0" max="10" step="0.5">
                        <small class="form-text text-muted">Rate on a scale of 0 (Not at all) to 10 (Extremely). This value contributes negatively to the X score.</small> {/* Updated Scale Text */}
                      </div>
                      <div class="form-group">
                        <label for="personal-needs-justification">Justification</label> {/* Optional */}
                        <textarea class="form-control survey-field" id="personal-needs-justification" rows="2"></textarea>
                      </div>
                    </div>
                  {/* Personal Wants */}
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Personal Wants <span class="badge badge-primary">X Axis</span></h5>
                      <p class="text-muted small">To what extent was the action focused on fulfilling personal wants such as financial gain, social recognition, praise, power, appearance, conformity, reward, competition, or security?</p>
                      <div class="form-group">
                        <label for="personal-wants-score">Score (0.0-10.0) <span class="text-danger">*</span></label> {/* Scale Changed */}
                        <input type="number" class="form-control survey-field" id="personal-wants-score" min="0" max="10" step="0.5">
                        <small class="form-text text-muted">Rate on a scale of 0 (Not at all) to 10 (Extremely). This value contributes negatively to the X score.</small> {/* Updated Scale Text */}
                      </div>
                      <div class="form-group">
                        <label for="personal-wants-justification">Justification</label> {/* Optional */}
                        <textarea class="form-control survey-field" id="personal-wants-justification" rows="2"></textarea>
                      </div>
                    </div>
                </div>
              </div>

              {/* --- Means (Sacrifice) Tab --- */}
              <div class="tab-pane fade" id="means" role="tabpanel">
                 <div class="question-section mb-4">
                    {/* Future Self-Sacrifice */}
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Future Self-Sacrifice <span class="badge badge-success">Y Axis</span></h5>
                      <p class="text-muted small">To what extent did the action require sacrifices that impact the future self? Consider aspects like future plans, core values, psychological wellbeing, life goals, elements of personal identity and legacy, health, and long-term well-being.</p>
                      <div class="form-group">
                        <label for="future-sacrifice-score">Score (0.0-10.0) <span class="text-danger">*</span></label> {/* Scale Changed */}
                        <input type="number" class="form-control survey-field" id="future-sacrifice-score" min="0" max="10" step="0.5">
                        <small class="form-text text-muted">Rate on a scale of 0 (No sacrifice) to 10 (Extreme sacrifice).</small> {/* Updated Scale Text */}
                      </div>
                      <div class="form-group">
                        <label for="future-sacrifice-justification">Justification</label> {/* Optional */}
                        <textarea class="form-control survey-field" id="future-sacrifice-justification" rows="2"></textarea>
                      </div>
                    </div>
                    {/* Number of Individuals Affected */}
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Number of Individuals Affected <span class="badge badge-success">Y Axis</span></h5>
                      <p class="text-muted small">How many people were impacted by the sacrifice or harm?</p>
                      <div class="form-group">
                        <label for="individuals-affected-score">Score (0.0-10.0) <span class="text-danger">*</span></label> {/* Scale Changed */}
                        <input type="number" class="form-control survey-field" id="individuals-affected-score" min="0" max="10" step="0.5">
                        <small class="form-text text-muted">Rate on a scale of 0 (None) to 10 (Very large number affected).</small> {/* Updated Scale Text */}
                      </div>
                      <div class="form-group">
                        <label for="individuals-affected-justification">Justification</label> {/* Optional */}
                        <textarea class="form-control survey-field" id="individuals-affected-justification" rows="2"></textarea>
                      </div>
                    </div>
                    {/* Type of Sacrifice */}
                     <div class="question-item p-3 mb-3 border rounded">
                      <h5>Type of Sacrifice <span class="badge badge-success">Y Axis</span></h5>
                      <p class="text-muted small">What was the severity of the impact on each individual in terms of what they lost (time, money, resources, freedom, life)?</p>
                      <div class="form-group">
                        <label for="sacrifice-type-score">Score (0.0-10.0) <span class="text-danger">*</span></label> {/* Scale Changed */}
                        <input type="number" class="form-control survey-field" id="sacrifice-type-score" min="0" max="10" step="0.5">
                        <small class="form-text text-muted">Rate on a scale of 0 (No impact) to 10 (Extreme impact/Loss of life).</small> {/* Updated Scale Text */}
                      </div>
                      <div class="form-group">
                        <label for="sacrifice-type-justification">Justification</label> {/* Optional */}
                        <textarea class="form-control survey-field" id="sacrifice-type-justification" rows="2"></textarea>
                      </div>
                    </div>
                    {/* Duration of Sacrifice */}
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Duration of Sacrifice <span class="badge badge-success">Y Axis</span></h5>
                      <p class="text-muted small">How long do you think the sacrifice affected the individuals involved (short-term vs. long-term impact)?</p>
                      <div class="form-group">
                        <label for="sacrifice-duration-score">Score (0.0-10.0) <span class="text-danger">*</span></label> {/* Scale Changed */}
                        <input type="number" class="form-control survey-field" id="sacrifice-duration-score" min="0" max="10" step="0.5">
                        <small class="form-text text-muted">Rate on a scale of 0 (No lasting impact) to 10 (Irreversible impact).</small> {/* Updated Scale Text */}
                      </div>
                      <div class="form-group">
                        <label for="sacrifice-duration-justification">Justification</label> {/* Optional */}
                        <textarea class="form-control survey-field" id="sacrifice-duration-justification" rows="2"></textarea>
                      </div>
                    </div>
                     {/* Magnitude of Life Impacted */}
                    <div class="question-item p-3 mb-3 border rounded">
                      <h5>Magnitude of Life Impacted <span class="badge badge-success">Y Axis</span></h5>
                      <p class="text-muted small">To what extent did the action impact life, considering the type and vulnerability of the affected organism(s)?</p>
                      <div class="form-group">
                        <label for="life-magnitude-score">Score (0.0-10.0) <span class="text-danger">*</span></label> {/* Scale Changed */}
                        <input type="number" class="form-control survey-field" id="life-magnitude-score" min="0" max="10" step="0.5">
                        <small class="form-text text-muted">Rate on a scale of 0 (e.g., Bacteria/Insects) to 10 (e.g., Vulnerable humans).</small> {/* Updated Scale Text */}
                      </div>
                      <div class="form-group">
                        <label for="life-magnitude-justification">Justification</label> {/* Optional */}
                        <textarea class="form-control survey-field" id="life-magnitude-justification" rows="2"></textarea>
                      </div>
                    </div>
                 </div>
              </div>

              {/* --- Character Tab --- */}
              <div class="tab-pane fade" id="character" role="tabpanel">
                <div class="question-section mb-4">
                    {/* Unconscious vs. Conscious */}
                    <div class="question-item p-3 mb-3 border rounded">
                        <h5>Unconscious vs. Conscious <span class="badge badge-warning">Z Axis</span></h5>
                        <p class="text-muted small">To what extent was the individual conscious of their actions and consequences?</p>
                        <div class="form-group">
                          <label for="consciousness-score">Score (0.0-10.0) <span class="text-danger">*</span></label> {/* Scale Changed */}
                          <input type="number" class="form-control survey-field" id="consciousness-score" min="0" max="10" step="0.5">
                          <small class="form-text text-muted">Rate on a scale of 0 (Unconscious) to 10 (Fully conscious).</small> {/* Updated Scale Text */}
                        </div>
                        <div class="form-group">
                          <label for="consciousness-justification">Justification</label> {/* Optional */}
                          <textarea class="form-control survey-field" id="consciousness-justification" rows="2"></textarea>
                        </div>
                      </div>
                    {/* Degree of Present Self-Sacrifice */}
                    <div class="question-item p-3 mb-3 border rounded">
                        <h5>Degree of Present Self-Sacrifice <span class="badge badge-warning">Z Axis</span></h5>
                        <p class="text-muted small">To what extent did the action require sacrifices from the individual's present self? Consider aspects like immediate comfort, desires, impulses, convenience, minor financial expenditures, or brief emotional distress.</p>
                        <div class="form-group">
                          <label for="present-sacrifice-score">Score (0.0-10.0) <span class="text-danger">*</span></label> {/* Scale Changed */}
                          <input type="number" class="form-control survey-field" id="present-sacrifice-score" min="0" max="10" step="0.5">
                          <small class="form-text text-muted">Rate on a scale of 0 (No sacrifice) to 10 (Extreme present sacrifice).</small> {/* Updated Scale Text */}
                        </div>
                        <div class="form-group">
                          <label for="present-sacrifice-justification">Justification</label> {/* Optional */}
                          <textarea class="form-control survey-field" id="present-sacrifice-justification" rows="2"></textarea>
                        </div>
                      </div>
                    {/* Habitual vs. Willpower */}
                     <div class="question-item p-3 mb-3 border rounded">
                        <h5>Habitual vs. Willpower <span class="badge badge-warning">Z Axis</span></h5>
                        <p class="text-muted small">To what extent was the action driven by willpower versus habitual responses?</p>
                        <div class="form-group">
                          <label for="willpower-score">Score (0.0-10.0) <span class="text-danger">*</span></label> {/* Scale Changed */}
                          <input type="number" class="form-control survey-field" id="willpower-score" min="0" max="10" step="0.5">
                          <small class="form-text text-muted">Rate on a scale of 0 (Entirely habitual) to 10 (Fully willful).</small> {/* Updated Scale Text */}
                        </div>
                        <div class="form-group">
                          <label for="willpower-justification">Justification</label> {/* Optional */}
                          <textarea class="form-control survey-field" id="willpower-justification" rows="2"></textarea>
                        </div>
                      </div>
                    {/* Unintentional vs. Intentional */}
                    <div class="question-item p-3 mb-3 border rounded">
                        <h5>Unintentional vs. Intentional <span class="badge badge-warning">Z Axis</span></h5>
                        <p class="text-muted small">To what extent was the action intentional?</p>
                        <div class="form-group">
                          <label for="intentionality-score">Score (0.0-10.0) <span class="text-danger">*</span></label> {/* Scale Changed */}
                          <input type="number" class="form-control survey-field" id="intentionality-score" min="0" max="10" step="0.5">
                          <small class="form-text text-muted">Rate on a scale of 0 (Unintentional) to 10 (Fully intentional).</small> {/* Updated Scale Text */}
                        </div>
                        <div class="form-group">
                          <label for="intentionality-justification">Justification</label> {/* Optional */}
                          <textarea class="form-control survey-field" id="intentionality-justification" rows="2"></textarea>
                        </div>
                      </div>
                    {/* Wills at Play */}
                    <div class="question-item p-3 mb-3 border rounded">
                        <h5>Wills at Play <span class="badge badge-warning">Z Axis</span></h5>
                        <p class="text-muted small">List the Wills and provide a one sentence justification as to why that Will might have influenced the scenario.</p>
                        <div class="form-group">
                          <label for="wills-justification">Response</label> {/* Optional */}
                          <textarea class="form-control survey-field" id="wills-justification" rows="4"></textarea>
                        </div>
                      </div>
                </div>
              </div>

              {/* --- Philosophy Tab --- */}
              <div class="tab-pane fade" id="philosophy" role="tabpanel">
                <div class="question-section mb-4">
                    {/* Deontology */}
                    <div class="question-item p-3 mb-3 border rounded">
                        <h5>Deontology</h5>
                        <p class="text-muted small">In one paragraph, explain why this action was right or wrong through a deontological lens.</p>
                        <div class="form-group">
                          <label for="deontology-score">Evaluation <span class="text-danger">*</span></label>
                          <select class="form-control survey-field" id="deontology-score">
                            <option value="" selected disabled>Select evaluation</option>
                            <option value="Right">Right</option>
                            <option value="Wrong">Wrong</option>
                            <option value="Neutral">Morally Neutral</option>
                            <option value="Complex">Morally Complex</option>
                          </select>
                        </div>
                        <div class="form-group">
                          <label for="deontology-justification">Justification</label> {/* Optional */}
                          <textarea class="form-control survey-field" id="deontology-justification" rows="3"></textarea>
                        </div>
                      </div>
                    {/* Utilitarianism */}
                     <div class="question-item p-3 mb-3 border rounded">
                        <h5>Utilitarianism</h5>
                        <p class="text-muted small">In two paragraphs, explain why this action was right or wrong from a utilitarian and negative utilitarian perspective.</p>
                        <div class="form-group">
                          <label for="utilitarianism-score">Evaluation <span class="text-danger">*</span></label>
                          <select class="form-control survey-field" id="utilitarianism-score">
                            <option value="" selected disabled>Select evaluation</option>
                            <option value="Right">Right</option>
                            <option value="Wrong">Wrong</option>
                            <option value="Neutral">Morally Neutral</option>
                            <option value="Complex">Morally Complex</option>
                          </select>
                        </div>
                        <div class="form-group">
                          <label for="utilitarianism-justification">Justification</label> {/* Optional */}
                          <textarea class="form-control survey-field" id="utilitarianism-justification" rows="4"></textarea>
                        </div>
                      </div>
                    {/* Virtue Ethics */}
                    <div class="question-item p-3 mb-3 border rounded">
                        <h5>Virtue Ethics</h5>
                        <p class="text-muted small">From an Aristotelian perspective, explain what virtues or vices were at play within this action.</p>
                        <div class="form-group">
                          <label for="virtue-ethics-score">Evaluation <span class="text-danger">*</span></label>
                          <select class="form-control survey-field" id="virtue-ethics-score">
                            <option value="" selected disabled>Select evaluation</option>
                            <option value="Virtuous">Virtuous</option>
                            <option value="Vicious">Vicious</option>
                            <option value="Mixed">Mixed Virtues/Vices</option>
                            <option value="Neutral">Neither Virtuous nor Vicious</option>
                          </select>
                        </div>
                        <div class="form-group">
                          <label for="virtue-ethics-justification">Justification</label> {/* Optional */}
                          <textarea class="form-control survey-field" id="virtue-ethics-justification" rows="3"></textarea>
                        </div>
                      </div>
                </div>
              </div>
            </div>

            {/* Progress Bar */}
            <div class="progress mt-3">
              <div class="progress-bar" id="survey-progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
            </div>

            {/* Submission Controls */}
            <div class="survey-controls mt-3 d-flex justify-content-between">
               <div> {/* Button Group for Draft */}
                 <button type="button" class="btn btn-info save-draft-btn">Save Draft</button>
               </div>
               <div> {/* Button Group for Navigation/Submit */}
                 <button type="button" class="btn btn-secondary prev-tab-btn" disabled>Previous</button>
                 <button type="button" class="btn btn-primary next-tab-btn">Next</button>
                 <button type="button" class="btn btn-success submit-survey-btn" style="display: none;">Submit Analysis</button>
               </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- User Surveys List Modal -->
    <div class="modal fade" id="userSurveysModal" tabindex="-1" role="dialog" aria-labelledby="userSurveysModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="userSurveysModalLabel">My Surveys</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body">
            <div class="table-responsive">
              <table class="table table-striped table-hover" id="user-surveys-table">
                <thead>
                  <tr>
                    <th>Title</th>
                    <th>Category</th>
                    <th>Date</th>
                    <th>Status</th> {/* Added Status Column */}
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody id="user-surveys-body">
                  {/* Populated dynamically */}
                  <tr>
                    <td colspan="5" class="text-center">Loading surveys...</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" id="create-new-survey-btn">Create New Analysis</button>
            <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>
    <!-- ... (Scenario Select Modal - unchanged) ... -->
    <div class="modal fade" id="scenarioSelectModal" tabindex="-1" role="dialog" aria-labelledby="scenarioSelectModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="scenarioSelectModalLabel">Select a Scenario to Analyze</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body">
            <!-- Search and filters -->
            <div class="form-group">
              <input type="text" class="form-control" id="scenario-search" placeholder="Search scenarios...">
            </div>

            <div class="table-responsive mt-3">
              <table class="table table-striped table-hover" id="scenarios-table">
                <thead>
                  <tr>
                    <th>Title</th>
                    <th>Category</th>
                    <!--<th>Model</th>--> {/* Removed Model column - handled in next step */}
                    <!--<th>Type</th>-->   {/* Removed Type column */}
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody id="scenarios-body">
                  <!-- Will be populated dynamically -->
                </tbody>
              </table>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
          </div>
        </div>
      </div>
    </div>
    <!-- ... (Model Selection Modal - unchanged from previous refinement) ... -->
     <div id="modelSelectionContainer">
        <div class="modal fade" id="modelSelectionModal" tabindex="-1" role="dialog">
            <div class="modal-dialog" role="document">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Choose Analysis Method</h5>
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <h6 id="model-scenario-title"></h6>
                        <p>How would you like to analyze this scenario?</p>

                        <div class="list-group mb-3" id="model-options">
                            <button type="button" class="list-group-item list-group-item-action" id="own-analysis-btn">
                                <i class="fas fa-user mr-2"></i> Enter my own analysis
                            </button>
                        </div>

                        <div class="text-center text-muted" id="loading-models" style="display: none;">
                            <div class="spinner-border spinner-border-sm" role="status">
                                <span class="sr-only">Loading models...</span>
                            </div>
                            <span>Loading available AI models...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
     </div>

    <script>
        // --- Existing questionTooltips, AuthManager, ScenarioDataProcessor ---
         const questionTooltips = {
                "Societal Needs": {
                    info: "If needs are essential elements to ensure survival and growth (e.g., food, water, security, love), then societal needs are essential for the survival and growth of a society. Societal needs include maintaining justice, fairness, and trust in social institutions (e.g., don't lie, keep promises, don't steal, help others, uphold justice, avoid cruelty). When these societal needs are met, societies function harmoniously, promoting the well-being of individuals within them.",
                    question: "To what extent was the action focused on fulfilling societal needs such as justice, fairness, equality, respect for persons, or promoting the common good?"
                },
                "Others Needs": {
                    info: "Needs are often necessary for survival or fulfilling a core purpose. When essential needs (e.g., hunger, safety, belonging) are not met, there is an increase in unpleasant sensations. Meeting these needs reduces discomfort and ensures survival and well-being. This question focuses on whether the action was aimed at fulfilling others' essential needs.",
                    question: "To what extent was the action focused on fulfilling others' needs related to physiology, safety, love/belonging, esteem, or self-actualization?"
                },
                "Others Wants": {
                    info: "Wants are often tied to increasing pleasant sensations or achieving rewards and favourable outcomes. They are not essential for survival but often relate to desires for financial gain, recognition, or status. This question focuses on whether the action was aimed at fulfilling others' non-essential wants.",
                    question: "To what extent was the action focused on fulfilling others' wants such as financial gain, social recognition, praise, power, appearance, conformity, reward, competition, or security?"
                },
                "Personal Needs": {
                    info: "Needs are often essential for personal survival or fulfilling a core purpose. When these needs are unmet, unpleasant sensations arise (e.g., hunger, lack of security or belonging). Meeting personal needs reduces this discomfort. This question focuses on whether the action was primarily aimed at fulfilling personal essential needs.",
                    question: "To what degree was the action motivated by fulfilling essential personal needs such as safety, physiological survival, or self-actualisation?"
                },
                "Personal Wants": {
                    info: "Wants are most often tied to desires for rewards or pleasant sensations, beyond essential needs. These can include financial gain, praise, or social recognition. This question assesses whether the action was motivated by fulfilling personal non-essential wants.",
                    question: "To what extent was the action focused on fulfilling personal wants such as financial gain, social recognition, praise, power, appearance, conformity, reward, competition, or security?"
                },
                "Future Self-Sacrifice": {
                    info: "Our future selves don't exist yet and morally speaking would be considered an 'other', treated as an agent yet to come. When we make decisions that negatively impact our future, it is similar to making a decision that impacts another person's future morally speaking. With this in mind evaluate the level of sacrifice affecting the future self, including future versions of oneself, cumulative identity, long-term values, and future aspirations. This encompasses actions that impact deeply held values, long-term plans, fundamental life goals, health, or personal well-being.",
                    question: "To what extent did the action require sacrifices that impact the future self? Consider aspects like future plans, core values, psychological wellbeing, life goals, elements of personal identity and legacy, health, and long-term well-being."
                },
                "Number of Individuals Affected": {
                    info: "",
                    question: "How many people were impacted by the sacrifice or harm?"
                },
                "Type of Sacrifice": {
                    info: "",
                    question: "What was the severity of the impact on each individual in terms of what they lost (time, money, resources, freedom, life)?"
                },
                "Duration of Sacrifice": {
                    info: "",
                    question: "How long do you think the sacrifice affected the individuals involved (short-term vs. long-term impact)?"
                },
                "Magnitude of Life Impacted": {
                    info: "Evaluate the magnitude of the sacrifice based on the type of life impacted. Smaller organisms like bacteria and insects are assigned lower values, while more complex and sentient life forms, such as animals and humans, are assigned higher values. Additionally, consider the vulnerability of individuals; for example, children or disabled humans may have a slightly higher weighting due to their increased dependency and reduced capacity to defend themselves.",
                    question: "To what extent did the action impact life, considering the type and vulnerability of the affected organism(s)? Use the following scale to assess the magnitude of impact per individual:"
                },
                "Unconscious vs Conscious": {
                    info: "Evaluate the individual's level of awareness regarding their actions and their consequences. Consider whether the action was performed reflexively, partially consciously, or with full mindfulness.",
                    question: "To what extent was the individual conscious of their actions and consequences?"
                },
                "Present Self-Sacrifice": {
                    info: "A component of Self-Control is self-sacrifice, as we don't exercise self-control when we want to do something, only when we don't want to. Evaluate the level of sacrifice affecting the immediate, present self. This includes sacrifices that impact short-term desires, impulses, and needs—such as loss of comfort, overcoming impulses, inconvenience, or minor financial costs.",
                    question: "To what extent did the action require sacrifices from the individual's present self? Consider aspects like immediate comfort, desires, impulses, convenience, minor financial expenditures, or brief emotional distress."
                },
                "Habit vs Will Power": {
                    info: "Our actions exist somewhere on the spectrum from a habit to an exertion of will power. When we're doing something for the first time, or when we don't want to do something, we often require more will power. Noting that when we want to do something, or are chasing a desire, we also form habits. This question aims to reflect on whether the action was habitual or required will power, not differentiating between desire driven habits, or value aligned habits. Evaluate whether the individual acted out of ingrained habits or deliberate effort. Consider the effort required to override impulses or habitual behaviours.",
                    question: "To what extent was the action driven by willpower versus habitual responses?"
                },
                "Unintentional vs Intentional": {
                    info: "Our actions always have a measure of intentionality, was this what was being aimed at, was it influenced by unconscious intentions (desires), or was this a mistake (not intended at all). Assess whether the action was performed deliberately or occurred reflexively without deliberate thought.",
                    question: "To what extent was the action intentional?"
                },
                "Wills at Play": {
                    info: "Within each person is a composition of Wills, or unconscious drivers, with fundamental wills working together as a Will to Survive which should sit at the heart of every life form, and from that will survive do second order Wills emerging. Within the Will to survive are drives such as the Will to Consume, the Will to Homeostasis, the Will to Replicate for example, and emerging from the Will to Survive are higher order drives that might aid in our placement within a Hierarchy, or ensure genetic continuity such as a Will to Status, or a Will to Reproduction, even a Will to Create. Each of these Wills are in constant competition for airtime, there are some associated with the biological impulses (lust, envy, gluttony), and some associated with virtue (will to abstain, will to patience, empathy). Reflecting on this idea, what Wills do you think might be influencing this scenario and why?",
                    question: "List the Wills and provide a one sentence justification as to why that Will might have influenced the scenario."
                },
                "Deontology": {
                    info: "",
                    question: "In one paragraph could you explain why this action was right or wrong through a deontological lens?"
                },
                "Utilitarianism": {
                    info: "",
                    question: "In two paragraphs could you explain why this action was right or wrong from a utilitarian and negative utilitarian perspective?"
                },
                "Virtue Ethics": {
                    info: "",
                    question: "From an Aristotelian perspective could you explain what virtues or vices were at play within this action?"
                }
            };
            // Replace your current AuthManager with this enhanced implementation
            const AuthManager = {
            client: null,
            isInitializing: false,
            initError: null,
            lastInitAttempt: 0,
            tokenRefreshTimer: null,

            // Constants
            INIT_COOLDOWN: 5000, // 5 seconds between init attempts
            MAX_RETRIES: 3,
            TOKEN_REFRESH_MARGIN: 5 * 60 * 1000, // Refresh token 5 minutes before expiration

            /**
             * Safely initializes the Auth0 client with retry mechanism and session restoration
             * @returns {Promise<Object>} The initialized Auth0 client
             */
             initialize: async function() {
                // This method is now just a wrapper that calls the enhanced implementation
                try {
                    if (this.client) return this.client;

                    if (this.isInitializing) {
                    return new Promise((resolve, reject) => {
                        const checkInterval = setInterval(() => {
                        if (!this.isInitializing) {
                            clearInterval(checkInterval);
                            if (this.client) resolve(this.client);
                            else reject(this.initError || new Error("Auth0 client initialization failed"));
                        }
                        }, 100);
                    });
                    }

                    this.isInitializing = true;
                    this.lastInitAttempt = Date.now();

                    // Use the enhanced config from initializeApplication
                    const authConfig = {
                        domain: 'dev-10xzf0prvka6p40y.us.auth0.com',
                        clientId: 'o7n479CCBo1GoASsEQI3s44cIXdyvzJh',
                        authorizationParams: {
                            redirect_uri: 'https://themoralcube.com', // Make sure this matches Auth0 settings
                            scope: 'openid profile email offline_access read:current_user update:current_user_metadata', // Add necessary scopes
                            audience: 'https://dev-10xzf0prvka6p40y.us.auth0.com/api/v2/' // Needed for Management API
                        },
                        cacheLocation: 'localstorage',
                        useRefreshTokens: true,
                        useRefreshTokensFallback: true,
                        useCookiesForTransactions: true,
                        cookieDomain: window.location.hostname,
                        useFormData: true // Helps with some third-party cookie scenarios
                    };

                    console.log('Initializing Auth0 client with enhanced configuration...');
                    this.client = await auth0.createAuth0Client(authConfig);

                    // Handle redirect callback
                    if (window.location.search.includes("code=") && window.location.search.includes("state=")) {
                    try {
                        await this.client.handleRedirectCallback();
                        window.history.replaceState({}, document.title, window.location.pathname);
                    } catch (callbackError) {
                        console.error('Error handling redirect callback:', callbackError);
                    }
                    }

                    // Set up automatic token refresh
                    if (await this.client.isAuthenticated()) {
                    console.log('User authenticated, scheduling token refresh');
                    this.scheduleTokenRefresh();
                    }

                    return this.client;
                } catch (error) {
                    console.error('Auth0 initialization failed:', error);
                    this.initError = error;
                    throw error;
                } finally {
                    this.isInitializing = false;
                }
            },

            /**
             * Schedule token refresh before expiration
             */
            scheduleTokenRefresh: async function() {
                // Clear any existing refresh timer
                if (this.tokenRefreshTimer) {
                    clearTimeout(this.tokenRefreshTimer);
                    this.tokenRefreshTimer = null;
                }

                try {
                    // Check if we're authenticated before scheduling refresh
                    if (!await this.isUserAuthenticated()) {
                        console.log("No authenticated session to refresh");
                        return;
                    }

                    // Get current token claims to determine expiration
                    const token = await this.getToken({ignoreCache: false});
                    const claims = this.parseJwt(token);

                    if (!claims || !claims.exp) {
                        console.error("Could not parse token expiration");
                        // Fall back to fixed interval if we can't get expiration
                        this.tokenRefreshTimer = setTimeout(async () => {
                            try {
                                await this.getToken({ ignoreCache: true });
                                console.log('Token refreshed successfully (fallback)');
                                this.scheduleTokenRefresh();
                            } catch (error) {
                                console.error('Token refresh failed:', error);
                            }
                        }, 4.5 * 60 * 1000); // 4.5 minutes fallback
                        return;
                    }

                    // Calculate when token expires (in milliseconds)
                    const expiresAt = claims.exp * 1000;
                    const now = Date.now();

                    // Calculate when to refresh (5 minutes before expiration or sooner if already close)
                    const refreshIn = Math.max(0, expiresAt - now - this.TOKEN_REFRESH_MARGIN);

                    console.log(`Token expires in ${Math.floor((expiresAt - now) / 1000)} seconds, scheduling refresh in ${Math.floor(refreshIn / 1000)} seconds`);

                    // Schedule token refresh
                    this.tokenRefreshTimer = setTimeout(async () => {
                        try {
                            // Try to refresh token silently
                            await this.getToken({ ignoreCache: true });
                            console.log('Token refreshed successfully');

                            // Schedule next refresh
                            this.scheduleTokenRefresh();
                        } catch (error) {
                            console.error('Token refresh failed:', error);
                            // If refresh fails, check if user is still authenticated
                            const isAuthenticated = await this.isUserAuthenticated(true);
                            if (isAuthenticated) {
                                // Try again in 1 minute
                                setTimeout(() => this.scheduleTokenRefresh(), 60000);
                            }
                        }
                    }, refreshIn);
                } catch (error) {
                    console.error('Error scheduling token refresh:', error);
                }
            },

            /**
             * Parse JWT token to get claims
             * @param {string} token JWT token
             * @returns {Object|null} Parsed claims or null on failure
             */
            parseJwt: function(token) {
                try {
                if (!token) return null;
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));

                return JSON.parse(jsonPayload);
                } catch (error) {
                console.error('Error parsing JWT:', error);
                return null;
                }
            },

            /**
             * Safely gets the Auth0 client, initializing if necessary
             * @returns {Promise<Object>} The Auth0 client
             */
            async getClient() {
                if (!this.client) {
                return this.initialize();
                }
                return this.client;
            },

            /**
             * Checks if the user is authenticated, includes silent auth check
             * @param {boolean} forceCheck Force a fresh check rather than using cached state
             * @returns {Promise<boolean>} Whether user is authenticated
             */
            isUserAuthenticated: async function(forceCheck = false) {
                try {
                    const client = await this.getClient();
                    const isAuthenticated = await client.isAuthenticated({ ignoreCache: forceCheck });

                    // If authentication check fails, try to get token silently to restore session
                    if (!isAuthenticated && !forceCheck) {
                        try {
                            await this.getTokenSilently();
                            // Check again after silent attempt
                            return await client.isAuthenticated({ ignoreCache: true });
                        } catch (silentError) {
                            // Silent authentication failed, user truly not authenticated
                            return false;
                        }
                    }

                    return isAuthenticated;
                } catch (error) {
                    console.error('Error checking authentication status:', error);
                    return false;
                }
            },

             /**
             * Gets the authentication token with proper error handling and retries
             * @param {Object} options Token options
             * @returns {Promise<string>} The authentication token
             */
             async getToken(options = {}) {
                try {
                    const client = await this.getClient();
                    let retries = 0;
                    const maxRetries = options.maxRetries || 2;

                    while (retries <= maxRetries) {
                        try {
                             // Define required params, ensure audience is included for Management API
                            const authParams = {
                                audience: 'https://dev-10xzf0prvka6p40y.us.auth0.com/api/v2/',
                                scope: 'openid profile email read:current_user update:current_user_metadata offline_access'
                            };

                            return await client.getTokenSilently({
                                authorizationParams: authParams,
                                timeoutInSeconds: options.timeoutInSeconds || 60,
                                cacheMode: options.ignoreCache ? 'off' : 'on',
                                ...options
                            });
                        } catch (error) {
                            console.warn(`Token acquisition attempt ${retries + 1} failed:`, error);

                            // Specific handling for common errors
                            if (error.error === 'login_required' || error.error === 'consent_required') {
                                console.log("Silent auth failed, requires user interaction.");
                                throw error; // Don't retry if user interaction is needed
                            }

                            retries++;
                            if (retries <= maxRetries) {
                                await new Promise(resolve => setTimeout(resolve, 1000 * retries));
                            } else {
                                throw error; // Throw error after max retries
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error getting token:', error);
                    throw error; // Re-throw the final error
                }
            },


            /**
             * Try to get a token silently (without UI) to restore session
             * @returns {Promise<string>} Token if successful
             */
             getTokenSilently: async function() {
                try {
                    const client = await this.getClient();
                    return await client.getTokenSilently({
                        authorizationParams: {
                            audience: 'https://dev-10xzf0prvka6p40y.us.auth0.com/api/v2/',
                            scope: 'openid profile email read:current_user update:current_user_metadata offline_access'
                        },
                        timeoutInSeconds: 10, // Shorter timeout for silent check
                        detailedResponse: false
                    });
                } catch (error) {
                    // Don't log this as an error since it's expected in many cases (e.g., user not logged in)
                    console.log('Silent authentication failed:', error.message);
                    throw error; // Rethrow for the caller to handle
                }
            },

            /**
             * Gets the authenticated user profile
             * @param {boolean} forceRefresh Force a fresh profile fetch
             * @returns {Promise<Object>} User profile data
             */
            async getUser(forceRefresh = false) {
                try {
                const client = await this.getClient();
                // Use isUserAuthenticated which includes silent check
                const isAuthenticated = await this.isUserAuthenticated(forceRefresh);

                if (!isAuthenticated) {
                    return null;
                }

                return await client.getUser();
                } catch (error) {
                console.error('Error getting user profile:', error);
                return null;
                }
            },

            /**
             * Performs login with redirect, optionally forcing Google
             * @returns {Promise<void>}
             */
             login: async function() { // Simplified to force Google
                try {
                    const client = await this.getClient();
                    await client.loginWithRedirect({
                        authorizationParams: {
                            redirect_uri: window.location.origin,
                            scope: 'openid profile email', // Basic scopes for Google
                            connection: 'google-oauth2'  // Explicitly use Google
                        }
                    });
                } catch (error) {
                    console.error('Login redirect error:', error);
                    alert('Unable to login. Please try again.');
                }
            },


            /**
             * Performs logout
             * @returns {Promise<void>}
             */
             logout: async function() {
                try {
                    // Clear token refresh timer
                    if (this.tokenRefreshTimer) {
                        clearTimeout(this.tokenRefreshTimer);
                        this.tokenRefreshTimer = null;
                    }

                    const client = await this.getClient();

                    await client.logout({
                        logoutParams: {
                            returnTo: window.location.origin
                        }
                    });

                    // Clear any cached data (Important!)
                    this.client = null; // Force re-initialization on next interaction
                    // Consider clearing relevant localStorage/sessionStorage too if needed

                    // Update UI immediately after logout attempt
                    updateAuthUI();
                } catch (error) {
                    console.error('Logout error:', error);
                    alert('Logout failed. You may still be logged in locally.');
                     // Still try to update UI to reflect logged-out state
                    updateAuthUI();
                }
            }
            };

        // ScenarioDataProcessor (with fix for user survey handling)
        const ScenarioDataProcessor = {
            // State
            dataPoints: [],
            displayPoints: [],
            scenarioRelationships: new Map(),
            isProcessing: false,
            lastFetchTime: 0,

            // Constants
            FETCH_COOLDOWN: 5000, // 5 seconds between fetch attempts
            MAX_RETRIES: 3,

            /**
            * Helper: Check if a data point represents a user survey
            * @param {Object} point Data point to check
            * @returns {boolean} Whether the point represents a user survey
            */
            isUserSurvey(point) {
                // Check multiple conditions for robustness
                return point && (
                    point.isUserSurvey === true ||
                    point.llmName === "Your Analysis" ||
                    point.metadata?.llmSource?.provider === "Human" ||
                    point.status === 'draft' // Consider drafts as user surveys internally
                );
            },

             /**
             * Fetch scenarios from the API with retry logic
             * @returns {Promise<Array>} Processed scenario data
             */
             async fetchScenarios() {
                 if (this.isProcessing) {
                     console.warn('Already fetching scenarios, request queued');
                     return new Promise(resolve => {
                         const checkInterval = setInterval(() => {
                             if (!this.isProcessing) {
                                 clearInterval(checkInterval);
                                 resolve(this.dataPoints);
                             }
                         }, 100);
                     });
                 }

                 try {
                     this.isProcessing = true;

                     const now = Date.now();
                     if (now - this.lastFetchTime < this.FETCH_COOLDOWN) {
                         await new Promise(resolve => setTimeout(resolve, this.FETCH_COOLDOWN - (now - this.lastFetchTime)));
                     }

                     this.lastFetchTime = Date.now();

                     let retries = 0;
                     let response = null;

                     while (retries <= this.MAX_RETRIES) {
                         try {
                             console.log(`Fetching scenarios (attempt ${retries + 1}/${this.MAX_RETRIES + 1})`);

                             const controller = new AbortController();
                             const timeoutId = setTimeout(() => controller.abort(), 15000); // 15-second timeout

                             response = await fetch('/.netlify/functions/fetchscenarios', {
                                 signal: controller.signal
                             });

                             clearTimeout(timeoutId);

                             if (!response.ok) {
                                 throw new Error(`API response error: ${response.status} ${response.statusText}`);
                             }

                             const data = await response.json();
                             await this.processJsonData(data);

                             // After processing API data, attempt to load user surveys
                             try {
                                 if (await AuthManager.isUserAuthenticated()) {
                                     const userSurveys = await UserSurveyManager.getUserSurveys();
                                     this.integrateUserSurveys(userSurveys);
                                 }
                             } catch (userSurveyError) {
                                 console.warn("Could not load user surveys during initial fetch:", userSurveyError);
                             }

                             return this.dataPoints; // Return combined data
                         } catch (error) {
                             retries++;
                             console.warn(`Fetch attempt ${retries} failed:`, error);

                             if (error.name === 'AbortError') {
                                 console.error('Fetch timeout exceeded');
                             }

                             if (retries <= this.MAX_RETRIES) {
                                 const backoffTime = Math.min(1000 * Math.pow(2, retries), 8000);
                                 await new Promise(resolve => setTimeout(resolve, backoffTime));
                             } else {
                                 throw error; // Final throw after retries
                             }
                         }
                     }
                 } catch (error) {
                     console.error('Error fetching scenarios:', error);
                     await this.processJsonData([]); // Process empty data on error
                     throw error;
                 } finally {
                     this.isProcessing = false;
                 }
             },

            /**
            * Process raw scenario data into structured format
            * @param {Object|Array} data Raw scenario data from API
            */
            async processJsonData(data) {
                console.log("Processing JSON data from API");

                // Reset state BUT preserve existing user surveys if any
                const existingUserSurveys = this.dataPoints.filter(p => this.isUserSurvey(p));
                this.dataPoints = [...existingUserSurveys];
                this.displayPoints = [...existingUserSurveys.filter(p => p.isParent)]; // Keep parent user surveys
                this.scenarioRelationships.clear();

                let scenarios = [];
                try {
                    if (Array.isArray(data)) {
                        scenarios = data;
                    } else if (data && Array.isArray(data.scenarios)) {
                        scenarios = data.scenarios;
                    } else if (data && typeof data === 'object' && data.id) {
                        scenarios = [data]; // Handle single object case
                    }
                } catch (error) {
                    console.error("Error extracting scenarios:", error);
                    scenarios = [];
                }

                console.log(`Found ${scenarios.length} scenarios from API`);
                let flattenedScenarios = [];
                const processedIds = new Set(existingUserSurveys.map(s => s.id)); // Don't re-process existing user surveys

                scenarios.forEach(scenario => {
                     if (scenario && scenario.id && !processedIds.has(scenario.id)) {
                         processedIds.add(scenario.id);
                         flattenedScenarios.push(scenario);
                     } else if (scenario && scenario.scenarios && Array.isArray(scenario.scenarios)) {
                         // Handle nested scenarios if needed
                         scenario.scenarios.forEach(nested => {
                             if (nested && nested.id && !processedIds.has(nested.id)) {
                                 processedIds.add(nested.id);
                                 flattenedScenarios.push(nested);
                             }
                         });
                     }
                 });


                console.log(`Processing ${flattenedScenarios.length} new unique scenarios from API`);

                flattenedScenarios.forEach((scenario, index) => {
                    try {
                        if (!scenario || typeof scenario !== 'object' || !scenario.id) {
                            console.warn(`Invalid API scenario at index ${index}`);
                            return;
                        }

                         // Skip if it looks like a user survey from the API (shouldn't happen ideally)
                         if (scenario.llmName === "Your Analysis" || scenario.metadata?.llmSource?.provider === "Human") {
                            console.log(`Skipping potential user survey from API: ${scenario.id}`);
                            return;
                        }

                        const metadata = scenario.metadata || {};
                        const survey = scenario.survey || {};

                        const point = {
                            id: scenario.id,
                            scenarioTitle: this.validateStringField(metadata.title, 'Untitled Scenario'),
                            scenarioDescription: this.validateStringField(metadata.description, ''),
                            llmName: metadata.llmSource ? this.validateStringField(metadata.llmSource.model, 'Unknown Model') : 'Unknown Model',
                            category: this.validateStringField(metadata.category, 'Uncategorized'),
                            overallCategory: metadata.classification ?
                                this.normalizeCategory(this.validateStringField(metadata.classification.type, 'unknown')) : 'unknown',
                            url: this.validateStringField(metadata.url, ''),
                            dimensions: Array.isArray(survey.dimensions) ? survey.dimensions : [],
                            x: this.validateNumberField(survey.finalPosition?.x, 0),
                            y: this.validateNumberField(survey.finalPosition?.y, 0),
                            z: this.validateNumberField(survey.finalPosition?.z, 0),
                            isParent: scenario.type === 'base',
                            parentId: scenario.parentId || null,
                            relationToBase: metadata.relationToBase || null,
                            deontologyScore: this.validateStringField(survey.deontologyScore, 'N/A'),
                            utilitarianismScore: this.validateStringField(survey.utilitarianismScore, 'N/A'),
                            virtueEthicsScore: this.validateStringField(survey.virtueEthicsScore, 'N/A'),
                            isUserSurvey: false, // Explicitly mark as not user survey
                            status: 'completed' // API data is always completed
                        };

                        this.dataPoints.push(point);
                        if (point.isParent) {
                            this.displayPoints.push(point); // Add parent scenarios from API
                        }

                        // Build relationships (only for non-user surveys)
                        if (!point.isParent && point.parentId) {
                             const parent = this.dataPoints.find(p => p.id === point.parentId && !this.isUserSurvey(p)); // Find non-user parent
                             if (parent) {
                                if (!this.scenarioRelationships.has(parent.scenarioTitle)) {
                                    this.scenarioRelationships.set(parent.scenarioTitle, []);
                                }
                                this.scenarioRelationships.get(parent.scenarioTitle).push({
                                    childId: point.scenarioTitle,
                                    relationshipType: point.relationToBase,
                                    model: point.llmName,
                                    data: point
                                });
                            } else {
                               // console.warn(`Parent scenario not found for API child ${point.id} (parent ID: ${point.parentId})`);
                            }
                        }
                    } catch (error) {
                        console.error(`Error processing API scenario at index ${index}:`, error);
                    }
                });

                console.log(`Processing complete: ${this.dataPoints.length} total data points, ${this.displayPoints.length} display points`);
                await this.updateFilters();
            },

            /**
             * Integrate user surveys into the dataPoints array
             * @param {Array} userSurveys Array of survey objects from UserSurveyManager
             */
             integrateUserSurveys(userSurveys) {
                 if (!userSurveys || userSurveys.length === 0) {
                     return;
                 }
                 console.log(`Integrating ${userSurveys.length} user surveys`);

                 userSurveys.forEach(survey => {
                     try {
                        if (!survey || !survey.id) {
                            console.warn("Skipping invalid user survey:", survey);
                            return;
                        }

                         // Normalize survey data just in case
                        const normalizedSurvey = UserSurveyManager.normalizeUserSurvey(survey);

                         // Check if this survey ID already exists in dataPoints
                        const existingIndex = this.dataPoints.findIndex(p => p.id === normalizedSurvey.id);

                        // Create the data point structure
                         const point = {
                             id: normalizedSurvey.id,
                             scenarioTitle: this.validateStringField(normalizedSurvey.metadata?.title, 'User Analysis'),
                             scenarioDescription: this.validateStringField(normalizedSurvey.metadata?.description, ''),
                             llmName: "Your Analysis", // Standardize name
                             category: this.validateStringField(normalizedSurvey.metadata?.category, 'Uncategorized'),
                             overallCategory: this.normalizeCategory(this.validateStringField(normalizedSurvey.metadata?.classification?.type, 'unknown')),
                             url: this.validateStringField(normalizedSurvey.metadata?.url, ''),
                             dimensions: Array.isArray(normalizedSurvey.survey?.dimensions) ? normalizedSurvey.survey.dimensions : [],
                             x: this.validateNumberField(normalizedSurvey.survey?.finalPosition?.x, 0),
                             y: this.validateNumberField(normalizedSurvey.survey?.finalPosition?.y, 0),
                             z: this.validateNumberField(normalizedSurvey.survey?.finalPosition?.z, 0),
                             isParent: true, // Assume user surveys are main points for now
                             parentId: null,
                             relationToBase: null,
                             deontologyScore: this.validateStringField(normalizedSurvey.survey?.deontologyScore, 'N/A'),
                             utilitarianismScore: this.validateStringField(normalizedSurvey.survey?.utilitarianismScore, 'N/A'),
                             virtueEthicsScore: this.validateStringField(normalizedSurvey.survey?.virtueEthicsScore, 'N/A'),
                             isUserSurvey: true, // Mark explicitly
                             status: normalizedSurvey.status || 'completed' // Use status from survey or default to completed
                         };


                         if (existingIndex !== -1) {
                             // Update existing entry
                             this.dataPoints[existingIndex] = point;
                             // Update displayPoints if it was there
                             const displayIndex = this.displayPoints.findIndex(dp => dp.id === point.id);
                             if (displayIndex !== -1 && point.isParent) {
                                this.displayPoints[displayIndex] = point;
                             } else if (displayIndex === -1 && point.isParent) {
                                 this.displayPoints.push(point); // Add if it became a parent
                             }
                             console.log(`Updated user survey: ${point.id}`);
                         } else {
                             // Add new entry
                             this.dataPoints.push(point);
                             if (point.isParent) {
                                 this.displayPoints.push(point);
                             }
                             console.log(`Added new user survey: ${point.id}`);
                         }
                     } catch (error) {
                         console.error("Error integrating user survey:", survey.id, error);
                     }
                 });

                 // Re-update filters after potentially adding new models/scenarios
                 this.updateFilters();
             },

            /**
            * Update UI filters based on processed data
            */
            async updateFilters() {
                try {
                    // Use displayPoints (parent scenarios + parent user surveys) for filters
                     const pointsForFilters = this.displayPoints;

                    const uniqueScenarios = [...new Set(pointsForFilters.map(p => p.scenarioTitle))].sort();
                    const uniqueModels = [...new Set(this.dataPoints.map(p => p.llmName))].sort(); // Show all models seen
                    const uniqueCategories = [...new Set(pointsForFilters.map(p => p.category))].sort();

                    console.log("Updating filters with:", {
                        scenarios: uniqueScenarios.length,
                        models: uniqueModels.length,
                        categories: uniqueCategories.length
                    });

                    // Update model filter dropdown
                    const modelFilter = document.getElementById('modelFilter');
                    if (modelFilter) {
                         // Preserve selected values
                        const selectedValues = Array.from(modelFilter.selectedOptions).map(opt => opt.value);
                        modelFilter.innerHTML = uniqueModels.map(model =>
                            `<option value="${this.escapeHTML(model)}" ${selectedValues.includes(model) ? 'selected' : ''}>${this.escapeHTML(model)}</option>`
                        ).join('');
                    }

                    // Update scenario filter dropdown
                    const scenarioFilter = document.getElementById('scenarioFilter');
                    if (scenarioFilter) {
                        const selectedValues = Array.from(scenarioFilter.selectedOptions).map(opt => opt.value);
                        scenarioFilter.innerHTML = uniqueScenarios.map(scenario =>
                            `<option value="${this.escapeHTML(scenario)}" ${selectedValues.includes(scenario) ? 'selected' : ''}>${this.escapeHTML(scenario)}</option>`
                        ).join('');
                    }

                    // Update category filter dropdown
                    const categoryFilter = document.getElementById('categoryFilter');
                    if (categoryFilter) {
                         const selectedValues = Array.from(categoryFilter.selectedOptions).map(opt => opt.value);
                        categoryFilter.innerHTML = uniqueCategories.map(category =>
                            `<option value="${this.escapeHTML(category)}" ${selectedValues.includes(category) ? 'selected' : ''}>${this.escapeHTML(category)}</option>`
                        ).join('');
                    }

                    // Update alternate outcomes dropdown (usually cleared unless specific scenario/model selected)
                     // This is handled by VisualizationManager.updateAlternateOutcomesDropdown() usually

                    // Update category badges based on *all* data points
                    const activeOverallCategories = new Set([...new Set(this.dataPoints.map(point =>
                        this.normalizeCategory(point.overallCategory)))]);

                    document.querySelectorAll('.filter-badge').forEach(badge => {
                        const category = badge.dataset.category.toLowerCase();
                         // Show badge if *any* data point has this overall category
                        const exists = activeOverallCategories.has(category);
                        badge.style.display = exists ? 'inline-block' : 'none';
                        // Maintain active state based on VisualizationManager's activeCategories
                         badge.classList.toggle('active', VisualizationManager.activeCategories.has(category));
                         badge.style.opacity = VisualizationManager.activeCategories.has(category) ? '1' : '0.3'; // Reflect active state
                    });
                } catch (error) {
                    console.error("Error updating filters:", error);
                }
            },


            /**
            * Helper: Normalize a category string
            * @param {string} category Category to normalize
            * @returns {string} Normalized category
            */
            normalizeCategory(category) {
                if (typeof category !== 'string') return 'unknown';
                 let normalized = category.toLowerCase().replace(/\s+/g, '_');
                 if (normalized === 'morally-grey') normalized = 'morally_grey'; // Ensure consistency
                 if (normalized === 'world-building') normalized = 'world_building';
                return normalized;
            },

            /**
            * Helper: Validate a string field with fallback
            * @param {*} value Value to validate
            * @param {string} fallback Fallback value
            * @returns {string} Validated string
            */
            validateStringField(value, fallback) {
                return (value && typeof value === 'string') ? value : fallback;
            },

            /**
            * Helper: Validate a number field with fallback
            * @param {*} value Value to validate
            * @param {number} fallback Fallback value
            * @returns {number} Validated number
            */
             validateNumberField(value, fallback) {
                 // Handle MongoDB NumberDouble/Int structures if present
                 if (value && typeof value === 'object') {
                     if (value.$numberDouble !== undefined) {
                         return parseFloat(value.$numberDouble);
                     }
                     if (value.$numberInt !== undefined) {
                         return parseInt(value.$numberInt);
                     }
                 }
                 // Standard check
                 const num = parseFloat(value);
                 return !isNaN(num) ? num : fallback;
             },

            /**
            * Helper: Escape HTML to prevent XSS
            * @param {string} str String to escape
            * @returns {string} Escaped string
            */
            escapeHTML(str) {
                if (!str) return '';
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }
        };

        // UserSurveyManager (with draft saving, scale mapping, validation fixes)
        const UserSurveyManager = {
            // State
            userSurveyData: null,
            isEditMode: false,
            editSurveyId: null,
            scenarioData: null, // Original scenario data if editing/analyzing
            currentTabIndex: 0,
            tabIds: ['ends', 'means', 'character', 'philosophy'],
            isSubmitting: false,
            initialFormState: {}, // For tracking changes
            changedFields: new Set(),
            lastSurveyFetchTime: 0,
            surveyCache: null,
            SURVEY_CACHE_DURATION: 30000, // 30 seconds cache for getUserSurveys
            draftSaveTimeout: null, // For debouncing draft saves

            // Constants
            AUTH_RETRY_LIMIT: 2,
            DATA_SIZE_WARNING: 10 * 1024 * 1024, // 10MB
            DATA_SIZE_LIMIT: 15 * 1024 * 1024,   // 15MB (Auth0 limit is 16MB)
            DRAFT_SAVE_DEBOUNCE: 1500, // ms to wait before saving draft

            /**
            * Initialize survey functionality
            */
            initialize() {
                this.initSurveyControls();
                this.updateTabDisplay();
                this.attachModalListeners();
                console.log('Survey manager initialized');
            },

            /** Helper function to map values between ranges */
            mapValue(value, inputMin, inputMax, outputMin, outputMax) {
                // Handle invalid inputs
                if (inputMin === inputMax) return outputMin; // Avoid division by zero
                value = parseFloat(value);
                if (isNaN(value)) return outputMin; // Default if value is not a number

                // Clamp value to input range
                value = Math.max(inputMin, Math.min(value, inputMax));

                // Perform linear mapping
                const inputRange = inputMax - inputMin;
                const outputRange = outputMax - outputMin;
                return outputMin + ((value - inputMin) / inputRange) * outputRange;
            },


            /**
             * Initialize survey controls with event listeners
             */
            initSurveyControls() {
                const nextBtn = document.querySelector('.next-tab-btn');
                const prevBtn = document.querySelector('.prev-tab-btn');
                const submitBtn = document.querySelector('.submit-survey-btn');
                const saveDraftBtn = document.querySelector('.save-draft-btn'); // Draft button

                if (nextBtn) {
                    nextBtn.addEventListener('click', () => {
                        if (this.currentTabIndex < this.tabIds.length - 1) {
                            // Only validate required score fields for moving next
                            if (this.validateCurrentTab(true)) {
                                this.currentTabIndex++;
                                this.updateTabDisplay();
                                // Optionally save draft on tab change
                                this.saveDraft();
                            } else {
                                this.showValidationError('Please fill in all required score/evaluation fields in this section.');
                            }
                        }
                    });
                }

                if (prevBtn) {
                    prevBtn.addEventListener('click', () => {
                        if (this.currentTabIndex > 0) {
                            this.currentTabIndex--;
                            this.updateTabDisplay();
                             // Optionally save draft on tab change
                            this.saveDraft();
                        }
                    });
                }

                // Save Draft Button Handler
                 if (saveDraftBtn) {
                    saveDraftBtn.addEventListener('click', async () => {
                        if (this.isSubmitting) return; // Prevent saving while submitting
                        this.isSubmitting = true; // Use submitting flag to disable buttons
                        saveDraftBtn.disabled = true;
                        saveDraftBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Saving...';

                        try {
                             if (!await AuthManager.isUserAuthenticated()) {
                                this.showErrorMessage('Please log in to save drafts.');
                                AuthManager.login();
                                return; // Stop if not logged in
                            }
                            await this.saveDraft(true); // Force immediate save
                            this.showSuccessMessage('Draft saved successfully!');
                        } catch (error) {
                            console.error('Error saving draft:', error);
                            this.showErrorMessage(`Failed to save draft: ${error.message}`);
                        } finally {
                             this.isSubmitting = false;
                             saveDraftBtn.disabled = false;
                             saveDraftBtn.textContent = 'Save Draft';
                        }
                    });
                }


                if (submitBtn) {
                    submitBtn.addEventListener('click', async () => {
                        // Full validation before final submit
                        if (!this.validateAllTabs()) {
                             this.showValidationError('Please complete all required fields (*) in all tabs before submitting.');
                             return;
                        }

                        const isAuthenticated = await AuthManager.isUserAuthenticated(true);
                        if (!isAuthenticated) {
                            this.showErrorMessage('Your session has expired. Please log in again to submit your analysis.');
                            setTimeout(() => AuthManager.login(), 2000);
                            return;
                        }

                        if (this.isSubmitting) return;
                        this.isSubmitting = true;

                        submitBtn.disabled = true;
                        submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Submitting...';

                        let surveyData = null;
                        try {
                            console.log('Collecting final survey data...');
                            // Collect data and explicitly set status to 'completed'
                            surveyData = await this.collectSurveyData('completed');
                            console.log('Final survey data collected:', surveyData.id, surveyData.status);

                            if (this.isEditMode && this.editSurveyId) {
                                console.log(`Updating completed survey (ID: ${this.editSurveyId})...`);
                                await this.updateSurvey(this.editSurveyId, surveyData);
                                this.showSuccessMessage('Survey edits submitted successfully!');
                            } else {
                                console.log('Submitting new completed survey...');
                                await this.submitSurvey(surveyData);
                                this.showSuccessMessage('Analysis submitted successfully!');
                            }

                             // Clear draft from localStorage after successful submission
                            const draftKey = await this.getDraftKey();
                            if (draftKey) {
                                localStorage.removeItem(draftKey);
                                console.log("Cleared draft from local storage:", draftKey);
                            }

                            this.resetSurveyForm();
                            $('#surveyModal').modal('hide');
                            // Refresh lists/views
                            await ScenarioDataProcessor.fetchScenarios(); // Re-fetch to include the new/updated survey
                            if (VisualizationManager.updateUserSurveysPreview) {
                                VisualizationManager.updateUserSurveysPreview();
                            }
                             if (VisualizationManager.updateVisualization) {
                                VisualizationManager.updateVisualization();
                            }
                            await this.loadUserSurveys(); // Refresh the full list modal


                        } catch (error) {
                            console.error('Error submitting survey:', error);
                             this.showErrorMessage(`Failed to submit analysis: ${error.message || 'Unknown error'}`);
                             // Consider allowing saving as draft on error?
                        } finally {
                            submitBtn.disabled = false;
                            submitBtn.textContent = 'Submit Analysis';
                            this.isSubmitting = false;
                        }
                    });
                }


                // Add listeners for auto-saving drafts
                document.querySelectorAll('#surveyModal .survey-field').forEach(input => {
                    input.addEventListener('change', () => this.triggerSaveDraft()); // Use change for selects/numbers
                    if (input.tagName.toLowerCase() === 'textarea' || input.type === 'text' || input.type === 'number') {
                        input.addEventListener('input', () => this.triggerSaveDraft()); // Use input for typing
                    }
                     // Also update progress bar and tab completion on change
                    input.addEventListener('change', () => {
                        this.updateProgressBarAndTabs();
                    });
                    input.addEventListener('input', () => { // Update progress faster for typing
                        this.updateProgressBarAndTabs();
                    });
                });


                // Create new survey button (in User Surveys Modal)
                const createNewSurveyBtn = document.getElementById('create-new-survey-btn');
                if (createNewSurveyBtn) {
                    createNewSurveyBtn.addEventListener('click', () => {
                        $('#userSurveysModal').modal('hide');
                        VisualizationManager.handleAnalyzeScenarioClick(); // Reuse existing logic
                    });
                }

                // Scenario search functionality
                const scenarioSearch = document.getElementById('scenario-search');
                if (scenarioSearch) {
                    scenarioSearch.addEventListener('input', () => {
                        this.filterScenariosList(scenarioSearch.value);
                    });
                }
            },

             /** Debounced trigger for saving draft */
            triggerSaveDraft() {
                clearTimeout(this.draftSaveTimeout); // Clear previous timeout
                this.draftSaveTimeout = setTimeout(() => {
                    this.saveDraft(); // Call the actual save function
                }, this.DRAFT_SAVE_DEBOUNCE);
            },

            /** Get the localStorage key for the current draft */
            async getDraftKey() {
                const scenarioId = document.getElementById('scenario-id')?.value;
                if (!scenarioId) return null;

                // Use user ID if logged in, otherwise a generic key (less ideal)
                let userId = 'anonymous';
                 try {
                    if (await AuthManager.isUserAuthenticated()) {
                        const user = await AuthManager.getUser();
                        userId = user?.sub || 'authenticated_user';
                    }
                 } catch (e) { /* ignore auth errors for key generation */ }

                return `draft_survey_${userId}_${scenarioId}`;
            },


             /** Save current survey state as a draft */
            async saveDraft(forceImmediate = false) {
                 if (this.isSubmitting && !forceImmediate) return; // Don't save if final submission is in progress

                const draftKey = await this.getDraftKey();
                if (!draftKey) {
                   // console.warn("Cannot save draft without scenario ID.");
                    return;
                }

                try {
                    // Collect data, explicitly marking as draft
                    const draftData = await this.collectSurveyData('draft');

                    // Save to localStorage
                    localStorage.setItem(draftKey, JSON.stringify(draftData));
                   // console.log("Draft saved to localStorage:", draftKey);

                     // Optionally: Persist draft to backend if needed (more complex)
                     // await this.saveDraftToBackend(draftData);

                } catch (error) {
                     // Ignore collection errors if fields are missing, focus on storing what's there
                    if (error.message.includes('Missing required fields')) {
                         try {
                             const partialData = await this.collectSurveyData('draft', true); // Collect partial data
                             localStorage.setItem(draftKey, JSON.stringify(partialData));
                            // console.log("Partial draft saved to localStorage:", draftKey);
                         } catch (partialError) {
                             console.error("Error saving partial draft:", partialError);
                         }
                    } else {
                        console.error("Error preparing draft data:", error);
                    }
                }
            },

            /** Load draft from localStorage */
            async loadDraft() {
                const draftKey = await this.getDraftKey();
                if (!draftKey) return;

                const savedDraft = localStorage.getItem(draftKey);
                if (savedDraft) {
                    try {
                        const draftData = JSON.parse(savedDraft);
                        console.log("Loading draft from localStorage:", draftKey);

                        // Populate form fields from draftData
                        this.populateFormFromData(draftData);

                         // Show a notification
                        this.showInfoMessage("Loaded previously saved draft.");

                        // Re-validate tabs and progress bar after loading
                        this.updateProgressBarAndTabs();

                    } catch (error) {
                        console.error("Error loading draft:", error);
                        localStorage.removeItem(draftKey); // Remove corrupted draft
                    }
                }
            },

             /** Populate form fields from survey data object */
            populateFormFromData(surveyData) {
                if (!surveyData) return;

                // Populate metadata
                $('#moral-classification').val(surveyData.metadata?.classification?.type || '');
                $('#classification-justification').val(surveyData.metadata?.classification?.justification || '');

                // Populate dimensions and questions
                if (surveyData.survey?.dimensions) {
                     const questionFieldMap = { // Reuse map from collectSurveyData
                        'Societal Needs': 'societal-needs', 'Others Needs': 'others-needs', 'Others Wants': 'others-wants',
                        'Personal Needs': 'personal-needs', 'Personal Wants': 'personal-wants',
                        'Future Self-Sacrifice': 'future-sacrifice', 'Number of Individuals Affected': 'individuals-affected',
                        'Type of Sacrifice': 'sacrifice-type', 'Duration of Sacrifice': 'sacrifice-duration',
                        'Magnitude of Life Impacted': 'life-magnitude', 'Unconscious vs Conscious': 'consciousness',
                        'Present Self-Sacrifice': 'present-sacrifice', 'Habit vs Will Power': 'willpower',
                        'Unintentional vs Intentional': 'intentionality', 'Wills at Play': 'wills',
                        'Deontology': 'deontology', 'Utilitarianism': 'utilitarianism', 'Virtue Ethics': 'virtue-ethics'
                     };

                    surveyData.survey.dimensions.forEach(dim => {
                        (dim.questions || []).forEach(q => {
                            const fieldBase = questionFieldMap[q.question];
                            if (fieldBase) {
                                const scoreField = $(`#${fieldBase}-score`);
                                const justField = $(`#${fieldBase}-justification`);

                                if (scoreField.length) {
                                    scoreField.val(q.score !== undefined ? q.score : '');
                                    scoreField.trigger('input'); // Trigger slider update if exists
                                }
                                if (justField.length) {
                                    justField.val(q.justification || '');
                                }
                            }
                        });
                    });
                }
                 // Trigger change events to update UI elements like progress bar
                $('.survey-field').trigger('change');
            },


            /**
             * Attach modal-related event listeners
             */
            attachModalListeners() {
                // Reset form when survey modal is closed
                $('#surveyModal').on('hidden.bs.modal', () => {
                    this.resetSurveyForm();
                });

                 // Load draft when survey modal is shown
                $('#surveyModal').on('shown.bs.modal', () => {
                    this.loadDraft(); // Attempt to load draft for the current scenario
                     this.updateProgressBarAndTabs(); // Initial check on show
                });

                // My Surveys button
                const mySurveysBtn = document.getElementById('my-surveys-btn');
                if (mySurveysBtn) {
                    mySurveysBtn.addEventListener('click', async () => {
                        const authenticated = await AuthManager.isUserAuthenticated();
                        if (authenticated) {
                            await this.loadUserSurveys(); // Load and display surveys in modal
                            $('#userSurveysModal').modal('show');
                        } else {
                            showLoginPrompt();
                        }
                    });
                }
            },

            /**
             * Update tab display based on current tab index
             */
            updateTabDisplay() {
                try {
                    // Hide all tabs
                    document.querySelectorAll('#surveyModal .tab-pane').forEach(tab => {
                        tab.classList.remove('show', 'active');
                    });

                    // Show current tab
                    const currentTab = document.getElementById(this.tabIds[this.currentTabIndex]);
                    if (currentTab) {
                        currentTab.classList.add('show', 'active');
                    }

                    // Update active tab in nav
                    document.querySelectorAll('#surveyModal .nav-link').forEach(link => {
                        link.classList.remove('active');
                    });
                    const tabLink = document.querySelector(`#${this.tabIds[this.currentTabIndex]}-tab`);
                    if (tabLink) {
                        tabLink.classList.add('active');
                    }

                    // Update buttons
                    const prevBtn = document.querySelector('.prev-tab-btn');
                    const nextBtn = document.querySelector('.next-tab-btn');
                    const submitBtn = document.querySelector('.submit-survey-btn');

                    if (prevBtn) prevBtn.disabled = this.currentTabIndex === 0;

                    if (nextBtn && submitBtn) {
                        if (this.currentTabIndex === this.tabIds.length - 1) {
                            nextBtn.style.display = 'none';
                            submitBtn.style.display = 'inline-block'; // Use inline-block
                        } else {
                            nextBtn.style.display = 'inline-block';
                            submitBtn.style.display = 'none';
                        }
                    }

                    // Update progress bar and tab indicators
                    this.updateProgressBarAndTabs();
                } catch (error) {
                    console.error('Error updating tab display:', error);
                }
            },

            /** Check completion status of a single tab */
            checkTabCompletion(tabId) {
                 const requiredFields = document.querySelectorAll(
                     `#${tabId} input[type="number"]:not([readonly]),
                      #${tabId} select:not([disabled]):not([readonly])`
                 );
                 const totalRequired = requiredFields.length;
                 if (totalRequired === 0) return { completed: 0, total: 0, percentage: 1 }; // Tab has no required fields

                 let completedCount = 0;
                 requiredFields.forEach(field => {
                      // Check if field has a non-empty value
                      if (field.value !== '' && field.value !== null) {
                           // Specific check for select to ensure a valid option is chosen
                           if (field.tagName.toLowerCase() === 'select') {
                                if (field.selectedIndex > 0) { // Assumes first option is placeholder
                                     completedCount++;
                                }
                           } else {
                                completedCount++;
                           }
                      }
                 });

                  // Special case for first tab (metadata) - check classification
                 if (tabId === this.tabIds[0]) {
                      const classificationSelect = document.getElementById('moral-classification');
                      if (!classificationSelect || classificationSelect.value === '') {
                           // If classification is missing, mark tab as incomplete regardless of other fields
                           return { completed: completedCount, total: totalRequired + 1, percentage: completedCount / (totalRequired + 1) };
                      } else {
                           // Add 1 to total and completed if classification is filled
                           return { completed: completedCount + 1, total: totalRequired + 1, percentage: (completedCount + 1) / (totalRequired + 1) };
                      }
                 }


                 const percentage = totalRequired > 0 ? (completedCount / totalRequired) : 1; // 100% if no required fields
                 return { completed: completedCount, total: totalRequired, percentage: percentage };
            },

             /** Update Progress Bar AND Tab Indicators */
            updateProgressBarAndTabs() {
                try {
                    const progressBar = document.getElementById('survey-progress-bar');
                    if (!progressBar) return;

                    let totalCompletionPercentage = 0;
                    let completedTabs = 0;

                    this.tabIds.forEach(tabId => {
                        const completion = this.checkTabCompletion(tabId);
                        totalCompletionPercentage += completion.percentage;

                        // Update Tab Indicator (Requirement 5)
                        const tabLink = document.getElementById(`${tabId}-tab`);
                        const indicator = tabLink?.querySelector('.tab-completion-indicator');
                        if (indicator) {
                            if (completion.percentage === 1) {
                                indicator.innerHTML = '<i class="fas fa-check-circle"></i>';
                                indicator.parentElement.classList.add('tab-complete');
                                indicator.parentElement.classList.remove('tab-incomplete');
                                completedTabs++;
                            } else if (completion.percentage > 0) {
                                 indicator.innerHTML = '<i class="fas fa-circle"></i>'; // Use a simple dot/circle
                                 indicator.parentElement.classList.add('tab-incomplete');
                                 indicator.parentElement.classList.remove('tab-complete');
                            } else {
                                indicator.innerHTML = ''; // Hide indicator if nothing is filled
                                indicator.parentElement.classList.remove('tab-complete', 'tab-incomplete');
                            }
                        }
                    });

                    // Calculate overall progress based on average tab completion (Requirement 6)
                    const overallPercentage = Math.floor((totalCompletionPercentage / this.tabIds.length) * 100);

                    // Update progress bar
                    progressBar.style.width = `${overallPercentage}%`;
                    progressBar.setAttribute('aria-valuenow', overallPercentage);
                    progressBar.textContent = `${overallPercentage}%`;

                    // Update progress bar color
                    if (overallPercentage < 30) {
                        progressBar.className = 'progress-bar bg-danger';
                    } else if (overallPercentage < 100) {
                        progressBar.className = 'progress-bar bg-warning';
                    } else {
                        progressBar.className = 'progress-bar bg-success';
                    }
                } catch (error) {
                    console.error('Error updating progress bar and tabs:', error);
                }
            },


            /**
             * Validate the current tab - NOW checks only required scores/selects (Req 4)
             * @param {boolean} onlyRequired - If true, only checks fields marked required (*)
             * @returns {boolean} Whether the current tab is valid
             */
            validateCurrentTab(onlyRequired = false) { // Default to checking all for potential future use
                try {
                    const currentTabId = this.tabIds[this.currentTabIndex];
                    // Select only score/evaluation fields: number inputs and selects
                    const fieldsToCheck = document.querySelectorAll(
                        `#${currentTabId} input[type="number"]:not([readonly]),
                         #${currentTabId} select:not([disabled]):not([readonly])`
                    );

                    let isValid = true;

                    fieldsToCheck.forEach(field => {
                        // Skip validation if field is hidden or not required (if onlyRequired is true)
                         const label = field.previousElementSibling || field.parentElement.querySelector('label');
                         const isRequired = label && label.querySelector('.text-danger'); // Check for *

                        if (!this.isElementVisible(field) || (onlyRequired && !isRequired)) return;

                        let fieldIsValid = true;
                        if (field.value === '' || field.value === null) {
                            fieldIsValid = false;
                        } else if (field.tagName.toLowerCase() === 'select' && field.selectedIndex <= 0) {
                             // Also check select index, assuming index 0 is the placeholder
                             fieldIsValid = false;
                        } else if (field.type === 'number') {
                            // Additional check for number range validity
                            const value = parseFloat(field.value);
                            const min = parseFloat(field.min);
                            const max = parseFloat(field.max);
                            if ((!isNaN(min) && value < min) || (!isNaN(max) && value > max)) {
                                fieldIsValid = false;
                            }
                        }

                        if (!fieldIsValid) {
                            field.classList.add('is-invalid');
                            isValid = false;
                        } else {
                            field.classList.remove('is-invalid');
                        }
                    });

                     // Special required check for moral classification on the first tab
                     if (currentTabId === this.tabIds[0]) {
                          const moralClassification = document.getElementById('moral-classification');
                          if (moralClassification && (moralClassification.value === '' || moralClassification.selectedIndex <= 0)) {
                               moralClassification.classList.add('is-invalid');
                               isValid = false;
                          } else if (moralClassification) {
                               moralClassification.classList.remove('is-invalid');
                          }
                     }


                    console.log(`Tab ${currentTabId} validation (RequiredOnly: ${onlyRequired}): ${isValid}`);
                    return isValid;
                } catch (error) {
                    console.error('Error validating tab:', error);
                    return true; // Fail open in case of error
                }
            },

            /** Validate all tabs for final submission */
            validateAllTabs() {
                let allValid = true;
                this.tabIds.forEach(tabId => {
                    const tabIndex = this.tabIds.indexOf(tabId);
                    const originalIndex = this.currentTabIndex;
                    this.currentTabIndex = tabIndex; // Temporarily set index for validation context
                    if (!this.validateCurrentTab(true)) { // Use true to only check required
                        allValid = false;
                        // Find the first invalid field and focus it? (Optional UX enhancement)
                    }
                     this.currentTabIndex = originalIndex; // Restore original index
                });
                return allValid;
            },


            // Helper function to check if an element is visible
            isElementVisible(element) {
                if (!element) return false;
                return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
            },

            /**
             * Filter the scenarios list based on search input
             */
            filterScenariosList(searchText) {
                try {
                    const searchLower = searchText.toLowerCase();
                    document.querySelectorAll('#scenarios-body tr').forEach(row => {
                        const title = row.cells[0]?.textContent.toLowerCase() || '';
                        const category = row.cells[1]?.textContent.toLowerCase() || '';
                        row.style.display = (title.includes(searchLower) || category.includes(searchLower)) ? '' : 'none';
                    });
                } catch (error) {
                    console.error('Error filtering scenarios list:', error);
                }
            },

            /**
             * Validate score is within expected range (using the MAPPED ranges)
             */
            validateScoreRange(dimensionId, questionId, score) {
                // Use the ORIGINAL ranges for validation after mapping
                const rangeMap = {
                    'Ends': {
                        'Societal Needs': { min: 0, max: 4 }, 'Others Needs': { min: 0, max: 4 }, 'Others Wants': { min: 0, max: 4 },
                        'Personal Needs': { min: -4, max: 0 }, 'Personal Wants': { min: -4, max: 0 }
                    },
                    'Means': {
                        'Future Self-Sacrifice': { min: -4, max: 0 }, 'Number of Individuals Affected': { min: -6, max: 0 },
                        'Type of Sacrifice': { min: -4, max: 0 }, 'Duration of Sacrifice': { min: -4, max: 0 },
                        'Magnitude of Life Impacted': { min: 0.01, max: 1.2 }
                    },
                    'Character': {
                        'Unconscious vs Conscious': { min: 0, max: 1 }, 'Present Self-Sacrifice': { min: 0, max: 2 },
                        'Habit vs Will Power': { min: 0, max: 4 }, 'Unintentional vs Intentional': { min: 0, max: 1 }
                    }
                 };

                 if (dimensionId === 'PhilosophicalAnalysis' || questionId === 'Wills at Play') return true; // Skip non-numeric or special cases

                 if (!rangeMap[dimensionId] || !rangeMap[dimensionId][questionId]) return true; // Skip if no range defined

                 const numericScore = parseFloat(score);
                 if (isNaN(numericScore)) {
                     throw new Error(`Score for ${questionId} must be a number`);
                 }

                 const range = rangeMap[dimensionId][questionId];
                 if (numericScore < range.min || numericScore > range.max) {
                    // Throw error showing the EXPECTED range, not the input range
                     throw new Error(`Internal score for ${questionId} (${numericScore.toFixed(2)}) is outside the expected calculation range of ${range.min} to ${range.max}. Check mapping logic.`);
                 }
                 return true;
            },

            /**
             * Collect survey data from form
             * @param {string} status - 'draft' or 'completed'
             * @param {boolean} allowPartial - If true, collects even if validation fails
             * @returns {Promise<Object>} Collected survey data
             */
            async collectSurveyData(status = 'draft', allowPartial = false) {
                if (!allowPartial && !this.validateAllTabs()) {
                     throw new Error('Validation failed. Cannot collect complete survey data.');
                }

                try {
                    const isAuthenticated = await AuthManager.isUserAuthenticated();
                    // Allow collecting drafts even if not authenticated? Or force login?
                    // Let's allow anonymous draft collection for now, but submission requires auth.
                    let userId = 'anonymous';
                    if (isAuthenticated) {
                        const user = await AuthManager.getUser();
                        userId = user?.sub || 'authenticated_user';
                    }

                    const scenarioId = document.getElementById('scenario-id')?.value;
                    const scenarioTitle = document.getElementById('scenario-title-display')?.value;
                    const moralClassification = document.getElementById('moral-classification')?.value;

                     // Need scenarioId to generate a unique ID if editing an existing draft
                     let surveyIdToUse = this.editSurveyId || scenarioId || this.generateId();
                     // If adding new based on existing scenario, generate new ID
                     if (!this.isEditMode && scenarioId) surveyIdToUse = this.generateId();

                     // Ensure required fields are present for 'completed' status
                     if (status === 'completed' && (!scenarioId || !scenarioTitle || !moralClassification)) {
                          throw new Error('Missing required fields: scenario ID, title, or classification for completed survey');
                     }


                    const surveyData = {
                        id: surveyIdToUse,
                        status: status, // Set status explicitly
                        type: document.getElementById('scenario-type')?.value || 'base',
                        parentId: document.getElementById('scenario-parent-id')?.value || null,
                         // Core Metadata
                        metadata: {
                            title: scenarioTitle || 'Untitled Analysis',
                            description: document.getElementById('scenario-description-display')?.value || '',
                            category: document.getElementById('scenario-category-display')?.value || 'Uncategorized',
                            llmSource: { model: "Human", version: "1.0", provider: "Human" },
                            classification: {
                                type: moralClassification || 'unknown',
                                justification: document.getElementById('classification-justification')?.value || ''
                            },
                            url: document.getElementById('scenario-url')?.value || ''
                        },
                        // Survey responses
                        survey: {
                            dimensions: [
                                { id: "Ends", axis: "x", label: "Motivation", questions: [
                                    this.processQuestionData('societal-needs'), this.processQuestionData('others-needs'),
                                    this.processQuestionData('others-wants'), this.processQuestionData('personal-needs'),
                                    this.processQuestionData('personal-wants') ] },
                                { id: "Means", axis: "y", label: "Sacrifice", questions: [
                                    this.processQuestionData('future-sacrifice'), this.processQuestionData('individuals-affected'),
                                    this.processQuestionData('sacrifice-type'), this.processQuestionData('sacrifice-duration'),
                                    this.processQuestionData('life-magnitude') ] },
                                { id: "Character", axis: "z", label: "Habit > Will Power", questions: [
                                    this.processQuestionData('consciousness'), this.processQuestionData('present-sacrifice'),
                                    this.processQuestionData('willpower'), this.processQuestionData('intentionality'),
                                    this.processQuestionData('wills', true) ] }, // No score for 'wills'
                                { id: "PhilosophicalAnalysis", axis: null, label: "Philosophical Perspectives", questions: [
                                    this.processQuestionData('deontology'), this.processQuestionData('utilitarianism'),
                                    this.processQuestionData('virtue-ethics') ] }
                            ],
                            finalPosition: this.calculateFinalPosition() // Uses mapped values internally
                        },
                        // Audit/Edit info
                         edits: {
                            editedBy: userId,
                            editDate: new Date().toISOString()
                            // editedFields: this.getEditedFields() // Maybe only include this on update?
                        },
                        created: this.isEditMode ? (this.originalScenarioData?.created || new Date().toISOString()) : new Date().toISOString(),
                        lastModified: new Date().toISOString(),
                        isUserSurvey: true, // Mark explicitly
                        llmName: "Your Analysis" // Standardize
                    };

                     // Validate the structure and scores if collecting a 'completed' survey
                     if (status === 'completed') {
                          this.validateSurveyData(surveyData);
                     }

                    return surveyData;
                } catch (error) {
                    console.error('Error collecting survey data:', error);
                    throw error;
                }
            },

            /**
             * Calculate final x/y/z position using MAPPED values (Req 3)
             * @returns {Object} Position coordinates {x, y, z}
             */
            calculateFinalPosition() {
                try {
                    // Get 0-10 scores from form
                    const ends_SN = parseFloat(document.getElementById('societal-needs-score')?.value) || 0;
                    const ends_ON = parseFloat(document.getElementById('others-needs-score')?.value) || 0;
                    const ends_OW = parseFloat(document.getElementById('others-wants-score')?.value) || 0;
                    const ends_PN = parseFloat(document.getElementById('personal-needs-score')?.value) || 0;
                    const ends_PW = parseFloat(document.getElementById('personal-wants-score')?.value) || 0;

                    const means_FS = parseFloat(document.getElementById('future-sacrifice-score')?.value) || 0;
                    const means_IA = parseFloat(document.getElementById('individuals-affected-score')?.value) || 0;
                    const means_ST = parseFloat(document.getElementById('sacrifice-type-score')?.value) || 0;
                    const means_SD = parseFloat(document.getElementById('sacrifice-duration-score')?.value) || 0;
                    const means_LM = parseFloat(document.getElementById('life-magnitude-score')?.value) || 0;

                    const char_UC = parseFloat(document.getElementById('consciousness-score')?.value) || 0;
                    const char_PS = parseFloat(document.getElementById('present-sacrifice-score')?.value) || 0;
                    const char_HW = parseFloat(document.getElementById('willpower-score')?.value) || 0;
                    const char_UI = parseFloat(document.getElementById('intentionality-score')?.value) || 0;

                    // Map 0-10 scores to their *intended* calculation ranges
                    const map_SN = this.mapValue(ends_SN, 0, 10, 0, 4);
                    const map_ON = this.mapValue(ends_ON, 0, 10, 0, 4);
                    const map_OW = this.mapValue(ends_OW, 0, 10, 0, 4);
                    const map_PN = this.mapValue(ends_PN, 0, 10, -4, 0); // Maps 0-10 -> -4-0
                    const map_PW = this.mapValue(ends_PW, 0, 10, -4, 0); // Maps 0-10 -> -4-0

                    const map_FS = this.mapValue(means_FS, 0, 10, -4, 0); // Maps 0-10 -> -4-0
                    const map_IA = this.mapValue(means_IA, 0, 10, -6, 0); // Maps 0-10 -> -6-0
                    const map_ST = this.mapValue(means_ST, 0, 10, -4, 0); // Maps 0-10 -> -4-0
                    const map_SD = this.mapValue(means_SD, 0, 10, -4, 0); // Maps 0-10 -> -4-0
                    const map_LM = this.mapValue(means_LM, 0, 10, 0.01, 1.2); // Maps 0-10 -> 0.01-1.2

                    const map_UC = this.mapValue(char_UC, 0, 10, 0, 1);
                    const map_PS = this.mapValue(char_PS, 0, 10, 0, 2);
                    const map_HW = this.mapValue(char_HW, 0, 10, 0, 4);
                    const map_UI = this.mapValue(char_UI, 0, 10, 0, 1);

                    // Calculate final X, Y, Z using the MAPPED values
                    const x = map_SN + map_ON + map_OW + map_PN + map_PW; // map_PN/PW are already negative/zero
                    // Y calculation: Sum negative scores, multiply by -1, then multiply by life magnitude
                    const y = ((map_FS + map_IA + map_ST + map_SD) * -1) * map_LM;
                    const z = map_UC + map_PS + map_HW + map_UI;

                    return {
                        x: parseFloat(x.toFixed(2)),
                        y: parseFloat(y.toFixed(2)),
                        z: parseFloat(z.toFixed(2))
                    };
                } catch (error) {
                    console.error('Error calculating final position:', error);
                    return { x: 0, y: 0, z: 0 };
                }
            },


            // ... (rest of UserSurveyManager methods like delete, submit, update, loadUserSurveys, etc.)
            // Make sure loadUserSurveys handles the 'status' field for display

             /**
             * Load user surveys into the "My Surveys" modal
             */
            async loadUserSurveys() {
                const surveysBody = document.getElementById('user-surveys-body');
                if (!surveysBody) return;
                surveysBody.innerHTML = `<tr><td colspan="5" class="text-center">Loading your analyses...</td></tr>`;

                try {
                    const userSurveys = await this.getUserSurveys(); // This already uses cache/fetch logic

                    if (!userSurveys || userSurveys.length === 0) {
                        surveysBody.innerHTML = `<tr><td colspan="5" class="text-center">No analyses submitted yet.</td></tr>`;
                        return;
                    }

                     // Sort by last modified date, newest first
                     userSurveys.sort((a, b) => {
                        const dateA = new Date(a.lastModified || a.created || 0);
                        const dateB = new Date(b.lastModified || b.created || 0);
                        return dateB - dateA;
                     });


                    const rows = userSurveys.map(survey => {
                        const title = ScenarioDataProcessor.escapeHTML(survey.metadata?.title || 'Untitled');
                        const category = ScenarioDataProcessor.escapeHTML(survey.metadata?.category || 'N/A');
                        const date = new Date(survey.lastModified || survey.created || Date.now()).toLocaleDateString();
                        const status = survey.status || 'completed'; // Default to completed if missing
                        const statusBadge = status === 'draft'
                             ? '<span class="badge badge-secondary">Draft</span>'
                             : '<span class="badge badge-success">Completed</span>';
                         const surveyId = ScenarioDataProcessor.escapeHTML(survey.id); // Ensure ID is escaped

                        return `
                            <tr>
                                <td>${title}</td>
                                <td>${category}</td>
                                <td>${date}</td>
                                <td>${statusBadge}</td>
                                <td>
                                    <button class="btn btn-sm btn-info view-survey-btn" data-survey-id="${surveyId}">View</button>
                                    <button class="btn btn-sm btn-primary edit-survey-btn" data-survey-id="${surveyId}">Edit</button>
                                    <button class="btn btn-sm btn-danger delete-survey-btn" data-survey-id="${surveyId}">Delete</button>
                                </td>
                            </tr>
                        `;
                    }).join('');

                    surveysBody.innerHTML = rows;

                    // Add event listeners using event delegation for efficiency
                     surveysBody.addEventListener('click', async (event) => {
                         const target = event.target;
                         const surveyId = target.getAttribute('data-survey-id');
                         if (!surveyId) return;

                         if (target.classList.contains('view-survey-btn')) {
                              console.log('View button clicked for survey:', surveyId);
                              // Ensure VisualizationManager is accessible
                              if (typeof VisualizationManager !== 'undefined' && VisualizationManager.viewUserSurvey) {
                                 await VisualizationManager.viewUserSurvey(surveyId);
                                 $('#userSurveysModal').modal('hide'); // Close modal after viewing
                              } else {
                                 console.error("VisualizationManager or viewUserSurvey method not found.");
                              }
                         } else if (target.classList.contains('edit-survey-btn')) {
                              console.log('Edit button clicked for survey:', surveyId);
                              await this.editSurvey(surveyId);
                         } else if (target.classList.contains('delete-survey-btn')) {
                              console.log('Delete button clicked for survey:', surveyId);
                              if (confirm('Are you sure you want to delete this analysis? This action cannot be undone.')) {
                                   await this.deleteSurvey(surveyId);
                                   // The list will refresh inside deleteSurvey -> loadUserSurveys
                              }
                         }
                     });


                } catch (error) {
                    console.error('Error loading user surveys table:', error);
                    surveysBody.innerHTML = `<tr><td colspan="5" class="text-center text-danger">Error loading analyses: ${error.message}</td></tr>`;
                }
            },

             /**
             * Prepare and open the survey modal for editing an existing survey
             * @param {string} surveyId - The ID of the survey to edit
             */
             async editSurvey(surveyId) {
                try {
                    const surveyToEdit = (await this.getUserSurveys()).find(s => s.id === surveyId);
                    if (!surveyToEdit) {
                        this.showErrorMessage('Survey not found.');
                        return;
                    }

                    // Close the list modal first
                    $('#userSurveysModal').modal('hide');

                    // Reset form and set edit mode
                    this.resetSurveyForm();
                    this.isEditMode = true;
                    this.editSurveyId = surveyId;
                     this.originalScenarioData = { ...surveyToEdit }; // Store original for comparison or created date

                    // Populate the form with the survey data
                     // Need to populate the readonly fields too
                     $('#scenario-id').val(surveyToEdit.id);
                     $('#scenario-title-display').val(surveyToEdit.metadata?.title || '');
                     $('#scenario-description-display').val(surveyToEdit.metadata?.description || '');
                     $('#scenario-category-display').val(surveyToEdit.metadata?.category || '');
                     $('#scenario-url').val(surveyToEdit.metadata?.url || '');
                     $('#scenario-type').val(surveyToEdit.type || 'base');
                     $('#scenario-parent-id').val(surveyToEdit.parentId || '');
                     $('#survey-status').val(surveyToEdit.status || 'draft'); // Load status

                     // Populate the editable fields
                     this.populateFormFromData(surveyToEdit);

                    // Update modal title
                    $('#surveyModalLabel').text(`Edit Analysis: ${surveyToEdit.metadata?.title || 'Untitled'}`);

                    // Enhance UI (sliders, etc.)
                    this.enhanceSurveyUI();
                     // Remove default "edit" checkboxes if they exist from base functionality
                    this.removeEditCheckboxes();
                    // Initialize change tracking for edit mode
                    this.initializeChangeTracking();


                    // Show the modal
                    // Use setTimeout to ensure modal is fully hidden before showing again
                    setTimeout(() => {
                        $('#surveyModal').modal('show');
                         this.updateProgressBarAndTabs(); // Update progress after loading data
                    }, 500); // Delay might need adjustment

                } catch (error) {
                    console.error('Error preparing survey for edit:', error);
                    this.showErrorMessage(`Error loading survey for editing: ${error.message}`);
                }
            },


            // Make sure placeholders exist if called before full definition
            showValidationError(message = 'Please complete all required fields (*).') {
                console.warn('Validation Error:', message);
                alert(message);
            },
            showSuccessMessage(message) {
                console.log('Success:', message);
                // Use a more subtle notification later if desired
                alert(message);
            },
            showErrorMessage(message) {
                console.error('Error:', message);
                alert(message);
            },
             showInfoMessage(message) {
                console.info('Info:', message);
                // Add a temporary, non-blocking notification element to the modal
                 const infoDiv = $('<div class="alert alert-info alert-dismissible fade show" role="alert" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 1051;">' + message + '<button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">&times;</span></button></div>');
                 $('#surveyModal .modal-body').prepend(infoDiv);
                 // Auto-dismiss after a few seconds
                 setTimeout(() => { infoDiv.alert('close'); }, 3000);
            },

             // --- Include previous getUserSurveys, submitSurvey, updateSurvey, deleteSurvey, performUserDataOperation etc. ---
             // Ensure submitSurvey and updateSurvey call saveToMongoDB AND performUserDataOperation
             // Ensure deleteSurvey calls performUserDataOperation('delete', ...)

             async getUserSurveys() {
                 try {
                     const now = Date.now();
                     if (this.surveyCache && now - this.lastSurveyFetchTime < this.SURVEY_CACHE_DURATION) {
                         return this.surveyCache;
                     }
                     if (now - this.lastSurveyFetchTime < 2000) {
                         await new Promise(resolve => setTimeout(resolve, 2000));
                     }
                     const user = await AuthManager.getUser();
                     if (!user || !user.sub) throw new Error('User not authenticated or missing ID');
                     const token = await AuthManager.getToken({ useAudience: true }); // Ensure audience for Management API

                     const controller = new AbortController();
                     const timeoutId = setTimeout(() => controller.abort(), 15000);
                     this.lastSurveyFetchTime = now;

                     try {
                          const response = await fetch(`https://dev-10xzf0prvka6p40y.us.auth0.com/api/v2/users/${user.sub}`, {
                              headers: { 'Authorization': `Bearer ${token}` },
                              signal: controller.signal
                          });
                          clearTimeout(timeoutId);

                          if (response.status === 429) throw new Error('Auth0 rate limit exceeded.');
                          if (!response.ok) throw new Error(`Failed to fetch user data: ${response.status}`);

                          const userData = await response.json();
                          const surveys = userData.user_metadata?.surveys || [];
                          const normalizedSurveys = surveys.map(survey => this.normalizeUserSurvey(survey));

                          this.surveyCache = normalizedSurveys; // Update cache
                          localStorage.setItem('userSurveys', JSON.stringify(normalizedSurveys)); // Also cache locally

                          return normalizedSurveys;
                     } catch (fetchError) {
                          clearTimeout(timeoutId);
                          throw fetchError;
                     }
                 } catch (error) {
                     console.error('Error fetching user surveys:', error);
                     // Fallback to local storage cache if API fails
                     try {
                         const localSurveys = localStorage.getItem('userSurveys');
                         if (localSurveys) {
                             console.warn("Using locally cached surveys due to fetch error.");
                             return JSON.parse(localSurveys);
                         }
                     } catch (localError) { /* ignore */ }

                     if (error.message.includes('auth') || error.message.includes('token')) AuthManager.login();
                     return []; // Return empty array on error
                 }
             },

             async submitSurvey(surveyData) {
                try {
                    surveyData.isUserSurvey = true;
                    surveyData.llmName = "Your Analysis";
                    surveyData.status = 'completed'; // Ensure status is completed

                    if (!await AuthManager.isUserAuthenticated(true)) throw new Error('Authentication required.');

                    // 1. Save to MongoDB (Primary persistent storage)
                    await this.saveToMongoDB(surveyData);

                     // 2. Update local cache & localStorage
                     this.updateLocalSurveyCache(surveyData);

                    // 3. Attempt to save to Auth0 (Secondary, might fail on rate limits)
                    try {
                        await this.performUserDataOperation('add', surveyData);
                    } catch (auth0Error) {
                        console.warn('Auth0 metadata save failed, but MongoDB save succeeded:', auth0Error);
                        // Proceed even if Auth0 fails, as MongoDB is primary
                    }

                    return { success: true, data: surveyData };
                } catch (error) {
                    console.error('Error in submitSurvey:', error);
                    throw error;
                }
            },

            async updateSurvey(surveyId, updatedSurveyData) {
                try {
                     updatedSurveyData.isUserSurvey = true;
                     updatedSurveyData.llmName = "Your Analysis";
                     // Keep status from original if editing draft, or set to completed? Let's assume update implies completion unless specified.
                     updatedSurveyData.status = updatedSurveyData.status || 'completed';

                     if (!await AuthManager.isUserAuthenticated(true)) throw new Error('Authentication required.');

                     // 1. Save to MongoDB
                     await this.saveToMongoDB(updatedSurveyData);

                     // 2. Update local cache & localStorage
                     this.updateLocalSurveyCache(updatedSurveyData);

                     // 3. Attempt Auth0 update
                     try {
                          await this.performUserDataOperation('update', updatedSurveyData, surveyId);
                     } catch (auth0Error) {
                          console.warn('Auth0 metadata update failed, MongoDB succeeded:', auth0Error);
                     }

                    return { success: true, data: updatedSurveyData };
                } catch (error) {
                    console.error('Error in updateSurvey:', error);
                    throw error;
                }
            },

             async deleteSurvey(surveyId) {
                 try {
                     if (!await AuthManager.isUserAuthenticated(true)) throw new Error('Authentication required.');

                     // 1. Delete from MongoDB (or mark as deleted) - NEED deleteSurvey function
                     await this.deleteFromMongoDB(surveyId); // Assuming this function exists/is created

                     // 2. Remove from local cache & localStorage
                     this.removeLocalSurveyCache(surveyId);

                     // 3. Attempt Auth0 delete
                     try {
                         await this.performUserDataOperation('delete', null, surveyId);
                     } catch (auth0Error) {
                         console.warn('Auth0 metadata delete failed, MongoDB succeeded:', auth0Error);
                     }

                     this.showSuccessMessage('Analysis deleted.');
                     await this.loadUserSurveys(); // Refresh list in modal
                     await ScenarioDataProcessor.fetchScenarios(); // Re-fetch data to remove from cube etc.
                      if (VisualizationManager.updateVisualization) {
                          VisualizationManager.updateVisualization();
                      }

                     return { success: true };
                 } catch (error) {
                     console.error('Error deleting survey:', error);
                     this.showErrorMessage(`Failed to delete analysis: ${error.message}`);
                     throw error;
                 }
             },


             // Helper to update local cache and localStorage
             updateLocalSurveyCache(surveyData) {
                 try {
                     const normalizedSurvey = this.normalizeUserSurvey(surveyData);
                     // Update in-memory cache
                     if (this.surveyCache) {
                         const index = this.surveyCache.findIndex(s => s.id === normalizedSurvey.id);
                         if (index >= 0) this.surveyCache[index] = normalizedSurvey;
                         else this.surveyCache.push(normalizedSurvey);
                     } else {
                         this.surveyCache = [normalizedSurvey];
                     }
                     // Update localStorage
                     const localSurveys = JSON.parse(localStorage.getItem('userSurveys') || '[]');
                     const localIndex = localSurveys.findIndex(s => s.id === normalizedSurvey.id);
                     if (localIndex >= 0) localSurveys[localIndex] = normalizedSurvey;
                     else localSurveys.push(normalizedSurvey);
                     localStorage.setItem('userSurveys', JSON.stringify(localSurveys));
                 } catch (e) { console.warn("Failed to update local survey cache", e); }
             },

              // Helper to remove from local cache and localStorage
             removeLocalSurveyCache(surveyId) {
                 try {
                     // Remove from in-memory cache
                     if (this.surveyCache) {
                         this.surveyCache = this.surveyCache.filter(s => s.id !== surveyId);
                     }
                     // Remove from localStorage
                     let localSurveys = JSON.parse(localStorage.getItem('userSurveys') || '[]');
                     localSurveys = localSurveys.filter(s => s.id !== surveyId);
                     localStorage.setItem('userSurveys', JSON.stringify(localSurveys));
                 } catch (e) { console.warn("Failed to remove from local survey cache", e); }
             },

            async performUserDataOperation(operation, surveyData = null, surveyId = null) {
                 // ... (Previous robust implementation including validation, size checks, fetch/patch logic)
                let token = null; let response = null;
                 try {
                    if (!await this.checkAuthentication()) throw new Error('User is not authenticated');
                    const user = await AuthManager.getUser();
                    if (!user || !user.sub) throw new Error('User profile is incomplete');
                    token = await AuthManager.getToken({ useAudience: true }); // Ensure audience

                    const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 15000);
                    try {
                        response = await fetch(`https://dev-10xzf0prvka6p40y.us.auth0.com/api/v2/users/${user.sub}`, { headers: { 'Authorization': `Bearer ${token}` }, signal: controller.signal });
                        clearTimeout(timeoutId);
                        if (!response.ok) throw new Error(`Failed to fetch user data: ${response.status}`);
                        const userData = await response.json(); const existingSurveys = userData.user_metadata?.surveys || [];
                        let updatedSurveys; let changedData;

                         switch (operation) {
                            case 'add':
                                if (!surveyData) throw new Error('Data required for add');
                                this.validateSurveyData(surveyData); // Use internal validation
                                const newSurvey = { ...surveyData, created: new Date().toISOString(), lastModified: new Date().toISOString(), userId: user.sub };
                                updatedSurveys = [...existingSurveys, newSurvey];
                                changedData = newSurvey;
                                break;
                            case 'update':
                                if (!surveyData || !surveyId) throw new Error('Data and ID required for update');
                                const surveyIndex = existingSurveys.findIndex(s => s.id === surveyId);
                                if (surveyIndex === -1) throw new Error(`Survey ID ${surveyId} not found`);
                                this.validateSurveyData(surveyData);
                                updatedSurveys = [...existingSurveys];
                                updatedSurveys[surveyIndex] = { ...surveyData, lastModified: new Date().toISOString(), userId: user.sub }; // Ensure userId persists
                                changedData = updatedSurveys[surveyIndex];
                                break;
                            case 'delete':
                                if (!surveyId) throw new Error('ID required for delete');
                                const surveyToDeleteIndex = existingSurveys.findIndex(s => s.id === surveyId);
                                if (surveyToDeleteIndex === -1) throw new Error(`Survey ID ${surveyId} not found`);
                                updatedSurveys = existingSurveys.filter(s => s.id !== surveyId);
                                changedData = existingSurveys[surveyToDeleteIndex]; // Data that was deleted
                                break;
                            default: throw new Error(`Unknown operation: ${operation}`);
                        }

                        const updatedMetadata = { ...userData.user_metadata, surveys: updatedSurveys };
                        const metadataSize = new TextEncoder().encode(JSON.stringify(updatedMetadata)).length;
                        if (metadataSize > this.DATA_SIZE_LIMIT) throw new Error('Data too large to save.');
                        if (metadataSize > this.DATA_SIZE_WARNING) console.warn(`Metadata size (${metadataSize} bytes) approaching limit.`);

                        const updateController = new AbortController(); const updateTimeoutId = setTimeout(() => updateController.abort(), 15000);
                        try {
                            const updateResponse = await fetch(`https://dev-10xzf0prvka6p40y.us.auth0.com/api/v2/users/${user.sub}`, {
                                method: 'PATCH', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                                body: JSON.stringify({ user_metadata: updatedMetadata }), signal: updateController.signal
                            });
                            clearTimeout(updateTimeoutId);
                            if (!updateResponse.ok) throw new Error(`Failed to update user data: ${updateResponse.status}`);
                            return { success: true, operation, data: changedData, userData: await updateResponse.json() };
                        } catch (updateError) { clearTimeout(updateTimeoutId); throw updateError; }
                    } catch (fetchError) { clearTimeout(timeoutId); throw fetchError; }
                 } catch (error) { console.error(`Error in ${operation} operation:`, error); throw new Error(`Failed to ${operation} survey: ${error.message}`); }
            },
            // Need saveToMongoDB and potentially deleteFromMongoDB using Netlify functions
             async saveToMongoDB(surveyData) {
                 try {
                     const token = await AuthManager.getToken({ useAudience: true }); // Ensure audience
                     const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 20000);
                     try {
                          const response = await fetch('/.netlify/functions/saveSurvey', {
                              method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                              body: JSON.stringify({ survey: surveyData, timestamp: new Date().toISOString() }), signal: controller.signal
                          });
                          clearTimeout(timeoutId);
                          if (!response.ok) {
                              const errorData = await response.json().catch(() => ({ message: `HTTP error ${response.status}` }));
                              throw new Error(`Failed to save to DB: ${errorData.message || response.statusText}`);
                          }
                          return await response.json();
                     } catch (fetchError) { clearTimeout(timeoutId); throw fetchError; }
                 } catch (error) { console.error('Error saving survey to MongoDB:', error); throw error; }
             },

             async deleteFromMongoDB(surveyId) {
                try {
                     const token = await AuthManager.getToken({ useAudience: true });
                     const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 15000);
                     try {
                          // Assuming your Netlify function handles DELETE requests at the same endpoint or similar
                          const response = await fetch('/.netlify/functions/saveSurvey', { // Adjust endpoint if needed
                              method: 'DELETE', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                              body: JSON.stringify({ surveyId: surveyId }), signal: controller.signal
                          });
                          clearTimeout(timeoutId);
                          if (!response.ok) {
                              const errorData = await response.json().catch(() => ({ message: `HTTP error ${response.status}` }));
                              throw new Error(`Failed to delete from DB: ${errorData.message || response.statusText}`);
                          }
                          return await response.json();
                     } catch (fetchError) { clearTimeout(timeoutId); throw fetchError; }
                } catch (error) { console.error('Error deleting survey from MongoDB:', error); throw error; }
            },
             // Need normalizeUserSurvey from previous steps
              normalizeUserSurvey(survey) {
                 if (!survey) return null;
                 try {
                    const normalized = { ...survey };
                    normalized.isUserSurvey = true;
                    normalized.llmName = "Your Analysis";
                    if (normalized._id && !normalized.id) normalized.id = normalized._id.$oid || normalized._id; // Handle Mongo _id
                    if (!normalized.survey) normalized.survey = {};
                    if (!normalized.survey.finalPosition) normalized.survey.finalPosition = { x: 0, y: 0, z: 0 };
                    else { // Ensure numeric values
                        const pos = normalized.survey.finalPosition;
                        normalized.survey.finalPosition = {
                            x: this.validateNumberField(pos.x, 0),
                            y: this.validateNumberField(pos.y, 0),
                            z: this.validateNumberField(pos.z, 0)
                        };
                    }
                    if (!normalized.metadata) normalized.metadata = { title: 'Untitled Survey', category: 'Uncategorized', classification: { type: 'unknown' } };
                    if (!normalized.created) normalized.created = new Date().toISOString();
                    if (!normalized.lastModified) normalized.lastModified = new Date().toISOString();
                    if (!normalized.status) normalized.status = 'completed'; // Default status

                    // Normalize dimension/question scores if needed (e.g., from MongoDB types)
                     if (normalized.survey.dimensions && Array.isArray(normalized.survey.dimensions)) {
                        normalized.survey.dimensions = normalized.survey.dimensions.map(dim => {
                            if (dim.questions && Array.isArray(dim.questions)) {
                                dim.questions = dim.questions.map(q => {
                                     // Exclude non-numeric questions like 'Wills at Play' or philosophical ones
                                     if (q.question !== 'Wills at Play' && dim.id !== 'PhilosophicalAnalysis') {
                                         q.score = this.validateNumberField(q.score, 0); // Ensure score is a number
                                     }
                                     return q;
                                });
                            }
                            return dim;
                        });
                     }

                    return normalized;
                 } catch (error) { console.error('Error normalizing survey:', error); return survey; }
             },

             // Need validateSurveyData from previous steps
             validateSurveyData(surveyData) {
                if (!surveyData.id || !surveyData.metadata || !surveyData.survey) throw new Error('Missing required survey properties');
                if (!surveyData.metadata.title) throw new Error('Title required');
                if (!surveyData.metadata.classification?.type) throw new Error('Classification required');
                 const validClass = ['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building'];
                if (!validClass.includes(surveyData.metadata.classification.type.toLowerCase())) throw new Error('Invalid classification');
                if (!Array.isArray(surveyData.survey.dimensions) || surveyData.survey.dimensions.length === 0) throw new Error('Dimensions missing');

                 const expectedDims = { 'Ends': 5, 'Means': 5, 'Character': 5, 'PhilosophicalAnalysis': 3 };
                 for (const [dimName, qCount] of Object.entries(expectedDims)) {
                    const dim = surveyData.survey.dimensions.find(d => d.id === dimName);
                    if (!dim || !Array.isArray(dim.questions) || dim.questions.length < qCount) throw new Error(`Dimension "${dimName}" missing or incomplete questions`);
                    // Check scores/justifications within each question (simplified check here)
                     dim.questions.forEach(q => {
                          // Skip score validation for Wills/Philosophy
                          if (q.question !== 'Wills at Play' && dim.id !== 'PhilosophicalAnalysis') {
                               if (q.score === undefined || q.score === null || (typeof q.score === 'number' && isNaN(q.score))) {
                                    // Check if this field is actually required before throwing error
                                    // For simplicity now, assume all score fields ARE required
                                     throw new Error(`Question "${q.question}" requires a valid score.`);
                               }
                               // Internal range validation happens during calculation/collection, focus on presence here
                          } else if (dim.id === 'PhilosophicalAnalysis') {
                               if (!q.score || q.score.trim() === '') throw new Error(`Question "${q.question}" requires an evaluation.`);
                          }
                           // Justification is optional, no check needed here based on Req 4
                     });
                }
                 const pos = surveyData.survey.finalPosition;
                if (!pos || typeof pos.x !== 'number' || typeof pos.y !== 'number' || typeof pos.z !== 'number') throw new Error('Invalid final position');
                return true;
             },
            initializeChangeTracking() { /* as defined before */ },
            updateSubmitButton() { /* as defined before */ },
            getEditedFields() { /* as defined before */ },
            removeEditCheckboxes() { /* as defined before */ },
            ensureFormFieldsEditable() { /* as defined before */ },
            enhanceSurveyUI() { /* as defined before */ },
            generateId() { return `survey_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`; },
            processQuestionData(questionId, noScore = false) { /* as defined before */ },
            resetSurveyForm() { /* as defined before */ }

        };

        // VisualizationManager (with draft exclusion)
        const VisualizationManager = {
            // ... (existing state: selectedScenarios, models, etc.)
            selectedComparison: [], // Keep track of cards selected for detail view
            activeCategories: new Set(['evil', 'virtue', 'vice', 'sin', 'morally_grey', 'world_building']),
            currentMediaUrl: "",
            isUpdatingVisuals: false,
            scenarioColorMapping: {},
            BORDER_COLORS: ["purple", "blue", "black", "pink", "dark green", "orange", "teal", "brown"],
            MAX_SELECTIONS: 4,
            MAX_COMPARISON: 2,


            initialize() {
                this.attachFilterListeners();
                this.attachComparisonCardHandlers(); // Ensure this is called
                this.initializeMediaControls();
                 console.log("Visualization manager initialized");

                 // Attach listener for analyze button
                 const analyzeBtn = document.getElementById('analyze-scenario-btn');
                 if (analyzeBtn) {
                     analyzeBtn.addEventListener('click', () => this.handleAnalyzeScenarioClick());
                 }
            },

            // ... (attachFilterListeners, handle Filters, resetFilters, clearAllFilters, updateSelectionUI, updateAlternate*, etc. as before)
             attachFilterListeners() {
                $('#modelFilter').on('change', (e) => this.handleModelFilterChange(e));
                $('#scenarioFilter').on('change', (e) => this.handleScenarioFilterChange(e));
                $('#categoryFilter').on('change', (e) => this.handleCategoryFilterChange(e));
                $('#alternateOutcomes').on('change', (e) => this.handleAlternateOutcomesChange(e));
                $('.filter-badges').on('click', '.filter-badge', (e) => this.handleCategoryBadgeClick(e));
                $('#clearFilters').on('click', () => this.clearAllFilters());
                // Delegated handler for read more links inside #overview
                $('#overview').on('click', '.read-more', (e) => this.handleReadMoreClick(e));
                 // Delegated handler for comparison card clicks
                 $('#overview').on('click', '.comparison-card', (e) => this.comparisonCardHandler(e));

                 $('#login-to-analyze').on('click', () => { AuthManager.login(); });
            },
            handleModelFilterChange(e) { /* ... as before ... */ this.updateVisualization(); },
            handleScenarioFilterChange(e) { /* ... as before ... */ this.updateAvailableModels(); this.updateVisualization(); },
            handleCategoryFilterChange(e) { /* ... as before ... */ this.updateVisualization(); },
            handleAlternateOutcomesChange(e) { /* ... as before ... */ this.updateAlternateVisualization(); },
            handleCategoryBadgeClick(e) { /* ... as before ... */ this.updateVisualization(); },
            handleReadMoreClick(e) { /* ... as before ... */ },
            resetFilters(filters) { /* ... as before ... */ },
            clearAllFilters() { /* ... as before ... */ this.updateVisualization(); }, // Ensure update happens
            updateSelectionUI(dropdown, selectedValues) { /* ... as before ... */ },
            updateAlternateOutcomesDropdown() { /* ... as before ... */ },
            updateAlternateVisualization() { /* ... as before ... */ },
            updateAvailableModels() { /* ... as before ... */ },
             handleAnalyzeScenarioClick: async function() { /* ... as before ... */ },
             loadScenariosForAnalysis: async function() { /* ... as before ... */ },
             selectScenarioForAnalysis: function(scenarioId, useModelAnswers = false) { /* ... as before ... */ },
             showModelSelectionModal: function(scenarioId, scenarioTitle) { /* ... as before ... */ },


            /**
             * Master update visualization function.
             */
            updateVisualization() {
                if (this.isUpdatingVisuals) return;
                this.isUpdatingVisuals = true;
                try {
                     // Start with all data points (API + integrated user surveys)
                    let allPoints = [...ScenarioDataProcessor.dataPoints];

                     // Filter out DRAFT surveys for the main plot (Requirement 2)
                     let pointsToPlot = allPoints.filter(point => point.status !== 'draft');

                    // Apply other filters (Categories, Scenarios, Models) to pointsToPlot
                     if (this.activeCategories.size !== 6) {
                        pointsToPlot = pointsToPlot.filter(point =>
                            this.activeCategories.has(ScenarioDataProcessor.normalizeCategory(point.overallCategory))
                        );
                     }
                    if (this.selectedCategories.length > 0) {
                        pointsToPlot = pointsToPlot.filter(point =>
                            this.selectedCategories.includes(point.category)
                        );
                    }
                    if (this.selectedScenarios.length > 0) {
                        pointsToPlot = pointsToPlot.filter(point =>
                            this.selectedScenarios.includes(point.scenarioTitle)
                        );
                    }
                    if (this.selectedModels.length > 0) {
                        pointsToPlot = pointsToPlot.filter(point =>
                            this.selectedModels.includes(point.llmName)
                        );
                    }
                     // Handle alternate outcome selection display logic (if applicable)
                     if (this.selectedScenarios.length === 1 && this.selectedModels.length === 1 && this.selectedAlternateOutcomes.length > 0) {
                         // Find the parent point within the *already filtered* pointsToPlot
                         const parentScenarioTitle = this.selectedScenarios[0];
                         const selModel = this.selectedModels[0];
                         const parentPoint = pointsToPlot.find(p =>
                             p.scenarioTitle === parentScenarioTitle && p.llmName === selModel && p.isParent
                         );

                         if (parentPoint) {
                             let alternatePoints = [];
                             // Find alternates in the *original* allPoints data
                             const rels = ScenarioDataProcessor.scenarioRelationships.get(parentScenarioTitle) || [];
                             alternatePoints = rels
                                 .filter(child => child.model === selModel && this.selectedAlternateOutcomes.includes(child.childId))
                                 .map(child => allPoints.find(p => p.id === child.data.id)) // Get full point data
                                 .filter(Boolean); // Remove undefined if any weren't found

                              // Show only the parent and selected alternates
                             pointsToPlot = [parentPoint, ...alternatePoints];
                         } else {
                              // If parent not found after filtering, maybe show nothing or a message
                              pointsToPlot = [];
                         }
                     }


                    // --- Update UI based on filtered data ---
                     this.updateFilterRelevance(pointsToPlot); // Update relevance based on plot points
                    this.updateScenarioColorMapping(pointsToPlot); // Update colors based on plot points

                     // Populate overview cards: Use *all* points matching scenario/model filters, including drafts?
                     // Let's show *all* matching cards (drafts included) in the overview for selection.
                     let pointsForOverview = allPoints; // Start with everything again
                     // Apply scenario/model filters to overview points
                    if (this.selectedScenarios.length > 0) {
                        pointsForOverview = pointsForOverview.filter(point => this.selectedScenarios.includes(point.scenarioTitle));
                    }
                    if (this.selectedModels.length > 0) {
                         pointsForOverview = pointsForOverview.filter(point => this.selectedModels.includes(point.llmName));
                    }
                    // Limit overview cards, maybe prioritize completed?
                     pointsForOverview.sort((a,b) => (a.status === 'draft' ? 1 : -1) - (b.status === 'draft' ? 1: -1) || (b.isParent - a.isParent));
                     this.populateOverview(pointsForOverview.slice(0, 8)); // Show up to 8 cards

                    // Update scenario details ONLY if 2 cards are selected
                    if (this.selectedComparison.length === this.MAX_COMPARISON) {
                         // Find the full data for the selected comparison IDs from allPoints
                         const compData = allPoints.filter(point => this.selectedComparison.includes(point.id));
                         if (compData.length === 2) {
                             this.populateScenarioDetails(compData);
                         } else {
                              this.clearScenarioDetails(); // Clear if couldn't find both
                         }
                    } else {
                         this.clearScenarioDetails(); // Clear if not exactly 2 selected
                    }

                    // Create the plot using ONLY non-draft points
                    if (pointsToPlot.length === 0) {
                        this.showPlotMessage('No data points match the current filters.');
                    } else {
                        this.createPlot(pointsToPlot);
                    }

                    this.updateSelectedMedia(); // Update media based on selections
                     this.updateUserSurveysPreview(); // Refresh user survey preview list


                } catch (error) {
                    console.error('Error updating visualization:', error);
                    this.showErrorMessage('Error updating visualization.');
                } finally {
                    this.isUpdatingVisuals = false;
                }
            },

             /** Show a message in the plot area */
             showPlotMessage(message) {
                 const plotElement = document.getElementById('cube-plot');
                 if (plotElement) {
                     plotElement.innerHTML = `<div class="alert alert-warning text-center m-5">${message}</div>`;
                 }
             },

              /** Clear scenario details section */
             clearScenarioDetails() {
                 const scenarioAccordion = document.getElementById('scenarioAccordion');
                 if (scenarioAccordion) {
                     scenarioAccordion.innerHTML = `
                         <div class="text-center text-muted p-3">
                             Select two scenario cards above to compare details
                         </div>
                     `;
                 }
             },


            /**
             * Update the user surveys preview section (includes Draft status)
             */
            async updateUserSurveysPreview() {
                 const container = document.getElementById('user-surveys-preview');
                 if (!container) return;

                 try {
                     const isAuthenticated = await AuthManager.isUserAuthenticated();
                     if (!isAuthenticated) {
                          // Display login prompt
                          container.innerHTML = `
                            <div class="login-prompt">
                                <span>Log in to view your analyses or <span class="login-link" id="login-to-analyze-preview">create a new one</span></span>
                            </div>
                        `;
                         $('#login-to-analyze-preview').on('click', () => { AuthManager.login(); });
                         return;
                     }

                     const userSurveys = await UserSurveyManager.getUserSurveys(); // Fetches or gets from cache
                     if (!userSurveys || userSurveys.length === 0) {
                         container.innerHTML = `<div class="no-surveys-message">No analyses found.</div>`;
                         return;
                     }

                     // Sort by date (newest first)
                      userSurveys.sort((a, b) => new Date(b.lastModified || b.created || 0) - new Date(a.lastModified || a.created || 0));
                      const recentSurveys = userSurveys.slice(0, 5); // Show recent 5

                     const surveyItems = recentSurveys.map(survey => {
                         const title = ScenarioDataProcessor.escapeHTML(survey.metadata?.title || 'Untitled');
                         const date = new Date(survey.lastModified || survey.created || Date.now()).toLocaleDateString();
                         const status = survey.status || 'completed';
                         const statusText = status === 'draft' ? '<span class="survey-status-draft">Draft</span>' : '';
                         const surveyId = ScenarioDataProcessor.escapeHTML(survey.id);

                         // Combine title and status badge
                          const displayTitle = `<strong>${title}</strong> ${statusText}`;

                         return `
                             <li data-survey-id="${surveyId}">
                                 <span>${displayTitle} <span class="text-muted">(${date})</span></span>
                             </li>
                         `;
                     }).join('');

                     container.innerHTML = `<ul class="user-surveys-list">${surveyItems}</ul>`;

                     // Re-attach delegated click listener for viewing/editing from preview
                      $(container).off('click', 'li').on('click', 'li', async (event) => {
                          const surveyId = $(event.currentTarget).data('survey-id');
                          const survey = userSurveys.find(s => s.id === surveyId);
                          if (survey) {
                              if (survey.status === 'draft') {
                                   // Edit draft directly
                                   await UserSurveyManager.editSurvey(surveyId);
                              } else {
                                   // View completed survey
                                   await VisualizationManager.viewUserSurvey(surveyId);
                              }
                          }
                      });

                 } catch (error) {
                     console.error('Error updating user surveys preview:', error);
                     container.innerHTML = `<div class="text-danger">Error loading analyses.</div>`;
                 }
             },

            /** Create the 3D plot (Ensure drafts are EXCLUDED before calling this) */
             createPlot(pointsToPlot) { // Accepts only points intended for the plot
                 try {
                     console.log(`Plotting ${pointsToPlot.length} points.`);
                     if (pointsToPlot.length === 0) {
                         this.showPlotMessage('No completed analyses match the current filters.');
                         return;
                     }

                     const meshData = { /* ... as before ... */
                        type: 'mesh3d', x: [-8, 12, 12, -8, -8, 12, 12, -8], y: [0, 0, 0, 0, 8, 8, 8, 8], z: [-21.6, -21.6, 0, 0, -21.6, -21.6, 0, 0],
                        i: [0, 0, 4, 4, 0, 0, 2, 2, 0, 1], j: [1, 2, 5, 6, 1, 5, 3, 7, 0, 2], k: [2, 3, 6, 7, 5, 4, 7, 6, 3, 3],
                        opacity: 0.1, color: 'lightblue', showlegend: false, hoverinfo: 'none'
                    };
                     let plotData = [meshData];

                     // Add lines for parent-child relationships if alternates are shown
                     const parentPoints = pointsToPlot.filter(p => p.isParent);
                     const childPoints = pointsToPlot.filter(p => !p.isParent);
                     parentPoints.forEach(parentPoint => {
                        const childrenOfParent = childPoints.filter(p => p.parentId === parentPoint.id);
                        childrenOfParent.forEach(childPoint => {
                            plotData.push({ /* ... line data as before ... */
                                type: 'scatter3d', x: [parentPoint.x, childPoint.x], y: [parentPoint.z, childPoint.z], z: [parentPoint.y, childPoint.y],
                                mode: 'lines', line: { color: '#666', width: 2, dash: 'dash' }, hoverinfo: 'text',
                                hovertext: `${parentPoint.scenarioTitle} → ${childPoint.scenarioTitle}`, showlegend: false
                            });
                        });
                     });

                     // Add main scatter points (only completed surveys)
                     plotData.push({
                         type: 'scatter3d',
                         x: pointsToPlot.map(p => p.x),
                         y: pointsToPlot.map(p => p.z), // Z-axis in plotly is vertical
                         z: pointsToPlot.map(p => p.y), // Y-axis (Means/Sacrifice) is depth
                         mode: 'markers',
                         marker: {
                             size: pointsToPlot.map(p => (p.isUserSurvey ? 12 : (p.isParent ? 8 : 6))),
                             color: pointsToPlot.map(p => (p.isUserSurvey ? '#2ca02c' : this.getColorByCategory(p.overallCategory))), // Green for user surveys
                             opacity: pointsToPlot.map(p => (p.isUserSurvey ? 1 : 0.8)),
                             line: {
                                 color: pointsToPlot.map(p => (p.isUserSurvey ? '#228B22' : (this.scenarioColorMapping[p.scenarioTitle + '_' + p.llmName] || '#000'))),
                                 width: pointsToPlot.map(p => (p.isUserSurvey ? 4 : (p.isParent ? 3 : 2))) // Thicker border for user surveys
                             }
                         },
                         text: pointsToPlot.map(p => `
                            <b>${ScenarioDataProcessor.escapeHTML(p.scenarioTitle)}</b><br>
                            <b>Category:</b> ${ScenarioDataProcessor.escapeHTML(p.overallCategory)}<br>
                            <b>Model:</b> ${p.isUserSurvey ? '<strong>Your Analysis</strong>' : ScenarioDataProcessor.escapeHTML(p.llmName)}<br>
                            ${p.isParent ? '<b>Type:</b> Base Scenario' : '<b>Type:</b> Alternative'}<br>
                            <b>Position (X,Y,Z):</b> (${p.x?.toFixed(2)}, ${p.y?.toFixed(2)}, ${p.z?.toFixed(2)})
                         `),
                         hoverinfo: 'text',
                         showlegend: false
                     });

                     const layout = { /* ... as before ... */
                        margin: { l: 0, r: 0, b: 0, t: 0 },
                        scene: {
                            xaxis: { title: 'Ends (Self > Altruistic)', range: [-8, 12], titlefont: { size: 10 } }, // Updated label
                            yaxis: { title: 'Character (Habit > Will)', range: [0, 8], titlefont: { size: 10 } },    // Updated label (Mapped to Plotly Y)
                            zaxis: { title: 'Means (Low > High Sacrifice)', range: [-21.6, 0], titlefont: { size: 10 } }, // Updated label (Mapped to Plotly Z)
                            camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } },
                            aspectmode: 'cube'
                        }
                    };

                     Plotly.newPlot('cube-plot', plotData, layout, { displayModeBar: false, responsive: true });

                 } catch (error) {
                     console.error('Error creating plot:', error);
                     this.showPlotMessage('Error rendering visualization.');
                 }
             },

             // ... (rest of VisualizationManager methods: getColorByCategory, populateOverview, populateScenarioDetails, media controls, etc.)
            updateFilterRelevance(filteredPoints) { /* ... as before ... */ },
            updateModelRelevance(filteredPoints) { /* ... as before ... */ },
            updateScenarioRelevance(filteredPoints) { /* ... as before ... */ },
            updateScenarioColorMapping(filteredPoints) { /* ... as before ... */ },
            getColorByCategory(category) { /* ... as before ... */ },
            populateOverview(data) { /* ... make sure it uses isUserSurvey and status fields for display ... */
                 try {
                     const overviewDiv = document.getElementById('overview');
                     if (!overviewDiv) return;
                     if (!Array.isArray(data)) data = [data];

                      // Sort: Completed Parent > Completed Child > Draft Parent > Draft Child
                      data.sort((a, b) =>
                          (a.status === 'draft' ? 1 : 0) - (b.status === 'draft' ? 1 : 0) || // Drafts last
                          (a.isParent ? -1 : 1) - (b.isParent ? -1 : 1) || // Parents first within status
                           0
                      );
                      data = data.slice(0, 8); // Limit cards

                     const cards = data.map(item => {
                         const scores = this.getEthicsScoresFromDimensions(item.dimensions); // Use helper
                         const borderColor = this.scenarioColorMapping[item.scenarioTitle + '_' + item.llmName] || '#000';
                         const isUserSurvey = ScenarioDataProcessor.isUserSurvey(item);
                         const isDraft = item.status === 'draft';

                          let borderStyle = `border: 2px solid ${borderColor};`;
                          let cardBackground = '';
                          let titleSuffix = '';

                          if (isUserSurvey) {
                              borderStyle = `border: 3px solid #2ca02c;`; // Thicker green border
                              if (isDraft) {
                                   cardBackground = 'background-color: #f0f0f0; opacity: 0.8;'; // Greyish background for draft
                                   titleSuffix = '<span class="badge badge-secondary ml-1">Draft</span>';
                              } else {
                                   cardBackground = 'background-color: #f0fff4;'; // Light green for completed user survey
                              }
                          } else if(isDraft){
                                // Should not happen based on current logic, but handle defensively
                                cardBackground = 'background-color: #f8f9fa; opacity: 0.7;';
                                titleSuffix = '<span class="badge badge-secondary ml-1">Draft</span>';
                          }

                         const escapedId = ScenarioDataProcessor.escapeHTML(item.id);
                         const isSelectedClass = this.selectedComparison.includes(item.id) ? ' selected-card' : ''; // Add selection class

                         return `
                            <div class="comparison-card${isSelectedClass}" data-scenario-id="${escapedId}" style="${borderStyle} ${cardBackground}">
                                <h4>
                                     ${this.getScenarioTitleHTML(item)}
                                     <small>(${isUserSurvey ? '<strong>Your Analysis</strong>' : ScenarioDataProcessor.escapeHTML(item.llmName)} ${this.getCategoryBadgeHTML(item.overallCategory)})</small>
                                     ${titleSuffix}
                                </h4>
                                <div class="scenario-description">
                                     <span class="description-text">${ScenarioDataProcessor.escapeHTML(item.scenarioDescription || 'No description')}</span>
                                     <span class="read-more">Read more</span>
                                </div>
                                <div class="ethics-scores mt-1" style="font-size: 0.7rem;">
                                     <div>Deon: ${ScenarioDataProcessor.escapeHTML(String(scores.deontologyScore))}</div>
                                     <div>Util: ${ScenarioDataProcessor.escapeHTML(String(scores.utilitarianismScore))}</div>
                                     <div>Virt: ${ScenarioDataProcessor.escapeHTML(String(scores.virtueEthicsScore))}</div>
                                </div>
                            </div>`;
                     }).join('');

                     overviewDiv.innerHTML = cards;
                     this.checkDescriptions(); // Check for read more links
                      // No need to re-attach handlers if using delegation

                 } catch (error) { console.error('Error populating overview:', error); }
            },
              // Helper for populateOverview
              getEthicsScoresFromDimensions(dimensions) {
                 const scores = { deontologyScore: 'N/A', utilitarianismScore: 'N/A', virtueEthicsScore: 'N/A' };
                 try {
                     const philosophyDim = dimensions?.find(dim => dim.id === 'PhilosophicalAnalysis');
                     philosophyDim?.questions?.forEach(q => {
                         if (q.question === 'Deontology') scores.deontologyScore = q.score;
                         else if (q.question === 'Utilitarianism') scores.utilitarianismScore = q.score;
                         else if (q.question === 'Virtue Ethics') scores.virtueEthicsScore = q.score;
                     });
                 } catch (e) { /* ignore */ }
                 return scores;
             },
             // Helper for populateOverview
             getScenarioTitleHTML(item) {
                 const title = ScenarioDataProcessor.escapeHTML(item.scenarioTitle);
                 return item.url ? `${title} <a href="${ScenarioDataProcessor.escapeHTML(item.url)}" target="_blank" class="scenario-link"><i class="fas fa-external-link-alt fa-xs"></i></a>` : title;
             },
             // Helper for populateOverview
             getCategoryBadgeHTML(category) {
                if (!category) return '';
                 let normCat = ScenarioDataProcessor.normalizeCategory(category);
                 let className = `category-badge category-${normCat}`;
                 return `<span class="${className}">${ScenarioDataProcessor.escapeHTML(category)}</span>`;
             },

            populateScenarioDetails(scenarioData) { /* ... as before, ensure it uses ScenarioDataProcessor.escapeHTML ... */ },
            initializeMediaControls() { /* ... as before ... */ },
            // Make sure this uses event delegation
             attachComparisonCardHandlers() {
                 console.log('Attaching comparison card handlers via delegation');
                 // Use event delegation on the #overview container
                 $('#overview').off('click', '.comparison-card').on('click', '.comparison-card', (event) => {
                     // Prevent clicks on links inside the card from triggering selection
                     if ($(event.target).closest('a, .read-more').length > 0) {
                         return;
                     }
                     this.comparisonCardHandler(event); // Call the original handler logic
                 });
             },
            comparisonCardHandler(event) { /* ... logic as before ... */ },
            checkDescriptions() { /* ... as before ... */ },
            updateSelectedMedia() { /* ... as before ... */ },
            updateMediaDisplay(url) { /* ... as before ... */ },
            embedRedditContent(container, url) { /* ... as before ... */ },
            embedYouTubeContent(container, url) { /* ... as before ... */ },
            embedGenericContent(container, url) { /* ... as before ... */ },
            showFallbackMediaDisplay(container, url) { /* ... as before ... */ },
            showWarningMessage(message) { alert(message); },
            showErrorMessage(message) { alert(message); },
             // Ensure viewUserSurvey exists and works
            async viewUserSurvey(surveyId) { /* ... logic as before ... */
                 try {
                     const survey = (await UserSurveyManager.getUserSurveys()).find(s => s.id === surveyId);
                     if (!survey) { this.showErrorMessage(`Survey ${surveyId} not found.`); return; }

                     const displayPoint = UserSurveyManager.normalizeUserSurvey(survey); // Use normalize
                     if (!displayPoint) return;

                     // Ensure it's treated as a completed point for viewing
                     displayPoint.status = 'completed';

                      // Add/update this point in the main data (temporarily for viewing)
                     const existingIndex = ScenarioDataProcessor.dataPoints.findIndex(p => p.id === displayPoint.id);
                     if (existingIndex !== -1) ScenarioDataProcessor.dataPoints[existingIndex] = displayPoint;
                     else ScenarioDataProcessor.dataPoints.push(displayPoint);
                     // Also update displayPoints if it's a parent
                      const displayPointIndex = ScenarioDataProcessor.displayPoints.findIndex(dp => dp.id === displayPoint.id);
                      if (displayPointIndex !== -1) ScenarioDataProcessor.displayPoints[displayPointIndex] = displayPoint;
                      else if(displayPoint.isParent) ScenarioDataProcessor.displayPoints.push(displayPoint);


                     // Set selections for visualization
                     this.selectedScenarios = [displayPoint.scenarioTitle];
                     this.selectedModels = ["Your Analysis"]; // Ensure 'Your Analysis' is selected
                     this.selectedComparison = [displayPoint.id]; // Select this card

                      // Update filters to reflect selection
                      $('#scenarioFilter').val(this.selectedScenarios);
                      $('#modelFilter').val(this.selectedModels);
                      // Potentially update category filter too


                     this.updateVisualization(); // Refresh plot and overview

                     // Populate details (ensure it shows only this one if just one selected)
                     this.populateScenarioDetails([displayPoint]);

                     $('#userSurveysModal').modal('hide');
                     return true;
                 } catch (error) {
                     console.error('Error viewing user survey:', error);
                     this.showErrorMessage('Error viewing survey: ' + error.message);
                     return false;
                 }
            }

        };

        // Global utility functions (ensure they use the managers correctly)
        async function isUserAuthenticated() {
            return await AuthManager.isUserAuthenticated();
        }
        function showLoginPrompt() {
            alert('You need to be logged in to use this feature.');
            AuthManager.login();
        }

        // --- Initialization Logic ---
        async function initializeApplication() {
            try {
                console.log('Starting application initialization...');

                // Initialize Auth manager first
                await AuthManager.initialize().catch(error => {
                    console.warn('Auth initialization warning:', error);
                });

                // Initialize data processor (fetches API data AND integrates user surveys)
                await ScenarioDataProcessor.fetchScenarios().catch(error => {
                    console.error('Error fetching initial data:', error);
                    alert('Unable to load scenario data. Please refresh or try later.');
                });

                 // Initialize visualization manager AFTER data is loaded
                VisualizationManager.initialize();

                 // Initialize user survey manager AFTER data/viz managers
                UserSurveyManager.initialize();


                // Update auth UI (shows login/logout, user avatar)
                await updateAuthUI(); // This will also trigger updateUserSurveysPreview

                // Initial visualization render
                 VisualizationManager.updateVisualization();


                console.log('Application initialization completed successfully');

                // Periodic session check (optional but good)
                 setInterval(async () => {
                    try {
                        if (await AuthManager.isUserAuthenticated(true)) {
                            await AuthManager.getToken({ ignoreCache: true, timeoutInSeconds: 10 }).catch(() => {});
                        }
                    } catch (error) { console.warn('Session check error:', error); }
                }, 5 * 60 * 1000);

            } catch (error) {
                console.error('Critical error during application initialization:', error);
                alert('There was a problem loading the application. Please refresh the page.');
            }
        }

        // Update Auth UI Function (ensure it triggers survey preview update)
        async function updateAuthUI() {
             try {
                const isAuthenticated = await AuthManager.isUserAuthenticated(true); // Force check
                const elements = { /* ... get elements ... */
                    loginBtn: document.getElementById('login'), logoutBtn: document.getElementById('logout'),
                    userContainer: document.getElementById('user-container'), userAvatar: document.getElementById('user-avatar')
                };

                if (isAuthenticated) {
                    if (elements.loginBtn) elements.loginBtn.style.display = 'none';
                    if (elements.userContainer) elements.userContainer.classList.remove('d-none');
                    if (elements.logoutBtn) elements.logoutBtn.style.display = 'block';
                    try {
                        const user = await AuthManager.getUser();
                        if (user?.picture && elements.userAvatar) {
                             elements.userAvatar.src = user.picture;
                             elements.userAvatar.style.display = 'block';
                        }
                        AuthManager.scheduleTokenRefresh(); // Ensure refresh is scheduled
                        // Update survey preview AFTER confirming auth state
                        if (VisualizationManager.updateUserSurveysPreview) {
                           await VisualizationManager.updateUserSurveysPreview(); // Await this
                        }
                    } catch (profileError) { console.error('Error fetching profile:', profileError); }
                } else {
                     if (elements.loginBtn) elements.loginBtn.style.display = 'block';
                     if (elements.userContainer) elements.userContainer.classList.add('d-none');
                     if (elements.logoutBtn) elements.logoutBtn.style.display = 'none';
                     if (elements.userAvatar) elements.userAvatar.style.display = 'none';
                     // Update survey preview for logged out state
                      if (VisualizationManager.updateUserSurveysPreview) {
                         await VisualizationManager.updateUserSurveysPreview(); // Await this
                      }
                     if (AuthManager.tokenRefreshTimer) { clearTimeout(AuthManager.tokenRefreshTimer); AuthManager.tokenRefreshTimer = null; }
                }
            } catch (error) {
                console.error('Error updating auth UI:', error);
                 // Fallback UI
                 $('#login').show(); $('#user-container').addClass('d-none');
            }
        }


        // Run initialization on DOM ready
        document.addEventListener('DOMContentLoaded', initializeApplication);

    </script>
     <!-- Footer -->
     <footer style="background-color: #e9ecef; padding: 20px 0; text-align: center; margin-top: 40px; border-top: 1px solid #dee2e6;">
            <div class="container">
                <div class="row">
                    <div class="col-md-6 mx-auto">
                        <p>&copy; 2025 The Moral Cube. All rights reserved.</p>
                        <ul class="list-inline mb-0">
                            <li class="list-inline-item"><a href="/" style="color: #4A5568; text-decoration: none;">Home</a></li>
                            <li class="list-inline-item">|</li>
                            <li class="list-inline-item"><a href="/feedback.html" style="color: #4A5568; text-decoration: none;">Feedback</a></li>
                            <li class="list-inline-item">|</li>
                            <li class="list-inline-item"><a href="/privacy-policy.html" style="color: #4A5568; text-decoration: none;">Privacy Policy</a></li>
                            <li class="list-inline-item">|</li>
                            <li class="list-inline-item"><a href="/data-deletion.html" style="color: #4A5568; text-decoration: none;">Data Deletion</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </footer>
</body>
</html>